(self["webpackChunktei_shell"] = self["webpackChunktei_shell"] || []).push([["default-node_modules_ng2-pdf-viewer_fesm2020_ng2-pdf-viewer_mjs"],{

/***/ 7787:
/*!**********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _defineProperty = (__webpack_require__(/*! ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/defineProperty.js */ 64144)["default"]);
var _classPrivateMethodInitSpec = (__webpack_require__(/*! ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js */ 43798)["default"]);
var _classPrivateFieldInitSpec = (__webpack_require__(/*! ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js */ 97218)["default"]);
var _asyncToGenerator = (__webpack_require__(/*! ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/asyncToGenerator.js */ 79717)["default"]);
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else {}
})(this, () => {
  return /******/(() => {
    // webpackBootstrap
    /******/
    "use strict";

    /******/
    var __webpack_modules__ = [
      /* 0 */
    , ( /* 1 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;
      exports.arrayByteLength = arrayByteLength;
      exports.arraysToBytes = arraysToBytes;
      exports.assert = assert;
      exports.bytesToString = bytesToString;
      exports.createPromiseCapability = createPromiseCapability;
      exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
      exports.escapeString = escapeString;
      exports.getModificationDate = getModificationDate;
      exports.getVerbosityLevel = getVerbosityLevel;
      exports.info = info;
      exports.isArrayBuffer = isArrayBuffer;
      exports.isArrayEqual = isArrayEqual;
      exports.isAscii = isAscii;
      exports.objectFromMap = objectFromMap;
      exports.objectSize = objectSize;
      exports.setVerbosityLevel = setVerbosityLevel;
      exports.shadow = shadow;
      exports.string32 = string32;
      exports.stringToBytes = stringToBytes;
      exports.stringToPDFString = stringToPDFString;
      exports.stringToUTF16BEString = stringToUTF16BEString;
      exports.stringToUTF8String = stringToUTF8String;
      exports.unreachable = unreachable;
      exports.utf8StringToString = utf8StringToString;
      exports.warn = warn;
      __w_pdfjs_require__(2);
      const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
      exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
      const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
      exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
      const RenderingIntentFlag = {
        ANY: 0x01,
        DISPLAY: 0x02,
        PRINT: 0x04,
        ANNOTATIONS_FORMS: 0x10,
        ANNOTATIONS_STORAGE: 0x20,
        ANNOTATIONS_DISABLE: 0x40,
        OPLIST: 0x100
      };
      exports.RenderingIntentFlag = RenderingIntentFlag;
      const AnnotationMode = {
        DISABLE: 0,
        ENABLE: 1,
        ENABLE_FORMS: 2,
        ENABLE_STORAGE: 3
      };
      exports.AnnotationMode = AnnotationMode;
      const PermissionFlag = {
        PRINT: 0x04,
        MODIFY_CONTENTS: 0x08,
        COPY: 0x10,
        MODIFY_ANNOTATIONS: 0x20,
        FILL_INTERACTIVE_FORMS: 0x100,
        COPY_FOR_ACCESSIBILITY: 0x200,
        ASSEMBLE: 0x400,
        PRINT_HIGH_QUALITY: 0x800
      };
      exports.PermissionFlag = PermissionFlag;
      const TextRenderingMode = {
        FILL: 0,
        STROKE: 1,
        FILL_STROKE: 2,
        INVISIBLE: 3,
        FILL_ADD_TO_PATH: 4,
        STROKE_ADD_TO_PATH: 5,
        FILL_STROKE_ADD_TO_PATH: 6,
        ADD_TO_PATH: 7,
        FILL_STROKE_MASK: 3,
        ADD_TO_PATH_FLAG: 4
      };
      exports.TextRenderingMode = TextRenderingMode;
      const ImageKind = {
        GRAYSCALE_1BPP: 1,
        RGB_24BPP: 2,
        RGBA_32BPP: 3
      };
      exports.ImageKind = ImageKind;
      const AnnotationType = {
        TEXT: 1,
        LINK: 2,
        FREETEXT: 3,
        LINE: 4,
        SQUARE: 5,
        CIRCLE: 6,
        POLYGON: 7,
        POLYLINE: 8,
        HIGHLIGHT: 9,
        UNDERLINE: 10,
        SQUIGGLY: 11,
        STRIKEOUT: 12,
        STAMP: 13,
        CARET: 14,
        INK: 15,
        POPUP: 16,
        FILEATTACHMENT: 17,
        SOUND: 18,
        MOVIE: 19,
        WIDGET: 20,
        SCREEN: 21,
        PRINTERMARK: 22,
        TRAPNET: 23,
        WATERMARK: 24,
        THREED: 25,
        REDACT: 26
      };
      exports.AnnotationType = AnnotationType;
      const AnnotationStateModelType = {
        MARKED: "Marked",
        REVIEW: "Review"
      };
      exports.AnnotationStateModelType = AnnotationStateModelType;
      const AnnotationMarkedState = {
        MARKED: "Marked",
        UNMARKED: "Unmarked"
      };
      exports.AnnotationMarkedState = AnnotationMarkedState;
      const AnnotationReviewState = {
        ACCEPTED: "Accepted",
        REJECTED: "Rejected",
        CANCELLED: "Cancelled",
        COMPLETED: "Completed",
        NONE: "None"
      };
      exports.AnnotationReviewState = AnnotationReviewState;
      const AnnotationReplyType = {
        GROUP: "Group",
        REPLY: "R"
      };
      exports.AnnotationReplyType = AnnotationReplyType;
      const AnnotationFlag = {
        INVISIBLE: 0x01,
        HIDDEN: 0x02,
        PRINT: 0x04,
        NOZOOM: 0x08,
        NOROTATE: 0x10,
        NOVIEW: 0x20,
        READONLY: 0x40,
        LOCKED: 0x80,
        TOGGLENOVIEW: 0x100,
        LOCKEDCONTENTS: 0x200
      };
      exports.AnnotationFlag = AnnotationFlag;
      const AnnotationFieldFlag = {
        READONLY: 0x0000001,
        REQUIRED: 0x0000002,
        NOEXPORT: 0x0000004,
        MULTILINE: 0x0001000,
        PASSWORD: 0x0002000,
        NOTOGGLETOOFF: 0x0004000,
        RADIO: 0x0008000,
        PUSHBUTTON: 0x0010000,
        COMBO: 0x0020000,
        EDIT: 0x0040000,
        SORT: 0x0080000,
        FILESELECT: 0x0100000,
        MULTISELECT: 0x0200000,
        DONOTSPELLCHECK: 0x0400000,
        DONOTSCROLL: 0x0800000,
        COMB: 0x1000000,
        RICHTEXT: 0x2000000,
        RADIOSINUNISON: 0x2000000,
        COMMITONSELCHANGE: 0x4000000
      };
      exports.AnnotationFieldFlag = AnnotationFieldFlag;
      const AnnotationBorderStyleType = {
        SOLID: 1,
        DASHED: 2,
        BEVELED: 3,
        INSET: 4,
        UNDERLINE: 5
      };
      exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
      const AnnotationActionEventType = {
        E: "Mouse Enter",
        X: "Mouse Exit",
        D: "Mouse Down",
        U: "Mouse Up",
        Fo: "Focus",
        Bl: "Blur",
        PO: "PageOpen",
        PC: "PageClose",
        PV: "PageVisible",
        PI: "PageInvisible",
        K: "Keystroke",
        F: "Format",
        V: "Validate",
        C: "Calculate"
      };
      exports.AnnotationActionEventType = AnnotationActionEventType;
      const DocumentActionEventType = {
        WC: "WillClose",
        WS: "WillSave",
        DS: "DidSave",
        WP: "WillPrint",
        DP: "DidPrint"
      };
      exports.DocumentActionEventType = DocumentActionEventType;
      const PageActionEventType = {
        O: "PageOpen",
        C: "PageClose"
      };
      exports.PageActionEventType = PageActionEventType;
      const StreamType = {
        UNKNOWN: "UNKNOWN",
        FLATE: "FLATE",
        LZW: "LZW",
        DCT: "DCT",
        JPX: "JPX",
        JBIG: "JBIG",
        A85: "A85",
        AHX: "AHX",
        CCF: "CCF",
        RLX: "RLX"
      };
      exports.StreamType = StreamType;
      const FontType = {
        UNKNOWN: "UNKNOWN",
        TYPE1: "TYPE1",
        TYPE1STANDARD: "TYPE1STANDARD",
        TYPE1C: "TYPE1C",
        CIDFONTTYPE0: "CIDFONTTYPE0",
        CIDFONTTYPE0C: "CIDFONTTYPE0C",
        TRUETYPE: "TRUETYPE",
        CIDFONTTYPE2: "CIDFONTTYPE2",
        TYPE3: "TYPE3",
        OPENTYPE: "OPENTYPE",
        TYPE0: "TYPE0",
        MMTYPE1: "MMTYPE1"
      };
      exports.FontType = FontType;
      const VerbosityLevel = {
        ERRORS: 0,
        WARNINGS: 1,
        INFOS: 5
      };
      exports.VerbosityLevel = VerbosityLevel;
      const CMapCompressionType = {
        NONE: 0,
        BINARY: 1,
        STREAM: 2
      };
      exports.CMapCompressionType = CMapCompressionType;
      const OPS = {
        dependency: 1,
        setLineWidth: 2,
        setLineCap: 3,
        setLineJoin: 4,
        setMiterLimit: 5,
        setDash: 6,
        setRenderingIntent: 7,
        setFlatness: 8,
        setGState: 9,
        save: 10,
        restore: 11,
        transform: 12,
        moveTo: 13,
        lineTo: 14,
        curveTo: 15,
        curveTo2: 16,
        curveTo3: 17,
        closePath: 18,
        rectangle: 19,
        stroke: 20,
        closeStroke: 21,
        fill: 22,
        eoFill: 23,
        fillStroke: 24,
        eoFillStroke: 25,
        closeFillStroke: 26,
        closeEOFillStroke: 27,
        endPath: 28,
        clip: 29,
        eoClip: 30,
        beginText: 31,
        endText: 32,
        setCharSpacing: 33,
        setWordSpacing: 34,
        setHScale: 35,
        setLeading: 36,
        setFont: 37,
        setTextRenderingMode: 38,
        setTextRise: 39,
        moveText: 40,
        setLeadingMoveText: 41,
        setTextMatrix: 42,
        nextLine: 43,
        showText: 44,
        showSpacedText: 45,
        nextLineShowText: 46,
        nextLineSetSpacingShowText: 47,
        setCharWidth: 48,
        setCharWidthAndBounds: 49,
        setStrokeColorSpace: 50,
        setFillColorSpace: 51,
        setStrokeColor: 52,
        setStrokeColorN: 53,
        setFillColor: 54,
        setFillColorN: 55,
        setStrokeGray: 56,
        setFillGray: 57,
        setStrokeRGBColor: 58,
        setFillRGBColor: 59,
        setStrokeCMYKColor: 60,
        setFillCMYKColor: 61,
        shadingFill: 62,
        beginInlineImage: 63,
        beginImageData: 64,
        endInlineImage: 65,
        paintXObject: 66,
        markPoint: 67,
        markPointProps: 68,
        beginMarkedContent: 69,
        beginMarkedContentProps: 70,
        endMarkedContent: 71,
        beginCompat: 72,
        endCompat: 73,
        paintFormXObjectBegin: 74,
        paintFormXObjectEnd: 75,
        beginGroup: 76,
        endGroup: 77,
        beginAnnotations: 78,
        endAnnotations: 79,
        beginAnnotation: 80,
        endAnnotation: 81,
        paintJpegXObject: 82,
        paintImageMaskXObject: 83,
        paintImageMaskXObjectGroup: 84,
        paintImageXObject: 85,
        paintInlineImageXObject: 86,
        paintInlineImageXObjectGroup: 87,
        paintImageXObjectRepeat: 88,
        paintImageMaskXObjectRepeat: 89,
        paintSolidColorImageMask: 90,
        constructPath: 91
      };
      exports.OPS = OPS;
      const UNSUPPORTED_FEATURES = {
        unknown: "unknown",
        forms: "forms",
        javaScript: "javaScript",
        signatures: "signatures",
        smask: "smask",
        shadingPattern: "shadingPattern",
        font: "font",
        errorTilingPattern: "errorTilingPattern",
        errorExtGState: "errorExtGState",
        errorXObject: "errorXObject",
        errorFontLoadType3: "errorFontLoadType3",
        errorFontState: "errorFontState",
        errorFontMissing: "errorFontMissing",
        errorFontTranslate: "errorFontTranslate",
        errorColorSpace: "errorColorSpace",
        errorOperatorList: "errorOperatorList",
        errorFontToUnicode: "errorFontToUnicode",
        errorFontLoadNative: "errorFontLoadNative",
        errorFontBuildPath: "errorFontBuildPath",
        errorFontGetPath: "errorFontGetPath",
        errorMarkedContent: "errorMarkedContent",
        errorContentSubStream: "errorContentSubStream"
      };
      exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
      const PasswordResponses = {
        NEED_PASSWORD: 1,
        INCORRECT_PASSWORD: 2
      };
      exports.PasswordResponses = PasswordResponses;
      let verbosity = VerbosityLevel.WARNINGS;
      function setVerbosityLevel(level) {
        if (Number.isInteger(level)) {
          verbosity = level;
        }
      }
      function getVerbosityLevel() {
        return verbosity;
      }
      function info(msg) {
        if (verbosity >= VerbosityLevel.INFOS) {
          console.log(`Info: ${msg}`);
        }
      }
      function warn(msg) {
        if (verbosity >= VerbosityLevel.WARNINGS) {
          console.log(`Warning: ${msg}`);
        }
      }
      function unreachable(msg) {
        throw new Error(msg);
      }
      function assert(cond, msg) {
        if (!cond) {
          unreachable(msg);
        }
      }
      function _isValidProtocol(url) {
        if (!url) {
          return false;
        }
        switch (url.protocol) {
          case "http:":
          case "https:":
          case "ftp:":
          case "mailto:":
          case "tel:":
            return true;
          default:
            return false;
        }
      }
      function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
        if (!url) {
          return null;
        }
        try {
          if (options && typeof url === "string") {
            if (options.addDefaultProtocol && url.startsWith("www.")) {
              const dots = url.match(/\./g);
              if (dots && dots.length >= 2) {
                url = `http://${url}`;
              }
            }
            if (options.tryConvertEncoding) {
              try {
                url = stringToUTF8String(url);
              } catch (ex) {}
            }
          }
          const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
          if (_isValidProtocol(absoluteUrl)) {
            return absoluteUrl;
          }
        } catch (ex) {}
        return null;
      }
      function shadow(obj, prop, value) {
        Object.defineProperty(obj, prop, {
          value,
          enumerable: true,
          configurable: true,
          writable: false
        });
        return value;
      }
      const BaseException = function BaseExceptionClosure() {
        function BaseException(message, name) {
          if (this.constructor === BaseException) {
            unreachable("Cannot initialize BaseException.");
          }
          this.message = message;
          this.name = name;
        }
        BaseException.prototype = new Error();
        BaseException.constructor = BaseException;
        return BaseException;
      }();
      exports.BaseException = BaseException;
      class PasswordException extends BaseException {
        constructor(msg, code) {
          super(msg, "PasswordException");
          this.code = code;
        }
      }
      exports.PasswordException = PasswordException;
      class UnknownErrorException extends BaseException {
        constructor(msg, details) {
          super(msg, "UnknownErrorException");
          this.details = details;
        }
      }
      exports.UnknownErrorException = UnknownErrorException;
      class InvalidPDFException extends BaseException {
        constructor(msg) {
          super(msg, "InvalidPDFException");
        }
      }
      exports.InvalidPDFException = InvalidPDFException;
      class MissingPDFException extends BaseException {
        constructor(msg) {
          super(msg, "MissingPDFException");
        }
      }
      exports.MissingPDFException = MissingPDFException;
      class UnexpectedResponseException extends BaseException {
        constructor(msg, status) {
          super(msg, "UnexpectedResponseException");
          this.status = status;
        }
      }
      exports.UnexpectedResponseException = UnexpectedResponseException;
      class FormatError extends BaseException {
        constructor(msg) {
          super(msg, "FormatError");
        }
      }
      exports.FormatError = FormatError;
      class AbortException extends BaseException {
        constructor(msg) {
          super(msg, "AbortException");
        }
      }
      exports.AbortException = AbortException;
      function bytesToString(bytes) {
        if (typeof bytes !== "object" || bytes === null || bytes.length === undefined) {
          unreachable("Invalid argument for bytesToString");
        }
        const length = bytes.length;
        const MAX_ARGUMENT_COUNT = 8192;
        if (length < MAX_ARGUMENT_COUNT) {
          return String.fromCharCode.apply(null, bytes);
        }
        const strBuf = [];
        for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
          const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
          const chunk = bytes.subarray(i, chunkEnd);
          strBuf.push(String.fromCharCode.apply(null, chunk));
        }
        return strBuf.join("");
      }
      function stringToBytes(str) {
        if (typeof str !== "string") {
          unreachable("Invalid argument for stringToBytes");
        }
        const length = str.length;
        const bytes = new Uint8Array(length);
        for (let i = 0; i < length; ++i) {
          bytes[i] = str.charCodeAt(i) & 0xff;
        }
        return bytes;
      }
      function arrayByteLength(arr) {
        if (arr.length !== undefined) {
          return arr.length;
        }
        if (arr.byteLength !== undefined) {
          return arr.byteLength;
        }
        unreachable("Invalid argument for arrayByteLength");
      }
      function arraysToBytes(arr) {
        const length = arr.length;
        if (length === 1 && arr[0] instanceof Uint8Array) {
          return arr[0];
        }
        let resultLength = 0;
        for (let i = 0; i < length; i++) {
          resultLength += arrayByteLength(arr[i]);
        }
        let pos = 0;
        const data = new Uint8Array(resultLength);
        for (let i = 0; i < length; i++) {
          let item = arr[i];
          if (!(item instanceof Uint8Array)) {
            if (typeof item === "string") {
              item = stringToBytes(item);
            } else {
              item = new Uint8Array(item);
            }
          }
          const itemLength = item.byteLength;
          data.set(item, pos);
          pos += itemLength;
        }
        return data;
      }
      function string32(value) {
        return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
      }
      function objectSize(obj) {
        return Object.keys(obj).length;
      }
      function objectFromMap(map) {
        const obj = Object.create(null);
        for (const [key, value] of map) {
          obj[key] = value;
        }
        return obj;
      }
      function isLittleEndian() {
        const buffer8 = new Uint8Array(4);
        buffer8[0] = 1;
        const view32 = new Uint32Array(buffer8.buffer, 0, 1);
        return view32[0] === 1;
      }
      function isEvalSupported() {
        try {
          new Function("");
          return true;
        } catch (e) {
          return false;
        }
      }
      class FeatureTest {
        static get isLittleEndian() {
          return shadow(this, "isLittleEndian", isLittleEndian());
        }
        static get isEvalSupported() {
          return shadow(this, "isEvalSupported", isEvalSupported());
        }
        static get isOffscreenCanvasSupported() {
          return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
        }
      }
      exports.FeatureTest = FeatureTest;
      const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));
      class Util {
        static makeHexColor(r, g, b) {
          return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
        }
        static scaleMinMax(transform, minMax) {
          let temp;
          if (transform[0]) {
            if (transform[0] < 0) {
              temp = minMax[0];
              minMax[0] = minMax[1];
              minMax[1] = temp;
            }
            minMax[0] *= transform[0];
            minMax[1] *= transform[0];
            if (transform[3] < 0) {
              temp = minMax[2];
              minMax[2] = minMax[3];
              minMax[3] = temp;
            }
            minMax[2] *= transform[3];
            minMax[3] *= transform[3];
          } else {
            temp = minMax[0];
            minMax[0] = minMax[2];
            minMax[2] = temp;
            temp = minMax[1];
            minMax[1] = minMax[3];
            minMax[3] = temp;
            if (transform[1] < 0) {
              temp = minMax[2];
              minMax[2] = minMax[3];
              minMax[3] = temp;
            }
            minMax[2] *= transform[1];
            minMax[3] *= transform[1];
            if (transform[2] < 0) {
              temp = minMax[0];
              minMax[0] = minMax[1];
              minMax[1] = temp;
            }
            minMax[0] *= transform[2];
            minMax[1] *= transform[2];
          }
          minMax[0] += transform[4];
          minMax[1] += transform[4];
          minMax[2] += transform[5];
          minMax[3] += transform[5];
        }
        static transform(m1, m2) {
          return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
        }
        static applyTransform(p, m) {
          const xt = p[0] * m[0] + p[1] * m[2] + m[4];
          const yt = p[0] * m[1] + p[1] * m[3] + m[5];
          return [xt, yt];
        }
        static applyInverseTransform(p, m) {
          const d = m[0] * m[3] - m[1] * m[2];
          const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
          const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
          return [xt, yt];
        }
        static getAxialAlignedBoundingBox(r, m) {
          const p1 = Util.applyTransform(r, m);
          const p2 = Util.applyTransform(r.slice(2, 4), m);
          const p3 = Util.applyTransform([r[0], r[3]], m);
          const p4 = Util.applyTransform([r[2], r[1]], m);
          return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
        }
        static inverseTransform(m) {
          const d = m[0] * m[3] - m[1] * m[2];
          return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
        }
        static apply3dTransform(m, v) {
          return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
        }
        static singularValueDecompose2dScale(m) {
          const transpose = [m[0], m[2], m[1], m[3]];
          const a = m[0] * transpose[0] + m[1] * transpose[2];
          const b = m[0] * transpose[1] + m[1] * transpose[3];
          const c = m[2] * transpose[0] + m[3] * transpose[2];
          const d = m[2] * transpose[1] + m[3] * transpose[3];
          const first = (a + d) / 2;
          const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
          const sx = first + second || 1;
          const sy = first - second || 1;
          return [Math.sqrt(sx), Math.sqrt(sy)];
        }
        static normalizeRect(rect) {
          const r = rect.slice(0);
          if (rect[0] > rect[2]) {
            r[0] = rect[2];
            r[2] = rect[0];
          }
          if (rect[1] > rect[3]) {
            r[1] = rect[3];
            r[3] = rect[1];
          }
          return r;
        }
        static intersect(rect1, rect2) {
          const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
          const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
          if (xLow > xHigh) {
            return null;
          }
          const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
          const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
          if (yLow > yHigh) {
            return null;
          }
          return [xLow, yLow, xHigh, yHigh];
        }
        static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
          const tvalues = [],
            bounds = [[], []];
          let a, b, c, t, t1, t2, b2ac, sqrtb2ac;
          for (let i = 0; i < 2; ++i) {
            if (i === 0) {
              b = 6 * x0 - 12 * x1 + 6 * x2;
              a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
              c = 3 * x1 - 3 * x0;
            } else {
              b = 6 * y0 - 12 * y1 + 6 * y2;
              a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
              c = 3 * y1 - 3 * y0;
            }
            if (Math.abs(a) < 1e-12) {
              if (Math.abs(b) < 1e-12) {
                continue;
              }
              t = -c / b;
              if (0 < t && t < 1) {
                tvalues.push(t);
              }
              continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = Math.sqrt(b2ac);
            if (b2ac < 0) {
              continue;
            }
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (0 < t1 && t1 < 1) {
              tvalues.push(t1);
            }
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (0 < t2 && t2 < 1) {
              tvalues.push(t2);
            }
          }
          let j = tvalues.length,
            mt;
          const jlen = j;
          while (j--) {
            t = tvalues[j];
            mt = 1 - t;
            bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
            bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
          }
          bounds[0][jlen] = x0;
          bounds[1][jlen] = y0;
          bounds[0][jlen + 1] = x3;
          bounds[1][jlen + 1] = y3;
          bounds[0].length = bounds[1].length = jlen + 2;
          return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
        }
      }
      exports.Util = Util;
      const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];
      function stringToPDFString(str) {
        if (str[0] >= "\xEF") {
          let encoding;
          if (str[0] === "\xFE" && str[1] === "\xFF") {
            encoding = "utf-16be";
          } else if (str[0] === "\xFF" && str[1] === "\xFE") {
            encoding = "utf-16le";
          } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
            encoding = "utf-8";
          }
          if (encoding) {
            try {
              const decoder = new TextDecoder(encoding, {
                fatal: true
              });
              const buffer = stringToBytes(str);
              return decoder.decode(buffer);
            } catch (ex) {
              warn(`stringToPDFString: "${ex}".`);
            }
          }
        }
        const strBuf = [];
        for (let i = 0, ii = str.length; i < ii; i++) {
          const code = PDFStringTranslateTable[str.charCodeAt(i)];
          strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
        }
        return strBuf.join("");
      }
      function escapeString(str) {
        return str.replace(/([()\\\n\r])/g, match => {
          if (match === "\n") {
            return "\\n";
          } else if (match === "\r") {
            return "\\r";
          }
          return `\\${match}`;
        });
      }
      function isAscii(str) {
        return /^[\x00-\x7F]*$/.test(str);
      }
      function stringToUTF16BEString(str) {
        const buf = ["\xFE\xFF"];
        for (let i = 0, ii = str.length; i < ii; i++) {
          const char = str.charCodeAt(i);
          buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));
        }
        return buf.join("");
      }
      function stringToUTF8String(str) {
        return decodeURIComponent(escape(str));
      }
      function utf8StringToString(str) {
        return unescape(encodeURIComponent(str));
      }
      function isArrayBuffer(v) {
        return typeof v === "object" && v !== null && v.byteLength !== undefined;
      }
      function isArrayEqual(arr1, arr2) {
        if (arr1.length !== arr2.length) {
          return false;
        }
        for (let i = 0, ii = arr1.length; i < ii; i++) {
          if (arr1[i] !== arr2[i]) {
            return false;
          }
        }
        return true;
      }
      function getModificationDate(date = new Date()) {
        const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
        return buffer.join("");
      }
      function createPromiseCapability() {
        const capability = Object.create(null);
        let isSettled = false;
        Object.defineProperty(capability, "settled", {
          get() {
            return isSettled;
          }
        });
        capability.promise = new Promise(function (resolve, reject) {
          capability.resolve = function (data) {
            isSettled = true;
            resolve(data);
          };
          capability.reject = function (reason) {
            isSettled = true;
            reject(reason);
          };
        });
        return capability;
      }

      /***/
    }), ( /* 2 */
    /***/(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {
      var _is_node = __w_pdfjs_require__(3);
      ;

      /***/
    }), ( /* 3 */
    /***/(__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isNodeJS = void 0;
      const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
      exports.isNodeJS = isNodeJS;

      /***/
    }), ( /* 4 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
      exports.getDocument = getDocument;
      exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
      exports.version = void 0;
      var _util = __w_pdfjs_require__(1);
      var _display_utils = __w_pdfjs_require__(5);
      var _font_loader = __w_pdfjs_require__(7);
      var _annotation_storage = __w_pdfjs_require__(8);
      var _canvas = __w_pdfjs_require__(10);
      var _worker_options = __w_pdfjs_require__(13);
      var _is_node = __w_pdfjs_require__(3);
      var _message_handler = __w_pdfjs_require__(14);
      var _metadata = __w_pdfjs_require__(15);
      var _optional_content_config = __w_pdfjs_require__(16);
      var _transport_stream = __w_pdfjs_require__(17);
      var _xfa_text = __w_pdfjs_require__(18);
      const DEFAULT_RANGE_CHUNK_SIZE = 65536;
      const RENDERING_CANCELLED_TIMEOUT = 100;
      let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
      exports.DefaultCanvasFactory = DefaultCanvasFactory;
      let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
      exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
      let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
      exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
      if (_is_node.isNodeJS) {
        const {
          NodeCanvasFactory,
          NodeCMapReaderFactory,
          NodeStandardFontDataFactory
        } = __w_pdfjs_require__(19);
        exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;
        exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;
        exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;
      }
      let createPDFNetworkStream;
      function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
        createPDFNetworkStream = pdfNetworkStreamFactory;
      }
      function getDocument(src) {
        const task = new PDFDocumentLoadingTask();
        let source;
        if (typeof src === "string" || src instanceof URL) {
          source = {
            url: src
          };
        } else if ((0, _util.isArrayBuffer)(src)) {
          source = {
            data: src
          };
        } else if (src instanceof PDFDataRangeTransport) {
          source = {
            range: src
          };
        } else {
          if (typeof src !== "object") {
            throw new Error("Invalid parameter in getDocument, " + "need either string, URL, Uint8Array, or parameter object.");
          }
          if (!src.url && !src.data && !src.range) {
            throw new Error("Invalid parameter object: need either .data, .range or .url");
          }
          source = src;
        }
        const params = Object.create(null);
        let rangeTransport = null,
          worker = null;
        for (const key in source) {
          const value = source[key];
          switch (key) {
            case "url":
              if (typeof window !== "undefined") {
                try {
                  params[key] = new URL(value, window.location).href;
                  continue;
                } catch (ex) {
                  (0, _util.warn)(`Cannot create valid URL: "${ex}".`);
                }
              } else if (typeof value === "string" || value instanceof URL) {
                params[key] = value.toString();
                continue;
              }
              throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");
            case "range":
              rangeTransport = value;
              continue;
            case "worker":
              worker = value;
              continue;
            case "data":
              if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
                params[key] = new Uint8Array(value);
              } else if (value instanceof Uint8Array) {
                break;
              } else if (typeof value === "string") {
                params[key] = (0, _util.stringToBytes)(value);
              } else if (typeof value === "object" && value !== null && !isNaN(value.length)) {
                params[key] = new Uint8Array(value);
              } else if ((0, _util.isArrayBuffer)(value)) {
                params[key] = new Uint8Array(value);
              } else {
                throw new Error("Invalid PDF binary data: either typed array, " + "string, or array-like object is expected in the data property.");
              }
              continue;
          }
          params[key] = value;
        }
        params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
        params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
        params.ignoreErrors = params.stopAtErrors !== true;
        params.fontExtraProperties = params.fontExtraProperties === true;
        params.pdfBug = params.pdfBug === true;
        params.enableXfa = params.enableXfa === true;
        if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {
          params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;
        }
        if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
          params.docBaseUrl = null;
        }
        if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {
          params.maxImageSize = -1;
        }
        if (typeof params.cMapUrl !== "string") {
          params.cMapUrl = null;
        }
        if (typeof params.standardFontDataUrl !== "string") {
          params.standardFontDataUrl = null;
        }
        if (typeof params.useWorkerFetch !== "boolean") {
          params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
        }
        if (typeof params.isEvalSupported !== "boolean") {
          params.isEvalSupported = true;
        }
        if (typeof params.disableFontFace !== "boolean") {
          params.disableFontFace = _is_node.isNodeJS;
        }
        if (typeof params.useSystemFonts !== "boolean") {
          params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
        }
        if (typeof params.ownerDocument !== "object" || params.ownerDocument === null) {
          params.ownerDocument = globalThis.document;
        }
        if (typeof params.disableRange !== "boolean") {
          params.disableRange = false;
        }
        if (typeof params.disableStream !== "boolean") {
          params.disableStream = false;
        }
        if (typeof params.disableAutoFetch !== "boolean") {
          params.disableAutoFetch = false;
        }
        (0, _util.setVerbosityLevel)(params.verbosity);
        if (!worker) {
          const workerParams = {
            verbosity: params.verbosity,
            port: _worker_options.GlobalWorkerOptions.workerPort
          };
          worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
          task._worker = worker;
        }
        const docId = task.docId;
        worker.promise.then(function () {
          if (task.destroyed) {
            throw new Error("Loading aborted");
          }
          const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);
          const networkStreamPromise = new Promise(function (resolve) {
            let networkStream;
            if (rangeTransport) {
              networkStream = new _transport_stream.PDFDataTransportStream({
                length: params.length,
                initialData: params.initialData,
                progressiveDone: params.progressiveDone,
                contentDispositionFilename: params.contentDispositionFilename,
                disableRange: params.disableRange,
                disableStream: params.disableStream
              }, rangeTransport);
            } else if (!params.data) {
              networkStream = createPDFNetworkStream({
                url: params.url,
                length: params.length,
                httpHeaders: params.httpHeaders,
                withCredentials: params.withCredentials,
                rangeChunkSize: params.rangeChunkSize,
                disableRange: params.disableRange,
                disableStream: params.disableStream
              });
            }
            resolve(networkStream);
          });
          return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {
            if (task.destroyed) {
              throw new Error("Loading aborted");
            }
            const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
            const transport = new WorkerTransport(messageHandler, task, networkStream, params);
            task._transport = transport;
            messageHandler.send("Ready", null);
          });
        }).catch(task._capability.reject);
        return task;
      }
      function _fetchDocument(_x, _x2, _x3, _x4) {
        return _fetchDocument2.apply(this, arguments);
      }
      function _fetchDocument2() {
        _fetchDocument2 = _asyncToGenerator(function* (worker, source, pdfDataRangeTransport, docId) {
          if (worker.destroyed) {
            throw new Error("Worker was destroyed");
          }
          if (pdfDataRangeTransport) {
            source.length = pdfDataRangeTransport.length;
            source.initialData = pdfDataRangeTransport.initialData;
            source.progressiveDone = pdfDataRangeTransport.progressiveDone;
            source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
          }
          const workerId = yield worker.messageHandler.sendWithPromise("GetDocRequest", {
            docId,
            apiVersion: '2.14.305',
            source: {
              data: source.data,
              url: source.url,
              password: source.password,
              disableAutoFetch: source.disableAutoFetch,
              rangeChunkSize: source.rangeChunkSize,
              length: source.length
            },
            maxImageSize: source.maxImageSize,
            disableFontFace: source.disableFontFace,
            docBaseUrl: source.docBaseUrl,
            ignoreErrors: source.ignoreErrors,
            isEvalSupported: source.isEvalSupported,
            fontExtraProperties: source.fontExtraProperties,
            enableXfa: source.enableXfa,
            useSystemFonts: source.useSystemFonts,
            cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
            standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
          });
          if (worker.destroyed) {
            throw new Error("Worker was destroyed");
          }
          return workerId;
        });
        return _fetchDocument2.apply(this, arguments);
      }
      class PDFDocumentLoadingTask {
        constructor() {
          var _PDFDocumentLoadingTa, _PDFDocumentLoadingTa2;
          this._capability = (0, _util.createPromiseCapability)();
          this._transport = null;
          this._worker = null;
          this.docId = `d${(_docId._ = (_PDFDocumentLoadingTa = _docId._, _PDFDocumentLoadingTa2 = _PDFDocumentLoadingTa++, _PDFDocumentLoadingTa), _PDFDocumentLoadingTa2)}`;
          this.destroyed = false;
          this.onPassword = null;
          this.onProgress = null;
          this.onUnsupportedFeature = null;
        }
        get promise() {
          return this._capability.promise;
        }
        destroy() {
          var _this = this;
          return _asyncToGenerator(function* () {
            var _this$_transport;
            _this.destroyed = true;
            yield (_this$_transport = _this._transport) === null || _this$_transport === void 0 ? void 0 : _this$_transport.destroy();
            _this._transport = null;
            if (_this._worker) {
              _this._worker.destroy();
              _this._worker = null;
            }
          })();
        }
      }
      var _docId = {
        _: 0
      };
      exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
      class PDFDataRangeTransport {
        constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
          this.length = length;
          this.initialData = initialData;
          this.progressiveDone = progressiveDone;
          this.contentDispositionFilename = contentDispositionFilename;
          this._rangeListeners = [];
          this._progressListeners = [];
          this._progressiveReadListeners = [];
          this._progressiveDoneListeners = [];
          this._readyCapability = (0, _util.createPromiseCapability)();
        }
        addRangeListener(listener) {
          this._rangeListeners.push(listener);
        }
        addProgressListener(listener) {
          this._progressListeners.push(listener);
        }
        addProgressiveReadListener(listener) {
          this._progressiveReadListeners.push(listener);
        }
        addProgressiveDoneListener(listener) {
          this._progressiveDoneListeners.push(listener);
        }
        onDataRange(begin, chunk) {
          for (const listener of this._rangeListeners) {
            listener(begin, chunk);
          }
        }
        onDataProgress(loaded, total) {
          this._readyCapability.promise.then(() => {
            for (const listener of this._progressListeners) {
              listener(loaded, total);
            }
          });
        }
        onDataProgressiveRead(chunk) {
          this._readyCapability.promise.then(() => {
            for (const listener of this._progressiveReadListeners) {
              listener(chunk);
            }
          });
        }
        onDataProgressiveDone() {
          this._readyCapability.promise.then(() => {
            for (const listener of this._progressiveDoneListeners) {
              listener();
            }
          });
        }
        transportReady() {
          this._readyCapability.resolve();
        }
        requestDataRange(begin, end) {
          (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
        }
        abort() {}
      }
      exports.PDFDataRangeTransport = PDFDataRangeTransport;
      class PDFDocumentProxy {
        constructor(pdfInfo, transport) {
          var _this2 = this;
          this._pdfInfo = pdfInfo;
          this._transport = transport;
          Object.defineProperty(this, "fingerprint", {
            get() {
              (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, " + "please use `PDFDocumentProxy.fingerprints` instead.");
              return this.fingerprints[0];
            }
          });
          Object.defineProperty(this, "getStats", {
            value: function () {
              var _ref = _asyncToGenerator(function* () {
                (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, " + "please use the `PDFDocumentProxy.stats`-getter instead.");
                return _this2.stats || {
                  streamTypes: {},
                  fontTypes: {}
                };
              });
              return function value() {
                return _ref.apply(this, arguments);
              };
            }()
          });
        }
        get annotationStorage() {
          return this._transport.annotationStorage;
        }
        get numPages() {
          return this._pdfInfo.numPages;
        }
        get fingerprints() {
          return this._pdfInfo.fingerprints;
        }
        get stats() {
          return this._transport.stats;
        }
        get isPureXfa() {
          return !!this._transport._htmlForXfa;
        }
        get allXfaHtml() {
          return this._transport._htmlForXfa;
        }
        getPage(pageNumber) {
          return this._transport.getPage(pageNumber);
        }
        getPageIndex(ref) {
          return this._transport.getPageIndex(ref);
        }
        getDestinations() {
          return this._transport.getDestinations();
        }
        getDestination(id) {
          return this._transport.getDestination(id);
        }
        getPageLabels() {
          return this._transport.getPageLabels();
        }
        getPageLayout() {
          return this._transport.getPageLayout();
        }
        getPageMode() {
          return this._transport.getPageMode();
        }
        getViewerPreferences() {
          return this._transport.getViewerPreferences();
        }
        getOpenAction() {
          return this._transport.getOpenAction();
        }
        getAttachments() {
          return this._transport.getAttachments();
        }
        getJavaScript() {
          return this._transport.getJavaScript();
        }
        getJSActions() {
          return this._transport.getDocJSActions();
        }
        getOutline() {
          return this._transport.getOutline();
        }
        getOptionalContentConfig() {
          return this._transport.getOptionalContentConfig();
        }
        getPermissions() {
          return this._transport.getPermissions();
        }
        getMetadata() {
          return this._transport.getMetadata();
        }
        getMarkInfo() {
          return this._transport.getMarkInfo();
        }
        getData() {
          return this._transport.getData();
        }
        getDownloadInfo() {
          return this._transport.downloadInfoCapability.promise;
        }
        cleanup(keepLoadedFonts = false) {
          return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
        }
        destroy() {
          return this.loadingTask.destroy();
        }
        get loadingParams() {
          return this._transport.loadingParams;
        }
        get loadingTask() {
          return this._transport.loadingTask;
        }
        saveDocument() {
          if (this._transport.annotationStorage.size <= 0) {
            (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
          }
          return this._transport.saveDocument();
        }
        getFieldObjects() {
          return this._transport.getFieldObjects();
        }
        hasJSActions() {
          return this._transport.hasJSActions();
        }
        getCalculationOrderIds() {
          return this._transport.getCalculationOrderIds();
        }
      }
      exports.PDFDocumentProxy = PDFDocumentProxy;
      class PDFPageProxy {
        constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {
          this._pageIndex = pageIndex;
          this._pageInfo = pageInfo;
          this._ownerDocument = ownerDocument;
          this._transport = transport;
          this._stats = pdfBug ? new _display_utils.StatTimer() : null;
          this._pdfBug = pdfBug;
          this.commonObjs = transport.commonObjs;
          this.objs = new PDFObjects();
          this._bitmaps = new Set();
          this.cleanupAfterRender = false;
          this.pendingCleanup = false;
          this._intentStates = new Map();
          this._annotationPromises = new Map();
          this.destroyed = false;
        }
        get pageNumber() {
          return this._pageIndex + 1;
        }
        get rotate() {
          return this._pageInfo.rotate;
        }
        get ref() {
          return this._pageInfo.ref;
        }
        get userUnit() {
          return this._pageInfo.userUnit;
        }
        get view() {
          return this._pageInfo.view;
        }
        getViewport({
          scale,
          rotation = this.rotate,
          offsetX = 0,
          offsetY = 0,
          dontFlip = false
        } = {}) {
          return new _display_utils.PageViewport({
            viewBox: this.view,
            scale,
            rotation,
            offsetX,
            offsetY,
            dontFlip
          });
        }
        getAnnotations({
          intent = "display"
        } = {}) {
          const intentArgs = this._transport.getRenderingIntent(intent);
          let promise = this._annotationPromises.get(intentArgs.cacheKey);
          if (!promise) {
            promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
            this._annotationPromises.set(intentArgs.cacheKey, promise);
            promise = promise.then(annotations => {
              for (const annotation of annotations) {
                if (annotation.titleObj !== undefined) {
                  Object.defineProperty(annotation, "title", {
                    get() {
                      (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                      return annotation.titleObj.str;
                    }
                  });
                }
                if (annotation.contentsObj !== undefined) {
                  Object.defineProperty(annotation, "contents", {
                    get() {
                      (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                      return annotation.contentsObj.str;
                    }
                  });
                }
              }
              return annotations;
            });
          }
          return promise;
        }
        getJSActions() {
          return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
        }
        getXfa() {
          var _this3 = this;
          return _asyncToGenerator(function* () {
            var _this3$_transport$_ht;
            return ((_this3$_transport$_ht = _this3._transport._htmlForXfa) === null || _this3$_transport$_ht === void 0 ? void 0 : _this3$_transport$_ht.children[_this3._pageIndex]) || null;
          })();
        }
        render({
          canvasContext,
          viewport,
          intent = "display",
          annotationMode = _util.AnnotationMode.ENABLE,
          transform = null,
          imageLayer = null,
          canvasFactory = null,
          background = null,
          optionalContentConfigPromise = null,
          annotationCanvasMap = null,
          pageColors = null
        }) {
          var _arguments$, _arguments$2, _intentState;
          if (((_arguments$ = arguments[0]) === null || _arguments$ === void 0 ? void 0 : _arguments$.renderInteractiveForms) !== undefined) {
            (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, " + "please use the `annotationMode`-option instead.");
            if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
              annotationMode = _util.AnnotationMode.ENABLE_FORMS;
            }
          }
          if (((_arguments$2 = arguments[0]) === null || _arguments$2 === void 0 ? void 0 : _arguments$2.includeAnnotationStorage) !== undefined) {
            (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, " + "please use the `annotationMode`-option instead.");
            if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
              annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
            }
          }
          if (this._stats) {
            this._stats.time("Overall");
          }
          const intentArgs = this._transport.getRenderingIntent(intent, annotationMode);
          this.pendingCleanup = false;
          if (!optionalContentConfigPromise) {
            optionalContentConfigPromise = this._transport.getOptionalContentConfig();
          }
          let intentState = this._intentStates.get(intentArgs.cacheKey);
          if (!intentState) {
            intentState = Object.create(null);
            this._intentStates.set(intentArgs.cacheKey, intentState);
          }
          if (intentState.streamReaderCancelTimeout) {
            clearTimeout(intentState.streamReaderCancelTimeout);
            intentState.streamReaderCancelTimeout = null;
          }
          const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
            ownerDocument: this._ownerDocument
          });
          const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
          if (!intentState.displayReadyCapability) {
            intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
            intentState.operatorList = {
              fnArray: [],
              argsArray: [],
              lastChunk: false
            };
            if (this._stats) {
              this._stats.time("Page Request");
            }
            this._pumpOperatorList(intentArgs);
          }
          const complete = error => {
            intentState.renderTasks.delete(internalRenderTask);
            if (this.cleanupAfterRender || intentPrint) {
              this.pendingCleanup = true;
            }
            this._tryCleanup();
            if (error) {
              internalRenderTask.capability.reject(error);
              this._abortOperatorList({
                intentState,
                reason: error instanceof Error ? error : new Error(error)
              });
            } else {
              internalRenderTask.capability.resolve();
            }
            if (this._stats) {
              this._stats.timeEnd("Rendering");
              this._stats.timeEnd("Overall");
            }
          };
          const internalRenderTask = new InternalRenderTask({
            callback: complete,
            params: {
              canvasContext,
              viewport,
              transform,
              imageLayer,
              background
            },
            objs: this.objs,
            commonObjs: this.commonObjs,
            annotationCanvasMap,
            operatorList: intentState.operatorList,
            pageIndex: this._pageIndex,
            canvasFactory: canvasFactoryInstance,
            useRequestAnimationFrame: !intentPrint,
            pdfBug: this._pdfBug,
            pageColors
          });
          ((_intentState = intentState).renderTasks || (_intentState.renderTasks = new Set())).add(internalRenderTask);
          const renderTask = internalRenderTask.task;
          Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
            if (this.pendingCleanup) {
              complete();
              return;
            }
            if (this._stats) {
              this._stats.time("Rendering");
            }
            internalRenderTask.initializeGraphics({
              transparency,
              optionalContentConfig
            });
            internalRenderTask.operatorListChanged();
          }).catch(complete);
          return renderTask;
        }
        getOperatorList({
          intent = "display",
          annotationMode = _util.AnnotationMode.ENABLE
        } = {}) {
          function operatorListChanged() {
            if (intentState.operatorList.lastChunk) {
              intentState.opListReadCapability.resolve(intentState.operatorList);
              intentState.renderTasks.delete(opListTask);
            }
          }
          const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, true);
          let intentState = this._intentStates.get(intentArgs.cacheKey);
          if (!intentState) {
            intentState = Object.create(null);
            this._intentStates.set(intentArgs.cacheKey, intentState);
          }
          let opListTask;
          if (!intentState.opListReadCapability) {
            var _intentState2;
            opListTask = Object.create(null);
            opListTask.operatorListChanged = operatorListChanged;
            intentState.opListReadCapability = (0, _util.createPromiseCapability)();
            ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = new Set())).add(opListTask);
            intentState.operatorList = {
              fnArray: [],
              argsArray: [],
              lastChunk: false
            };
            if (this._stats) {
              this._stats.time("Page Request");
            }
            this._pumpOperatorList(intentArgs);
          }
          return intentState.opListReadCapability.promise;
        }
        streamTextContent({
          disableCombineTextItems = false,
          includeMarkedContent = false
        } = {}) {
          const TEXT_CONTENT_CHUNK_SIZE = 100;
          return this._transport.messageHandler.sendWithStream("GetTextContent", {
            pageIndex: this._pageIndex,
            combineTextItems: disableCombineTextItems !== true,
            includeMarkedContent: includeMarkedContent === true
          }, {
            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
            size(textContent) {
              return textContent.items.length;
            }
          });
        }
        getTextContent(params = {}) {
          if (this._transport._htmlForXfa) {
            return this.getXfa().then(xfa => {
              return _xfa_text.XfaText.textContent(xfa);
            });
          }
          const readableStream = this.streamTextContent(params);
          return new Promise(function (resolve, reject) {
            function pump() {
              reader.read().then(function ({
                value,
                done
              }) {
                if (done) {
                  resolve(textContent);
                  return;
                }
                Object.assign(textContent.styles, value.styles);
                textContent.items.push(...value.items);
                pump();
              }, reject);
            }
            const reader = readableStream.getReader();
            const textContent = {
              items: [],
              styles: Object.create(null)
            };
            pump();
          });
        }
        getStructTree() {
          return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
        }
        _destroy() {
          this.destroyed = true;
          const waitOn = [];
          for (const intentState of this._intentStates.values()) {
            this._abortOperatorList({
              intentState,
              reason: new Error("Page was destroyed."),
              force: true
            });
            if (intentState.opListReadCapability) {
              continue;
            }
            for (const internalRenderTask of intentState.renderTasks) {
              waitOn.push(internalRenderTask.completed);
              internalRenderTask.cancel();
            }
          }
          this.objs.clear();
          for (const bitmap of this._bitmaps) {
            bitmap.close();
          }
          this._bitmaps.clear();
          this._annotationPromises.clear();
          this._jsActionsPromise = null;
          this._structTreePromise = null;
          this.pendingCleanup = false;
          return Promise.all(waitOn);
        }
        cleanup(resetStats = false) {
          this.pendingCleanup = true;
          return this._tryCleanup(resetStats);
        }
        _tryCleanup(resetStats = false) {
          if (!this.pendingCleanup) {
            return false;
          }
          for (const {
            renderTasks,
            operatorList
          } of this._intentStates.values()) {
            if (renderTasks.size > 0 || !operatorList.lastChunk) {
              return false;
            }
          }
          this._intentStates.clear();
          this.objs.clear();
          this._annotationPromises.clear();
          this._jsActionsPromise = null;
          this._structTreePromise = null;
          if (resetStats && this._stats) {
            this._stats = new _display_utils.StatTimer();
          }
          for (const bitmap of this._bitmaps) {
            bitmap.close();
          }
          this._bitmaps.clear();
          this.pendingCleanup = false;
          return true;
        }
        _startRenderPage(transparency, cacheKey) {
          const intentState = this._intentStates.get(cacheKey);
          if (!intentState) {
            return;
          }
          if (this._stats) {
            this._stats.timeEnd("Page Request");
          }
          if (intentState.displayReadyCapability) {
            intentState.displayReadyCapability.resolve(transparency);
          }
        }
        _renderPageChunk(operatorListChunk, intentState) {
          for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
          }
          intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
          for (const internalRenderTask of intentState.renderTasks) {
            internalRenderTask.operatorListChanged();
          }
          if (operatorListChunk.lastChunk) {
            this._tryCleanup();
          }
        }
        _pumpOperatorList({
          renderingIntent,
          cacheKey
        }) {
          const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
            pageIndex: this._pageIndex,
            intent: renderingIntent,
            cacheKey,
            annotationStorage: renderingIntent & _util.RenderingIntentFlag.ANNOTATIONS_STORAGE ? this._transport.annotationStorage.serializable : null
          });
          const reader = readableStream.getReader();
          const intentState = this._intentStates.get(cacheKey);
          intentState.streamReader = reader;
          const pump = () => {
            reader.read().then(({
              value,
              done
            }) => {
              if (done) {
                intentState.streamReader = null;
                return;
              }
              if (this._transport.destroyed) {
                return;
              }
              this._renderPageChunk(value, intentState);
              pump();
            }, reason => {
              intentState.streamReader = null;
              if (this._transport.destroyed) {
                return;
              }
              if (intentState.operatorList) {
                intentState.operatorList.lastChunk = true;
                for (const internalRenderTask of intentState.renderTasks) {
                  internalRenderTask.operatorListChanged();
                }
                this._tryCleanup();
              }
              if (intentState.displayReadyCapability) {
                intentState.displayReadyCapability.reject(reason);
              } else if (intentState.opListReadCapability) {
                intentState.opListReadCapability.reject(reason);
              } else {
                throw reason;
              }
            });
          };
          pump();
        }
        _abortOperatorList({
          intentState,
          reason,
          force = false
        }) {
          if (!intentState.streamReader) {
            return;
          }
          if (!force) {
            if (intentState.renderTasks.size > 0) {
              return;
            }
            if (reason instanceof _display_utils.RenderingCancelledException) {
              intentState.streamReaderCancelTimeout = setTimeout(() => {
                this._abortOperatorList({
                  intentState,
                  reason,
                  force: true
                });
                intentState.streamReaderCancelTimeout = null;
              }, RENDERING_CANCELLED_TIMEOUT);
              return;
            }
          }
          intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});
          intentState.streamReader = null;
          if (this._transport.destroyed) {
            return;
          }
          for (const [curCacheKey, curIntentState] of this._intentStates) {
            if (curIntentState === intentState) {
              this._intentStates.delete(curCacheKey);
              break;
            }
          }
          this.cleanup();
        }
        get stats() {
          return this._stats;
        }
      }
      exports.PDFPageProxy = PDFPageProxy;
      class LoopbackPort {
        constructor() {
          this._listeners = [];
          this._deferred = Promise.resolve();
        }
        postMessage(obj, transfers) {
          const event = {
            data: structuredClone(obj, transfers)
          };
          this._deferred.then(() => {
            for (const listener of this._listeners) {
              listener.call(this, event);
            }
          });
        }
        addEventListener(name, listener) {
          this._listeners.push(listener);
        }
        removeEventListener(name, listener) {
          const i = this._listeners.indexOf(listener);
          this._listeners.splice(i, 1);
        }
        terminate() {
          this._listeners.length = 0;
        }
      }
      exports.LoopbackPort = LoopbackPort;
      const PDFWorkerUtil = {
        isWorkerDisabled: false,
        fallbackWorkerSrc: null,
        fakeWorkerId: 0
      };
      exports.PDFWorkerUtil = PDFWorkerUtil;
      {
        if (_is_node.isNodeJS && "function" === "function") {
          PDFWorkerUtil.isWorkerDisabled = true;
          PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
        } else if (typeof document === "object") {
          var _document, _document$currentScri;
          const pdfjsFilePath = (_document = document) === null || _document === void 0 ? void 0 : (_document$currentScri = _document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;
          if (pdfjsFilePath) {
            PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
          }
        }
        PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {
          let base;
          try {
            base = new URL(baseUrl);
            if (!base.origin || base.origin === "null") {
              return false;
            }
          } catch (e) {
            return false;
          }
          const other = new URL(otherUrl, base);
          return base.origin === other.origin;
        };
        PDFWorkerUtil.createCDNWrapper = function (url) {
          const wrapper = `importScripts("${url}");`;
          return URL.createObjectURL(new Blob([wrapper]));
        };
      }
      class PDFWorker {
        constructor({
          name = null,
          port = null,
          verbosity = (0, _util.getVerbosityLevel)()
        } = {}) {
          if (port && _workerPorts._.has(port)) {
            throw new Error("Cannot use more than one PDFWorker per port.");
          }
          this.name = name;
          this.destroyed = false;
          this.verbosity = verbosity;
          this._readyCapability = (0, _util.createPromiseCapability)();
          this._port = null;
          this._webWorker = null;
          this._messageHandler = null;
          if (port) {
            _workerPorts._.set(port, this);
            this._initializeFromPort(port);
            return;
          }
          this._initialize();
        }
        get promise() {
          return this._readyCapability.promise;
        }
        get port() {
          return this._port;
        }
        get messageHandler() {
          return this._messageHandler;
        }
        _initializeFromPort(port) {
          this._port = port;
          this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
          this._messageHandler.on("ready", function () {});
          this._readyCapability.resolve();
        }
        _initialize() {
          if (typeof Worker !== "undefined" && !PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
            let workerSrc = PDFWorker.workerSrc;
            try {
              if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
              }
              const worker = new Worker(workerSrc);
              const messageHandler = new _message_handler.MessageHandler("main", "worker", worker);
              const terminateEarly = () => {
                worker.removeEventListener("error", onWorkerError);
                messageHandler.destroy();
                worker.terminate();
                if (this.destroyed) {
                  this._readyCapability.reject(new Error("Worker was destroyed"));
                } else {
                  this._setupFakeWorker();
                }
              };
              const onWorkerError = () => {
                if (!this._webWorker) {
                  terminateEarly();
                }
              };
              worker.addEventListener("error", onWorkerError);
              messageHandler.on("test", data => {
                worker.removeEventListener("error", onWorkerError);
                if (this.destroyed) {
                  terminateEarly();
                  return;
                }
                if (data) {
                  this._messageHandler = messageHandler;
                  this._port = worker;
                  this._webWorker = worker;
                  this._readyCapability.resolve();
                  messageHandler.send("configure", {
                    verbosity: this.verbosity
                  });
                } else {
                  this._setupFakeWorker();
                  messageHandler.destroy();
                  worker.terminate();
                }
              });
              messageHandler.on("ready", data => {
                worker.removeEventListener("error", onWorkerError);
                if (this.destroyed) {
                  terminateEarly();
                  return;
                }
                try {
                  sendTest();
                } catch (e) {
                  this._setupFakeWorker();
                }
              });
              const sendTest = () => {
                const testObj = new Uint8Array();
                messageHandler.send("test", testObj, [testObj.buffer]);
              };
              sendTest();
              return;
            } catch (e) {
              (0, _util.info)("The worker has been disabled.");
            }
          }
          this._setupFakeWorker();
        }
        _setupFakeWorker() {
          if (!PDFWorkerUtil.isWorkerDisabled) {
            (0, _util.warn)("Setting up fake worker.");
            PDFWorkerUtil.isWorkerDisabled = true;
          }
          PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {
            if (this.destroyed) {
              this._readyCapability.reject(new Error("Worker was destroyed"));
              return;
            }
            const port = new LoopbackPort();
            this._port = port;
            const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
            const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
            WorkerMessageHandler.setup(workerHandler, port);
            const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
            this._messageHandler = messageHandler;
            this._readyCapability.resolve();
            messageHandler.send("configure", {
              verbosity: this.verbosity
            });
          }).catch(reason => {
            this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
          });
        }
        destroy() {
          this.destroyed = true;
          if (this._webWorker) {
            this._webWorker.terminate();
            this._webWorker = null;
          }
          _workerPorts._.delete(this._port);
          this._port = null;
          if (this._messageHandler) {
            this._messageHandler.destroy();
            this._messageHandler = null;
          }
        }
        static fromPort(params) {
          if (!(params !== null && params !== void 0 && params.port)) {
            throw new Error("PDFWorker.fromPort - invalid method signature.");
          }
          if (_assertClassBrand(PDFWorker, this, _workerPorts)._.has(params.port)) {
            return _assertClassBrand(PDFWorker, this, _workerPorts)._.get(params.port);
          }
          return new PDFWorker(params);
        }
        static get workerSrc() {
          if (_worker_options.GlobalWorkerOptions.workerSrc) {
            return _worker_options.GlobalWorkerOptions.workerSrc;
          }
          if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
            if (!_is_node.isNodeJS) {
              (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
            }
            return PDFWorkerUtil.fallbackWorkerSrc;
          }
          throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
        }
        static get _mainThreadWorkerMessageHandler() {
          try {
            var _globalThis$pdfjsWork;
            return ((_globalThis$pdfjsWork = globalThis.pdfjsWorker) === null || _globalThis$pdfjsWork === void 0 ? void 0 : _globalThis$pdfjsWork.WorkerMessageHandler) || null;
          } catch (ex) {
            return null;
          }
        }
        static get _setupFakeWorkerGlobal() {
          var _this4 = this;
          const loader = /*#__PURE__*/function () {
            var _ref2 = _asyncToGenerator(function* () {
              const mainWorkerMessageHandler = _this4._mainThreadWorkerMessageHandler;
              if (mainWorkerMessageHandler) {
                return mainWorkerMessageHandler;
              }
              if (_is_node.isNodeJS && "function" === "function") {
                const worker = eval("require")(_this4.workerSrc);
                return worker.WorkerMessageHandler;
              }
              yield (0, _display_utils.loadScript)(_this4.workerSrc);
              return window.pdfjsWorker.WorkerMessageHandler;
            });
            return function loader() {
              return _ref2.apply(this, arguments);
            };
          }();
          return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
        }
      }
      var _workerPorts = {
        _: new WeakMap()
      };
      exports.PDFWorker = PDFWorker;
      {
        PDFWorker.getWorkerSrc = function () {
          (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
          return this.workerSrc;
        };
      }
      var _docStats = /*#__PURE__*/new WeakMap();
      var _pageCache = /*#__PURE__*/new WeakMap();
      var _pagePromises = /*#__PURE__*/new WeakMap();
      var _metadataPromise = /*#__PURE__*/new WeakMap();
      class WorkerTransport {
        constructor(messageHandler, loadingTask, networkStream, params) {
          _classPrivateFieldInitSpec(this, _docStats, null);
          _classPrivateFieldInitSpec(this, _pageCache, new Map());
          _classPrivateFieldInitSpec(this, _pagePromises, new Map());
          _classPrivateFieldInitSpec(this, _metadataPromise, null);
          this.messageHandler = messageHandler;
          this.loadingTask = loadingTask;
          this.commonObjs = new PDFObjects();
          this.fontLoader = new _font_loader.FontLoader({
            docId: loadingTask.docId,
            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
            ownerDocument: params.ownerDocument,
            styleElement: params.styleElement
          });
          this._params = params;
          if (!params.useWorkerFetch) {
            this.CMapReaderFactory = new params.CMapReaderFactory({
              baseUrl: params.cMapUrl,
              isCompressed: params.cMapPacked
            });
            this.StandardFontDataFactory = new params.StandardFontDataFactory({
              baseUrl: params.standardFontDataUrl
            });
          }
          this.destroyed = false;
          this.destroyCapability = null;
          this._passwordCapability = null;
          this._networkStream = networkStream;
          this._fullReader = null;
          this._lastProgress = null;
          this.downloadInfoCapability = (0, _util.createPromiseCapability)();
          this.setupMessageHandler();
        }
        get annotationStorage() {
          return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
        }
        get stats() {
          return _classPrivateFieldGet(_docStats, this);
        }
        getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, isOpList = false) {
          let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
          let annotationHash = "";
          switch (intent) {
            case "any":
              renderingIntent = _util.RenderingIntentFlag.ANY;
              break;
            case "display":
              break;
            case "print":
              renderingIntent = _util.RenderingIntentFlag.PRINT;
              break;
            default:
              (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
          }
          switch (annotationMode) {
            case _util.AnnotationMode.DISABLE:
              renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
              break;
            case _util.AnnotationMode.ENABLE:
              break;
            case _util.AnnotationMode.ENABLE_FORMS:
              renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
              break;
            case _util.AnnotationMode.ENABLE_STORAGE:
              renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
              annotationHash = this.annotationStorage.hash;
              break;
            default:
              (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
          }
          if (isOpList) {
            renderingIntent += _util.RenderingIntentFlag.OPLIST;
          }
          return {
            renderingIntent,
            cacheKey: `${renderingIntent}_${annotationHash}`
          };
        }
        destroy() {
          if (this.destroyCapability) {
            return this.destroyCapability.promise;
          }
          this.destroyed = true;
          this.destroyCapability = (0, _util.createPromiseCapability)();
          if (this._passwordCapability) {
            this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
          }
          const waitOn = [];
          for (const page of _classPrivateFieldGet(_pageCache, this).values()) {
            waitOn.push(page._destroy());
          }
          _classPrivateFieldGet(_pageCache, this).clear();
          _classPrivateFieldGet(_pagePromises, this).clear();
          if (this.hasOwnProperty("annotationStorage")) {
            this.annotationStorage.resetModified();
          }
          const terminated = this.messageHandler.sendWithPromise("Terminate", null);
          waitOn.push(terminated);
          Promise.all(waitOn).then(() => {
            this.commonObjs.clear();
            this.fontLoader.clear();
            _classPrivateFieldSet(_metadataPromise, this, null);
            this._getFieldObjectsPromise = null;
            this._hasJSActionsPromise = null;
            if (this._networkStream) {
              this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
            }
            if (this.messageHandler) {
              this.messageHandler.destroy();
              this.messageHandler = null;
            }
            this.destroyCapability.resolve();
          }, this.destroyCapability.reject);
          return this.destroyCapability.promise;
        }
        setupMessageHandler() {
          const {
            messageHandler,
            loadingTask
          } = this;
          messageHandler.on("GetReader", (data, sink) => {
            (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
            this._fullReader = this._networkStream.getFullReader();
            this._fullReader.onProgress = evt => {
              this._lastProgress = {
                loaded: evt.loaded,
                total: evt.total
              };
            };
            sink.onPull = () => {
              this._fullReader.read().then(function ({
                value,
                done
              }) {
                if (done) {
                  sink.close();
                  return;
                }
                (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
                sink.enqueue(new Uint8Array(value), 1, [value]);
              }).catch(reason => {
                sink.error(reason);
              });
            };
            sink.onCancel = reason => {
              this._fullReader.cancel(reason);
              sink.ready.catch(readyReason => {
                if (this.destroyed) {
                  return;
                }
                throw readyReason;
              });
            };
          });
          messageHandler.on("ReaderHeadersReady", data => {
            const headersCapability = (0, _util.createPromiseCapability)();
            const fullReader = this._fullReader;
            fullReader.headersReady.then(() => {
              if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                if (this._lastProgress) {
                  var _loadingTask$onProgre;
                  (_loadingTask$onProgre = loadingTask.onProgress) === null || _loadingTask$onProgre === void 0 ? void 0 : _loadingTask$onProgre.call(loadingTask, this._lastProgress);
                }
                fullReader.onProgress = evt => {
                  var _loadingTask$onProgre2;
                  (_loadingTask$onProgre2 = loadingTask.onProgress) === null || _loadingTask$onProgre2 === void 0 ? void 0 : _loadingTask$onProgre2.call(loadingTask, {
                    loaded: evt.loaded,
                    total: evt.total
                  });
                };
              }
              headersCapability.resolve({
                isStreamingSupported: fullReader.isStreamingSupported,
                isRangeSupported: fullReader.isRangeSupported,
                contentLength: fullReader.contentLength
              });
            }, headersCapability.reject);
            return headersCapability.promise;
          });
          messageHandler.on("GetRangeReader", (data, sink) => {
            (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
            if (!rangeReader) {
              sink.close();
              return;
            }
            sink.onPull = () => {
              rangeReader.read().then(function ({
                value,
                done
              }) {
                if (done) {
                  sink.close();
                  return;
                }
                (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
                sink.enqueue(new Uint8Array(value), 1, [value]);
              }).catch(reason => {
                sink.error(reason);
              });
            };
            sink.onCancel = reason => {
              rangeReader.cancel(reason);
              sink.ready.catch(readyReason => {
                if (this.destroyed) {
                  return;
                }
                throw readyReason;
              });
            };
          });
          messageHandler.on("GetDoc", ({
            pdfInfo
          }) => {
            this._numPages = pdfInfo.numPages;
            this._htmlForXfa = pdfInfo.htmlForXfa;
            delete pdfInfo.htmlForXfa;
            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
          });
          messageHandler.on("DocException", function (ex) {
            let reason;
            switch (ex.name) {
              case "PasswordException":
                reason = new _util.PasswordException(ex.message, ex.code);
                break;
              case "InvalidPDFException":
                reason = new _util.InvalidPDFException(ex.message);
                break;
              case "MissingPDFException":
                reason = new _util.MissingPDFException(ex.message);
                break;
              case "UnexpectedResponseException":
                reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                break;
              case "UnknownErrorException":
                reason = new _util.UnknownErrorException(ex.message, ex.details);
                break;
              default:
                (0, _util.unreachable)("DocException - expected a valid Error.");
            }
            loadingTask._capability.reject(reason);
          });
          messageHandler.on("PasswordRequest", exception => {
            this._passwordCapability = (0, _util.createPromiseCapability)();
            if (loadingTask.onPassword) {
              const updatePassword = password => {
                if (password instanceof Error) {
                  this._passwordCapability.reject(password);
                } else {
                  this._passwordCapability.resolve({
                    password
                  });
                }
              };
              try {
                loadingTask.onPassword(updatePassword, exception.code);
              } catch (ex) {
                this._passwordCapability.reject(ex);
              }
            } else {
              this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
            }
            return this._passwordCapability.promise;
          });
          messageHandler.on("DataLoaded", data => {
            var _loadingTask$onProgre3;
            (_loadingTask$onProgre3 = loadingTask.onProgress) === null || _loadingTask$onProgre3 === void 0 ? void 0 : _loadingTask$onProgre3.call(loadingTask, {
              loaded: data.length,
              total: data.length
            });
            this.downloadInfoCapability.resolve(data);
          });
          messageHandler.on("StartRenderPage", data => {
            if (this.destroyed) {
              return;
            }
            const page = _classPrivateFieldGet(_pageCache, this).get(data.pageIndex);
            page._startRenderPage(data.transparency, data.cacheKey);
          });
          messageHandler.on("commonobj", ([id, type, exportedData]) => {
            var _globalThis$FontInspe;
            if (this.destroyed) {
              return;
            }
            if (this.commonObjs.has(id)) {
              return;
            }
            switch (type) {
              case "Font":
                const params = this._params;
                if ("error" in exportedData) {
                  const exportedError = exportedData.error;
                  (0, _util.warn)(`Error during font loading: ${exportedError}`);
                  this.commonObjs.resolve(id, exportedError);
                  break;
                }
                let fontRegistry = null;
                if (params.pdfBug && (_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled) {
                  fontRegistry = {
                    registerFont(font, url) {
                      globalThis.FontInspector.fontAdded(font, url);
                    }
                  };
                }
                const font = new _font_loader.FontFaceObject(exportedData, {
                  isEvalSupported: params.isEvalSupported,
                  disableFontFace: params.disableFontFace,
                  ignoreErrors: params.ignoreErrors,
                  onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                  fontRegistry
                });
                this.fontLoader.bind(font).catch(reason => {
                  return messageHandler.sendWithPromise("FontFallback", {
                    id
                  });
                }).finally(() => {
                  if (!params.fontExtraProperties && font.data) {
                    font.data = null;
                  }
                  this.commonObjs.resolve(id, font);
                });
                break;
              case "FontPath":
              case "Image":
                this.commonObjs.resolve(id, exportedData);
                break;
              default:
                throw new Error(`Got unknown common object type ${type}`);
            }
          });
          messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
            if (this.destroyed) {
              return;
            }
            const pageProxy = _classPrivateFieldGet(_pageCache, this).get(pageIndex);
            if (pageProxy.objs.has(id)) {
              return;
            }
            switch (type) {
              case "Image":
                pageProxy.objs.resolve(id, imageData);
                const MAX_IMAGE_SIZE_TO_STORE = 8000000;
                if (imageData) {
                  let length;
                  if (imageData.bitmap) {
                    const {
                      bitmap,
                      width,
                      height
                    } = imageData;
                    length = width * height * 4;
                    pageProxy._bitmaps.add(bitmap);
                  } else {
                    var _imageData$data;
                    length = ((_imageData$data = imageData.data) === null || _imageData$data === void 0 ? void 0 : _imageData$data.length) || 0;
                  }
                  if (length > MAX_IMAGE_SIZE_TO_STORE) {
                    pageProxy.cleanupAfterRender = true;
                  }
                }
                break;
              case "Pattern":
                pageProxy.objs.resolve(id, imageData);
                break;
              default:
                throw new Error(`Got unknown object type ${type}`);
            }
          });
          messageHandler.on("DocProgress", data => {
            var _loadingTask$onProgre4;
            if (this.destroyed) {
              return;
            }
            (_loadingTask$onProgre4 = loadingTask.onProgress) === null || _loadingTask$onProgre4 === void 0 ? void 0 : _loadingTask$onProgre4.call(loadingTask, {
              loaded: data.loaded,
              total: data.total
            });
          });
          messageHandler.on("DocStats", data => {
            if (this.destroyed) {
              return;
            }
            _classPrivateFieldSet(_docStats, this, Object.freeze({
              streamTypes: Object.freeze(data.streamTypes),
              fontTypes: Object.freeze(data.fontTypes)
            }));
          });
          messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
          messageHandler.on("FetchBuiltInCMap", data => {
            if (this.destroyed) {
              return Promise.reject(new Error("Worker was destroyed."));
            }
            if (!this.CMapReaderFactory) {
              return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
            }
            return this.CMapReaderFactory.fetch(data);
          });
          messageHandler.on("FetchStandardFontData", data => {
            if (this.destroyed) {
              return Promise.reject(new Error("Worker was destroyed."));
            }
            if (!this.StandardFontDataFactory) {
              return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
            }
            return this.StandardFontDataFactory.fetch(data);
          });
        }
        _onUnsupportedFeature({
          featureId
        }) {
          var _this$loadingTask$onU, _this$loadingTask;
          if (this.destroyed) {
            return;
          }
          (_this$loadingTask$onU = (_this$loadingTask = this.loadingTask).onUnsupportedFeature) === null || _this$loadingTask$onU === void 0 ? void 0 : _this$loadingTask$onU.call(_this$loadingTask, featureId);
        }
        getData() {
          return this.messageHandler.sendWithPromise("GetData", null);
        }
        getPage(pageNumber) {
          if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
            return Promise.reject(new Error("Invalid page request."));
          }
          const pageIndex = pageNumber - 1,
            cachedPromise = _classPrivateFieldGet(_pagePromises, this).get(pageIndex);
          if (cachedPromise) {
            return cachedPromise;
          }
          const promise = this.messageHandler.sendWithPromise("GetPage", {
            pageIndex
          }).then(pageInfo => {
            if (this.destroyed) {
              throw new Error("Transport destroyed");
            }
            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
            _classPrivateFieldGet(_pageCache, this).set(pageIndex, page);
            return page;
          });
          _classPrivateFieldGet(_pagePromises, this).set(pageIndex, promise);
          return promise;
        }
        getPageIndex(ref) {
          if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
            return Promise.reject(new Error("Invalid pageIndex request."));
          }
          return this.messageHandler.sendWithPromise("GetPageIndex", {
            num: ref.num,
            gen: ref.gen
          });
        }
        getAnnotations(pageIndex, intent) {
          return this.messageHandler.sendWithPromise("GetAnnotations", {
            pageIndex,
            intent
          });
        }
        saveDocument() {
          var _this$_fullReader$fil, _this$_fullReader;
          return this.messageHandler.sendWithPromise("SaveDocument", {
            isPureXfa: !!this._htmlForXfa,
            numPages: this._numPages,
            annotationStorage: this.annotationStorage.serializable,
            filename: (_this$_fullReader$fil = (_this$_fullReader = this._fullReader) === null || _this$_fullReader === void 0 ? void 0 : _this$_fullReader.filename) !== null && _this$_fullReader$fil !== void 0 ? _this$_fullReader$fil : null
          }).finally(() => {
            this.annotationStorage.resetModified();
          });
        }
        getFieldObjects() {
          return this._getFieldObjectsPromise || (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise("GetFieldObjects", null));
        }
        hasJSActions() {
          return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
        }
        getCalculationOrderIds() {
          return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
        }
        getDestinations() {
          return this.messageHandler.sendWithPromise("GetDestinations", null);
        }
        getDestination(id) {
          if (typeof id !== "string") {
            return Promise.reject(new Error("Invalid destination request."));
          }
          return this.messageHandler.sendWithPromise("GetDestination", {
            id
          });
        }
        getPageLabels() {
          return this.messageHandler.sendWithPromise("GetPageLabels", null);
        }
        getPageLayout() {
          return this.messageHandler.sendWithPromise("GetPageLayout", null);
        }
        getPageMode() {
          return this.messageHandler.sendWithPromise("GetPageMode", null);
        }
        getViewerPreferences() {
          return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
        }
        getOpenAction() {
          return this.messageHandler.sendWithPromise("GetOpenAction", null);
        }
        getAttachments() {
          return this.messageHandler.sendWithPromise("GetAttachments", null);
        }
        getJavaScript() {
          return this.messageHandler.sendWithPromise("GetJavaScript", null);
        }
        getDocJSActions() {
          return this.messageHandler.sendWithPromise("GetDocJSActions", null);
        }
        getPageJSActions(pageIndex) {
          return this.messageHandler.sendWithPromise("GetPageJSActions", {
            pageIndex
          });
        }
        getStructTree(pageIndex) {
          return this.messageHandler.sendWithPromise("GetStructTree", {
            pageIndex
          });
        }
        getOutline() {
          return this.messageHandler.sendWithPromise("GetOutline", null);
        }
        getOptionalContentConfig() {
          return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(results => {
            return new _optional_content_config.OptionalContentConfig(results);
          });
        }
        getPermissions() {
          return this.messageHandler.sendWithPromise("GetPermissions", null);
        }
        getMetadata() {
          return _classPrivateFieldGet(_metadataPromise, this) || _classPrivateFieldSet(_metadataPromise, this, this.messageHandler.sendWithPromise("GetMetadata", null).then(results => {
            var _this$_fullReader$fil2, _this$_fullReader2, _this$_fullReader$con, _this$_fullReader3;
            return {
              info: results[0],
              metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
              contentDispositionFilename: (_this$_fullReader$fil2 = (_this$_fullReader2 = this._fullReader) === null || _this$_fullReader2 === void 0 ? void 0 : _this$_fullReader2.filename) !== null && _this$_fullReader$fil2 !== void 0 ? _this$_fullReader$fil2 : null,
              contentLength: (_this$_fullReader$con = (_this$_fullReader3 = this._fullReader) === null || _this$_fullReader3 === void 0 ? void 0 : _this$_fullReader3.contentLength) !== null && _this$_fullReader$con !== void 0 ? _this$_fullReader$con : null
            };
          }));
        }
        getMarkInfo() {
          return this.messageHandler.sendWithPromise("GetMarkInfo", null);
        }
        startCleanup(keepLoadedFonts = false) {
          var _this5 = this;
          return _asyncToGenerator(function* () {
            yield _this5.messageHandler.sendWithPromise("Cleanup", null);
            if (_this5.destroyed) {
              return;
            }
            for (const page of _classPrivateFieldGet(_pageCache, _this5).values()) {
              const cleanupSuccessful = page.cleanup();
              if (!cleanupSuccessful) {
                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
              }
            }
            _this5.commonObjs.clear();
            if (!keepLoadedFonts) {
              _this5.fontLoader.clear();
            }
            _classPrivateFieldSet(_metadataPromise, _this5, null);
            _this5._getFieldObjectsPromise = null;
            _this5._hasJSActionsPromise = null;
          })();
        }
        get loadingParams() {
          const params = this._params;
          return (0, _util.shadow)(this, "loadingParams", {
            disableAutoFetch: params.disableAutoFetch,
            enableXfa: params.enableXfa
          });
        }
      }
      var _objs = /*#__PURE__*/new WeakMap();
      var _PDFObjects_brand = /*#__PURE__*/new WeakSet();
      class PDFObjects {
        constructor() {
          _classPrivateMethodInitSpec(this, _PDFObjects_brand);
          _classPrivateFieldInitSpec(this, _objs, Object.create(null));
        }
        get(objId, callback = null) {
          if (callback) {
            const obj = _assertClassBrand(_PDFObjects_brand, this, _ensureObj).call(this, objId);
            obj.capability.promise.then(() => callback(obj.data));
            return null;
          }
          const obj = _classPrivateFieldGet(_objs, this)[objId];
          if (!(obj !== null && obj !== void 0 && obj.capability.settled)) {
            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
          }
          return obj.data;
        }
        has(objId) {
          const obj = _classPrivateFieldGet(_objs, this)[objId];
          return (obj === null || obj === void 0 ? void 0 : obj.capability.settled) || false;
        }
        resolve(objId, data = null) {
          const obj = _assertClassBrand(_PDFObjects_brand, this, _ensureObj).call(this, objId);
          obj.data = data;
          obj.capability.resolve();
        }
        clear() {
          _classPrivateFieldSet(_objs, this, Object.create(null));
        }
      }
      function _ensureObj(objId) {
        const obj = _classPrivateFieldGet(_objs, this)[objId];
        if (obj) {
          return obj;
        }
        return _classPrivateFieldGet(_objs, this)[objId] = {
          capability: (0, _util.createPromiseCapability)(),
          data: null
        };
      }
      class RenderTask {
        constructor(internalRenderTask) {
          this._internalRenderTask = internalRenderTask;
          this.onContinue = null;
        }
        get promise() {
          return this._internalRenderTask.capability.promise;
        }
        cancel() {
          this._internalRenderTask.cancel();
        }
      }
      exports.RenderTask = RenderTask;
      class InternalRenderTask {
        constructor({
          callback,
          params,
          objs,
          commonObjs,
          annotationCanvasMap,
          operatorList,
          pageIndex,
          canvasFactory,
          useRequestAnimationFrame = false,
          pdfBug = false,
          pageColors = null
        }) {
          this.callback = callback;
          this.params = params;
          this.objs = objs;
          this.commonObjs = commonObjs;
          this.annotationCanvasMap = annotationCanvasMap;
          this.operatorListIdx = null;
          this.operatorList = operatorList;
          this._pageIndex = pageIndex;
          this.canvasFactory = canvasFactory;
          this._pdfBug = pdfBug;
          this.pageColors = pageColors;
          this.running = false;
          this.graphicsReadyCallback = null;
          this.graphicsReady = false;
          this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
          this.cancelled = false;
          this.capability = (0, _util.createPromiseCapability)();
          this.task = new RenderTask(this);
          this._cancelBound = this.cancel.bind(this);
          this._continueBound = this._continue.bind(this);
          this._scheduleNextBound = this._scheduleNext.bind(this);
          this._nextBound = this._next.bind(this);
          this._canvas = params.canvasContext.canvas;
        }
        get completed() {
          return this.capability.promise.catch(function () {});
        }
        initializeGraphics({
          transparency = false,
          optionalContentConfig
        }) {
          var _globalThis$StepperMa;
          if (this.cancelled) {
            return;
          }
          if (this._canvas) {
            if (_canvasInUse._.has(this._canvas)) {
              throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
            }
            _canvasInUse._.add(this._canvas);
          }
          if (this._pdfBug && (_globalThis$StepperMa = globalThis.StepperManager) !== null && _globalThis$StepperMa !== void 0 && _globalThis$StepperMa.enabled) {
            this.stepper = globalThis.StepperManager.create(this._pageIndex);
            this.stepper.init(this.operatorList);
            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
          }
          const {
            canvasContext,
            viewport,
            transform,
            imageLayer,
            background
          } = this.params;
          this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);
          this.gfx.beginDrawing({
            transform,
            viewport,
            transparency,
            background
          });
          this.operatorListIdx = 0;
          this.graphicsReady = true;
          if (this.graphicsReadyCallback) {
            this.graphicsReadyCallback();
          }
        }
        cancel(error = null) {
          this.running = false;
          this.cancelled = true;
          if (this.gfx) {
            this.gfx.endDrawing();
          }
          if (this._canvas) {
            _canvasInUse._.delete(this._canvas);
          }
          this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
        }
        operatorListChanged() {
          if (!this.graphicsReady) {
            if (!this.graphicsReadyCallback) {
              this.graphicsReadyCallback = this._continueBound;
            }
            return;
          }
          if (this.stepper) {
            this.stepper.updateOperatorList(this.operatorList);
          }
          if (this.running) {
            return;
          }
          this._continue();
        }
        _continue() {
          this.running = true;
          if (this.cancelled) {
            return;
          }
          if (this.task.onContinue) {
            this.task.onContinue(this._scheduleNextBound);
          } else {
            this._scheduleNext();
          }
        }
        _scheduleNext() {
          if (this._useRequestAnimationFrame) {
            window.requestAnimationFrame(() => {
              this._nextBound().catch(this._cancelBound);
            });
          } else {
            Promise.resolve().then(this._nextBound).catch(this._cancelBound);
          }
        }
        _next() {
          var _this6 = this;
          return _asyncToGenerator(function* () {
            if (_this6.cancelled) {
              return;
            }
            _this6.operatorListIdx = _this6.gfx.executeOperatorList(_this6.operatorList, _this6.operatorListIdx, _this6._continueBound, _this6.stepper);
            if (_this6.operatorListIdx === _this6.operatorList.argsArray.length) {
              _this6.running = false;
              if (_this6.operatorList.lastChunk) {
                _this6.gfx.endDrawing();
                if (_this6._canvas) {
                  _canvasInUse._.delete(_this6._canvas);
                }
                _this6.callback();
              }
            }
          })();
        }
      }
      var _canvasInUse = {
        _: new WeakSet()
      };
      const version = '2.14.305';
      exports.version = version;
      const build = 'eaaa8b4ad';
      exports.build = build;

      /***/
    }), ( /* 5 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      var _PixelsPerInch;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = void 0;
      exports.deprecated = deprecated;
      exports.getFilenameFromUrl = getFilenameFromUrl;
      exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
      exports.getXfaPageViewport = getXfaPageViewport;
      exports.isDataScheme = isDataScheme;
      exports.isPdfFile = isPdfFile;
      exports.isValidFetchUrl = isValidFetchUrl;
      exports.loadScript = loadScript;
      var _base_factory = __w_pdfjs_require__(6);
      var _util = __w_pdfjs_require__(1);
      const SVG_NS = "http://www.w3.org/2000/svg";
      class PixelsPerInch {}
      _PixelsPerInch = PixelsPerInch;
      _defineProperty(PixelsPerInch, "CSS", 96.0);
      _defineProperty(PixelsPerInch, "PDF", 72.0);
      _defineProperty(PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
      exports.PixelsPerInch = PixelsPerInch;
      class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
        constructor({
          ownerDocument = globalThis.document
        } = {}) {
          super();
          this._document = ownerDocument;
        }
        _createCanvas(width, height) {
          const canvas = this._document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          return canvas;
        }
      }
      exports.DOMCanvasFactory = DOMCanvasFactory;
      function fetchData(_x5) {
        return _fetchData.apply(this, arguments);
      }
      function _fetchData() {
        _fetchData = _asyncToGenerator(function* (url, asTypedArray = false) {
          if (isValidFetchUrl(url, document.baseURI)) {
            const response = yield fetch(url);
            if (!response.ok) {
              throw new Error(response.statusText);
            }
            return asTypedArray ? new Uint8Array(yield response.arrayBuffer()) : (0, _util.stringToBytes)(yield response.text());
          }
          return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.open("GET", url, true);
            if (asTypedArray) {
              request.responseType = "arraybuffer";
            }
            request.onreadystatechange = () => {
              if (request.readyState !== XMLHttpRequest.DONE) {
                return;
              }
              if (request.status === 200 || request.status === 0) {
                let data;
                if (asTypedArray && request.response) {
                  data = new Uint8Array(request.response);
                } else if (!asTypedArray && request.responseText) {
                  data = (0, _util.stringToBytes)(request.responseText);
                }
                if (data) {
                  resolve(data);
                  return;
                }
              }
              reject(new Error(request.statusText));
            };
            request.send(null);
          });
        });
        return _fetchData.apply(this, arguments);
      }
      class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
        _fetchData(url, compressionType) {
          return fetchData(url, this.isCompressed).then(data => {
            return {
              cMapData: data,
              compressionType
            };
          });
        }
      }
      exports.DOMCMapReaderFactory = DOMCMapReaderFactory;
      class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
        _fetchData(url) {
          return fetchData(url, true);
        }
      }
      exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
      class DOMSVGFactory extends _base_factory.BaseSVGFactory {
        _createSVG(type) {
          return document.createElementNS(SVG_NS, type);
        }
      }
      exports.DOMSVGFactory = DOMSVGFactory;
      class PageViewport {
        constructor({
          viewBox,
          scale,
          rotation,
          offsetX = 0,
          offsetY = 0,
          dontFlip = false
        }) {
          this.viewBox = viewBox;
          this.scale = scale;
          this.rotation = rotation;
          this.offsetX = offsetX;
          this.offsetY = offsetY;
          const centerX = (viewBox[2] + viewBox[0]) / 2;
          const centerY = (viewBox[3] + viewBox[1]) / 2;
          let rotateA, rotateB, rotateC, rotateD;
          rotation %= 360;
          if (rotation < 0) {
            rotation += 360;
          }
          switch (rotation) {
            case 180:
              rotateA = -1;
              rotateB = 0;
              rotateC = 0;
              rotateD = 1;
              break;
            case 90:
              rotateA = 0;
              rotateB = 1;
              rotateC = 1;
              rotateD = 0;
              break;
            case 270:
              rotateA = 0;
              rotateB = -1;
              rotateC = -1;
              rotateD = 0;
              break;
            case 0:
              rotateA = 1;
              rotateB = 0;
              rotateC = 0;
              rotateD = -1;
              break;
            default:
              throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
          }
          if (dontFlip) {
            rotateC = -rotateC;
            rotateD = -rotateD;
          }
          let offsetCanvasX, offsetCanvasY;
          let width, height;
          if (rotateA === 0) {
            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
            width = Math.abs(viewBox[3] - viewBox[1]) * scale;
            height = Math.abs(viewBox[2] - viewBox[0]) * scale;
          } else {
            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
            width = Math.abs(viewBox[2] - viewBox[0]) * scale;
            height = Math.abs(viewBox[3] - viewBox[1]) * scale;
          }
          this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
          this.width = width;
          this.height = height;
        }
        clone({
          scale = this.scale,
          rotation = this.rotation,
          offsetX = this.offsetX,
          offsetY = this.offsetY,
          dontFlip = false
        } = {}) {
          return new PageViewport({
            viewBox: this.viewBox.slice(),
            scale,
            rotation,
            offsetX,
            offsetY,
            dontFlip
          });
        }
        convertToViewportPoint(x, y) {
          return _util.Util.applyTransform([x, y], this.transform);
        }
        convertToViewportRectangle(rect) {
          const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);
          const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);
          return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
        }
        convertToPdfPoint(x, y) {
          return _util.Util.applyInverseTransform([x, y], this.transform);
        }
      }
      exports.PageViewport = PageViewport;
      class RenderingCancelledException extends _util.BaseException {
        constructor(msg, type) {
          super(msg, "RenderingCancelledException");
          this.type = type;
        }
      }
      exports.RenderingCancelledException = RenderingCancelledException;
      function isDataScheme(url) {
        const ii = url.length;
        let i = 0;
        while (i < ii && url[i].trim() === "") {
          i++;
        }
        return url.substring(i, i + 5).toLowerCase() === "data:";
      }
      function isPdfFile(filename) {
        return typeof filename === "string" && /\.pdf$/i.test(filename);
      }
      function getFilenameFromUrl(url) {
        const anchor = url.indexOf("#");
        const query = url.indexOf("?");
        const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
        return url.substring(url.lastIndexOf("/", end) + 1, end);
      }
      function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
        if (typeof url !== "string") {
          return defaultFilename;
        }
        if (isDataScheme(url)) {
          (0, _util.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
          return defaultFilename;
        }
        const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
        const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
        const splitURI = reURI.exec(url);
        let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
        if (suggestedFilename) {
          suggestedFilename = suggestedFilename[0];
          if (suggestedFilename.includes("%")) {
            try {
              suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
            } catch (ex) {}
          }
        }
        return suggestedFilename || defaultFilename;
      }
      class StatTimer {
        constructor() {
          this.started = Object.create(null);
          this.times = [];
        }
        time(name) {
          if (name in this.started) {
            (0, _util.warn)(`Timer is already running for ${name}`);
          }
          this.started[name] = Date.now();
        }
        timeEnd(name) {
          if (!(name in this.started)) {
            (0, _util.warn)(`Timer has not been started for ${name}`);
          }
          this.times.push({
            name,
            start: this.started[name],
            end: Date.now()
          });
          delete this.started[name];
        }
        toString() {
          const outBuf = [];
          let longest = 0;
          for (const time of this.times) {
            const name = time.name;
            if (name.length > longest) {
              longest = name.length;
            }
          }
          for (const time of this.times) {
            const duration = time.end - time.start;
            outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\n`);
          }
          return outBuf.join("");
        }
      }
      exports.StatTimer = StatTimer;
      function isValidFetchUrl(url, baseUrl) {
        try {
          const {
            protocol
          } = baseUrl ? new URL(url, baseUrl) : new URL(url);
          return protocol === "http:" || protocol === "https:";
        } catch (ex) {
          return false;
        }
      }
      function loadScript(src, removeScriptElement = false) {
        return new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = src;
          script.onload = function (evt) {
            if (removeScriptElement) {
              script.remove();
            }
            resolve(evt);
          };
          script.onerror = function () {
            reject(new Error(`Cannot load script at: ${script.src}`));
          };
          (document.head || document.documentElement).appendChild(script);
        });
      }
      function deprecated(details) {
        console.log("Deprecated API usage: " + details);
      }
      let pdfDateStringRegex;
      class PDFDateString {
        static toDateObject(input) {
          if (!input || typeof input !== "string") {
            return null;
          }
          if (!pdfDateStringRegex) {
            pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
          }
          const matches = pdfDateStringRegex.exec(input);
          if (!matches) {
            return null;
          }
          const year = parseInt(matches[1], 10);
          let month = parseInt(matches[2], 10);
          month = month >= 1 && month <= 12 ? month - 1 : 0;
          let day = parseInt(matches[3], 10);
          day = day >= 1 && day <= 31 ? day : 1;
          let hour = parseInt(matches[4], 10);
          hour = hour >= 0 && hour <= 23 ? hour : 0;
          let minute = parseInt(matches[5], 10);
          minute = minute >= 0 && minute <= 59 ? minute : 0;
          let second = parseInt(matches[6], 10);
          second = second >= 0 && second <= 59 ? second : 0;
          const universalTimeRelation = matches[7] || "Z";
          let offsetHour = parseInt(matches[8], 10);
          offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
          let offsetMinute = parseInt(matches[9], 10) || 0;
          offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
          if (universalTimeRelation === "-") {
            hour += offsetHour;
            minute += offsetMinute;
          } else if (universalTimeRelation === "+") {
            hour -= offsetHour;
            minute -= offsetMinute;
          }
          return new Date(Date.UTC(year, month, day, hour, minute, second));
        }
      }
      exports.PDFDateString = PDFDateString;
      function getXfaPageViewport(xfaPage, {
        scale = 1,
        rotation = 0
      }) {
        const {
          width,
          height
        } = xfaPage.attributes.style;
        const viewBox = [0, 0, parseInt(width), parseInt(height)];
        return new PageViewport({
          viewBox,
          scale,
          rotation
        });
      }

      /***/
    }), ( /* 6 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;
      var _util = __w_pdfjs_require__(1);
      class BaseCanvasFactory {
        constructor() {
          if (this.constructor === BaseCanvasFactory) {
            (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
          }
        }
        create(width, height) {
          if (width <= 0 || height <= 0) {
            throw new Error("Invalid canvas size");
          }
          const canvas = this._createCanvas(width, height);
          return {
            canvas,
            context: canvas.getContext("2d")
          };
        }
        reset(canvasAndContext, width, height) {
          if (!canvasAndContext.canvas) {
            throw new Error("Canvas is not specified");
          }
          if (width <= 0 || height <= 0) {
            throw new Error("Invalid canvas size");
          }
          canvasAndContext.canvas.width = width;
          canvasAndContext.canvas.height = height;
        }
        destroy(canvasAndContext) {
          if (!canvasAndContext.canvas) {
            throw new Error("Canvas is not specified");
          }
          canvasAndContext.canvas.width = 0;
          canvasAndContext.canvas.height = 0;
          canvasAndContext.canvas = null;
          canvasAndContext.context = null;
        }
        _createCanvas(width, height) {
          (0, _util.unreachable)("Abstract method `_createCanvas` called.");
        }
      }
      exports.BaseCanvasFactory = BaseCanvasFactory;
      class BaseCMapReaderFactory {
        constructor({
          baseUrl = null,
          isCompressed = false
        }) {
          if (this.constructor === BaseCMapReaderFactory) {
            (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
          }
          this.baseUrl = baseUrl;
          this.isCompressed = isCompressed;
        }
        fetch({
          name
        }) {
          var _this7 = this;
          return _asyncToGenerator(function* () {
            if (!_this7.baseUrl) {
              throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');
            }
            if (!name) {
              throw new Error("CMap name must be specified.");
            }
            const url = _this7.baseUrl + name + (_this7.isCompressed ? ".bcmap" : "");
            const compressionType = _this7.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
            return _this7._fetchData(url, compressionType).catch(reason => {
              throw new Error(`Unable to load ${_this7.isCompressed ? "binary " : ""}CMap at: ${url}`);
            });
          })();
        }
        _fetchData(url, compressionType) {
          (0, _util.unreachable)("Abstract method `_fetchData` called.");
        }
      }
      exports.BaseCMapReaderFactory = BaseCMapReaderFactory;
      class BaseStandardFontDataFactory {
        constructor({
          baseUrl = null
        }) {
          if (this.constructor === BaseStandardFontDataFactory) {
            (0, _util.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
          }
          this.baseUrl = baseUrl;
        }
        fetch({
          filename
        }) {
          var _this8 = this;
          return _asyncToGenerator(function* () {
            if (!_this8.baseUrl) {
              throw new Error('The standard font "baseUrl" parameter must be specified, ensure that ' + 'the "standardFontDataUrl" API parameter is provided.');
            }
            if (!filename) {
              throw new Error("Font filename must be specified.");
            }
            const url = `${_this8.baseUrl}${filename}`;
            return _this8._fetchData(url).catch(reason => {
              throw new Error(`Unable to load font data at: ${url}`);
            });
          })();
        }
        _fetchData(url) {
          (0, _util.unreachable)("Abstract method `_fetchData` called.");
        }
      }
      exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
      class BaseSVGFactory {
        constructor() {
          if (this.constructor === BaseSVGFactory) {
            (0, _util.unreachable)("Cannot initialize BaseSVGFactory.");
          }
        }
        create(width, height) {
          if (width <= 0 || height <= 0) {
            throw new Error("Invalid SVG dimensions");
          }
          const svg = this._createSVG("svg:svg");
          svg.setAttribute("version", "1.1");
          svg.setAttribute("width", `${width}px`);
          svg.setAttribute("height", `${height}px`);
          svg.setAttribute("preserveAspectRatio", "none");
          svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
          return svg;
        }
        createElement(type) {
          if (typeof type !== "string") {
            throw new Error("Invalid SVG element type");
          }
          return this._createSVG(type);
        }
        _createSVG(type) {
          (0, _util.unreachable)("Abstract method `_createSVG` called.");
        }
      }
      exports.BaseSVGFactory = BaseSVGFactory;

      /***/
    }), ( /* 7 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.FontLoader = exports.FontFaceObject = void 0;
      var _util = __w_pdfjs_require__(1);
      class BaseFontLoader {
        constructor({
          docId,
          onUnsupportedFeature,
          ownerDocument = globalThis.document,
          styleElement = null
        }) {
          if (this.constructor === BaseFontLoader) {
            (0, _util.unreachable)("Cannot initialize BaseFontLoader.");
          }
          this.docId = docId;
          this._onUnsupportedFeature = onUnsupportedFeature;
          this._document = ownerDocument;
          this.nativeFontFaces = [];
          this.styleElement = null;
        }
        addNativeFontFace(nativeFontFace) {
          this.nativeFontFaces.push(nativeFontFace);
          this._document.fonts.add(nativeFontFace);
        }
        insertRule(rule) {
          let styleElement = this.styleElement;
          if (!styleElement) {
            styleElement = this.styleElement = this._document.createElement("style");
            styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;
            this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
          }
          const styleSheet = styleElement.sheet;
          styleSheet.insertRule(rule, styleSheet.cssRules.length);
        }
        clear() {
          for (const nativeFontFace of this.nativeFontFaces) {
            this._document.fonts.delete(nativeFontFace);
          }
          this.nativeFontFaces.length = 0;
          if (this.styleElement) {
            this.styleElement.remove();
            this.styleElement = null;
          }
        }
        bind(font) {
          var _this9 = this;
          return _asyncToGenerator(function* () {
            if (font.attached || font.missingFile) {
              return;
            }
            font.attached = true;
            if (_this9.isFontLoadingAPISupported) {
              const nativeFontFace = font.createNativeFontFace();
              if (nativeFontFace) {
                _this9.addNativeFontFace(nativeFontFace);
                try {
                  yield nativeFontFace.loaded;
                } catch (ex) {
                  _this9._onUnsupportedFeature({
                    featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative
                  });
                  (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                  font.disableFontFace = true;
                  throw ex;
                }
              }
              return;
            }
            const rule = font.createFontFaceRule();
            if (rule) {
              _this9.insertRule(rule);
              if (_this9.isSyncFontLoadingSupported) {
                return;
              }
              yield new Promise(resolve => {
                const request = _this9._queueLoadingCallback(resolve);
                _this9._prepareFontLoadEvent([rule], [font], request);
              });
            }
          })();
        }
        _queueLoadingCallback(callback) {
          (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");
        }
        get isFontLoadingAPISupported() {
          var _this$_document;
          const hasFonts = !!((_this$_document = this._document) !== null && _this$_document !== void 0 && _this$_document.fonts);
          return (0, _util.shadow)(this, "isFontLoadingAPISupported", hasFonts);
        }
        get isSyncFontLoadingSupported() {
          (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
        }
        get _loadTestFont() {
          (0, _util.unreachable)("Abstract method `_loadTestFont`.");
        }
        _prepareFontLoadEvent(rules, fontsToLoad, request) {
          (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");
        }
      }
      let FontLoader;
      exports.FontLoader = FontLoader;
      {
        exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
          constructor(params) {
            super(params);
            this.loadingContext = {
              requests: [],
              nextRequestId: 0
            };
            this.loadTestFontId = 0;
          }
          get isSyncFontLoadingSupported() {
            let supported = false;
            if (typeof navigator === "undefined") {
              supported = true;
            } else {
              const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
              if ((m === null || m === void 0 ? void 0 : m[1]) >= 14) {
                supported = true;
              }
            }
            return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
          }
          _queueLoadingCallback(callback) {
            function completeRequest() {
              (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
              request.done = true;
              while (context.requests.length > 0 && context.requests[0].done) {
                const otherRequest = context.requests.shift();
                setTimeout(otherRequest.callback, 0);
              }
            }
            const context = this.loadingContext;
            const request = {
              id: `pdfjs-font-loading-${context.nextRequestId++}`,
              done: false,
              complete: completeRequest,
              callback
            };
            context.requests.push(request);
            return request;
          }
          get _loadTestFont() {
            const getLoadTestFont = function () {
              return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
            };
            return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());
          }
          _prepareFontLoadEvent(rules, fonts, request) {
            function int32(data, offset) {
              return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
            }
            function spliceString(s, offset, remove, insert) {
              const chunk1 = s.substring(0, offset);
              const chunk2 = s.substring(offset + remove);
              return chunk1 + insert + chunk2;
            }
            let i, ii;
            const canvas = this._document.createElement("canvas");
            canvas.width = 1;
            canvas.height = 1;
            const ctx = canvas.getContext("2d");
            let called = 0;
            function isFontReady(name, callback) {
              called++;
              if (called > 30) {
                (0, _util.warn)("Load test font never loaded.");
                callback();
                return;
              }
              ctx.font = "30px " + name;
              ctx.fillText(".", 0, 20);
              const imageData = ctx.getImageData(0, 0, 1, 1);
              if (imageData.data[3] > 0) {
                callback();
                return;
              }
              setTimeout(isFontReady.bind(null, name, callback));
            }
            const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
            let data = this._loadTestFont;
            const COMMENT_OFFSET = 976;
            data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
            const CFF_CHECKSUM_OFFSET = 16;
            const XXXX_VALUE = 0x58585858;
            let checksum = int32(data, CFF_CHECKSUM_OFFSET);
            for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
              checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
            }
            if (i < loadTestFontId.length) {
              checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
            }
            data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
            const url = `url(data:font/opentype;base64,${btoa(data)});`;
            const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
            this.insertRule(rule);
            const names = [];
            for (const font of fonts) {
              names.push(font.loadedName);
            }
            names.push(loadTestFontId);
            const div = this._document.createElement("div");
            div.style.visibility = "hidden";
            div.style.width = div.style.height = "10px";
            div.style.position = "absolute";
            div.style.top = div.style.left = "0px";
            for (const name of names) {
              const span = this._document.createElement("span");
              span.textContent = "Hi";
              span.style.fontFamily = name;
              div.appendChild(span);
            }
            this._document.body.appendChild(div);
            isFontReady(loadTestFontId, () => {
              div.remove();
              request.complete();
            });
          }
        };
      }
      class FontFaceObject {
        constructor(translatedData, {
          isEvalSupported = true,
          disableFontFace = false,
          ignoreErrors = false,
          onUnsupportedFeature,
          fontRegistry = null
        }) {
          this.compiledGlyphs = Object.create(null);
          for (const i in translatedData) {
            this[i] = translatedData[i];
          }
          this.isEvalSupported = isEvalSupported !== false;
          this.disableFontFace = disableFontFace === true;
          this.ignoreErrors = ignoreErrors === true;
          this._onUnsupportedFeature = onUnsupportedFeature;
          this.fontRegistry = fontRegistry;
        }
        createNativeFontFace() {
          if (!this.data || this.disableFontFace) {
            return null;
          }
          let nativeFontFace;
          if (!this.cssFontInfo) {
            nativeFontFace = new FontFace(this.loadedName, this.data, {});
          } else {
            const css = {
              weight: this.cssFontInfo.fontWeight
            };
            if (this.cssFontInfo.italicAngle) {
              css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
            }
            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
          }
          if (this.fontRegistry) {
            this.fontRegistry.registerFont(this);
          }
          return nativeFontFace;
        }
        createFontFaceRule() {
          if (!this.data || this.disableFontFace) {
            return null;
          }
          const data = (0, _util.bytesToString)(this.data);
          const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
          let rule;
          if (!this.cssFontInfo) {
            rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
          } else {
            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
            if (this.cssFontInfo.italicAngle) {
              css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
            }
            rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
          }
          if (this.fontRegistry) {
            this.fontRegistry.registerFont(this, url);
          }
          return rule;
        }
        getPathGenerator(objs, character) {
          if (this.compiledGlyphs[character] !== undefined) {
            return this.compiledGlyphs[character];
          }
          let cmds;
          try {
            cmds = objs.get(this.loadedName + "_path_" + character);
          } catch (ex) {
            if (!this.ignoreErrors) {
              throw ex;
            }
            this._onUnsupportedFeature({
              featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath
            });
            (0, _util.warn)(`getPathGenerator - ignoring character: "${ex}".`);
            return this.compiledGlyphs[character] = function (c, size) {};
          }
          if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {
            const jsBuf = [];
            for (const current of cmds) {
              const args = current.args !== undefined ? current.args.join(",") : "";
              jsBuf.push("c.", current.cmd, "(", args, ");\n");
            }
            return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
          }
          return this.compiledGlyphs[character] = function (c, size) {
            for (const current of cmds) {
              if (current.cmd === "scale") {
                current.args = [size, -size];
              }
              c[current.cmd].apply(c, current.args);
            }
          };
        }
      }
      exports.FontFaceObject = FontFaceObject;

      /***/
    }), ( /* 8 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AnnotationStorage = void 0;
      var _murmurhash = __w_pdfjs_require__(9);
      var _util = __w_pdfjs_require__(1);
      class AnnotationStorage {
        constructor() {
          this._storage = new Map();
          this._modified = false;
          this.onSetModified = null;
          this.onResetModified = null;
        }
        getValue(key, defaultValue) {
          const value = this._storage.get(key);
          if (value === undefined) {
            return defaultValue;
          }
          return Object.assign(defaultValue, value);
        }
        getRawValue(key) {
          return this._storage.get(key);
        }
        setValue(key, value) {
          const obj = this._storage.get(key);
          let modified = false;
          if (obj !== undefined) {
            for (const [entry, val] of Object.entries(value)) {
              if (obj[entry] !== val) {
                modified = true;
                obj[entry] = val;
              }
            }
          } else {
            modified = true;
            this._storage.set(key, value);
          }
          if (modified) {
            this._setModified();
          }
        }
        getAll() {
          return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;
        }
        get size() {
          return this._storage.size;
        }
        _setModified() {
          if (!this._modified) {
            this._modified = true;
            if (typeof this.onSetModified === "function") {
              this.onSetModified();
            }
          }
        }
        resetModified() {
          if (this._modified) {
            this._modified = false;
            if (typeof this.onResetModified === "function") {
              this.onResetModified();
            }
          }
        }
        get serializable() {
          return this._storage.size > 0 ? this._storage : null;
        }
        get hash() {
          const hash = new _murmurhash.MurmurHash3_64();
          for (const [key, value] of this._storage) {
            hash.update(`${key}:${JSON.stringify(value)}`);
          }
          return hash.hexdigest();
        }
      }
      exports.AnnotationStorage = AnnotationStorage;

      /***/
    }), ( /* 9 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MurmurHash3_64 = void 0;
      var _util = __w_pdfjs_require__(1);
      const SEED = 0xc3d2e1f0;
      const MASK_HIGH = 0xffff0000;
      const MASK_LOW = 0xffff;
      class MurmurHash3_64 {
        constructor(seed) {
          this.h1 = seed ? seed & 0xffffffff : SEED;
          this.h2 = seed ? seed & 0xffffffff : SEED;
        }
        update(input) {
          let data, length;
          if (typeof input === "string") {
            data = new Uint8Array(input.length * 2);
            length = 0;
            for (let i = 0, ii = input.length; i < ii; i++) {
              const code = input.charCodeAt(i);
              if (code <= 0xff) {
                data[length++] = code;
              } else {
                data[length++] = code >>> 8;
                data[length++] = code & 0xff;
              }
            }
          } else if ((0, _util.isArrayBuffer)(input)) {
            data = input.slice();
            length = data.byteLength;
          } else {
            throw new Error("Wrong data format in MurmurHash3_64_update. " + "Input must be a string or array.");
          }
          const blockCounts = length >> 2;
          const tailLength = length - blockCounts * 4;
          const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
          let k1 = 0,
            k2 = 0;
          let h1 = this.h1,
            h2 = this.h2;
          const C1 = 0xcc9e2d51,
            C2 = 0x1b873593;
          const C1_LOW = C1 & MASK_LOW,
            C2_LOW = C2 & MASK_LOW;
          for (let i = 0; i < blockCounts; i++) {
            if (i & 1) {
              k1 = dataUint32[i];
              k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
              k1 = k1 << 15 | k1 >>> 17;
              k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
              h1 ^= k1;
              h1 = h1 << 13 | h1 >>> 19;
              h1 = h1 * 5 + 0xe6546b64;
            } else {
              k2 = dataUint32[i];
              k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
              k2 = k2 << 15 | k2 >>> 17;
              k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
              h2 ^= k2;
              h2 = h2 << 13 | h2 >>> 19;
              h2 = h2 * 5 + 0xe6546b64;
            }
          }
          k1 = 0;
          switch (tailLength) {
            case 3:
              k1 ^= data[blockCounts * 4 + 2] << 16;
            case 2:
              k1 ^= data[blockCounts * 4 + 1] << 8;
            case 1:
              k1 ^= data[blockCounts * 4];
              k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
              k1 = k1 << 15 | k1 >>> 17;
              k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
              if (blockCounts & 1) {
                h1 ^= k1;
              } else {
                h2 ^= k1;
              }
          }
          this.h1 = h1;
          this.h2 = h2;
        }
        hexdigest() {
          let h1 = this.h1,
            h2 = this.h2;
          h1 ^= h2 >>> 1;
          h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
          h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
          h1 ^= h2 >>> 1;
          h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
          h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
          h1 ^= h2 >>> 1;
          const hex1 = (h1 >>> 0).toString(16),
            hex2 = (h2 >>> 0).toString(16);
          return hex1.padStart(8, "0") + hex2.padStart(8, "0");
        }
      }
      exports.MurmurHash3_64 = MurmurHash3_64;

      /***/
    }), ( /* 10 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CanvasGraphics = void 0;
      var _util = __w_pdfjs_require__(1);
      var _pattern_helper = __w_pdfjs_require__(11);
      var _image_utils = __w_pdfjs_require__(12);
      var _is_node = __w_pdfjs_require__(3);
      var _display_utils = __w_pdfjs_require__(5);
      const MIN_FONT_SIZE = 16;
      const MAX_FONT_SIZE = 100;
      const MAX_GROUP_SIZE = 4096;
      const EXECUTION_TIME = 15;
      const EXECUTION_STEPS = 10;
      const COMPILE_TYPE3_GLYPHS = true;
      const MAX_SIZE_TO_COMPILE = 1000;
      const FULL_CHUNK_HEIGHT = 16;
      const LINEWIDTH_SCALE_FACTOR = 1.000001;
      function mirrorContextOperations(ctx, destCtx) {
        if (ctx._removeMirroring) {
          throw new Error("Context is already forwarding operations.");
        }
        ctx.__originalSave = ctx.save;
        ctx.__originalRestore = ctx.restore;
        ctx.__originalRotate = ctx.rotate;
        ctx.__originalScale = ctx.scale;
        ctx.__originalTranslate = ctx.translate;
        ctx.__originalTransform = ctx.transform;
        ctx.__originalSetTransform = ctx.setTransform;
        ctx.__originalResetTransform = ctx.resetTransform;
        ctx.__originalClip = ctx.clip;
        ctx.__originalMoveTo = ctx.moveTo;
        ctx.__originalLineTo = ctx.lineTo;
        ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
        ctx.__originalRect = ctx.rect;
        ctx.__originalClosePath = ctx.closePath;
        ctx.__originalBeginPath = ctx.beginPath;
        ctx._removeMirroring = () => {
          ctx.save = ctx.__originalSave;
          ctx.restore = ctx.__originalRestore;
          ctx.rotate = ctx.__originalRotate;
          ctx.scale = ctx.__originalScale;
          ctx.translate = ctx.__originalTranslate;
          ctx.transform = ctx.__originalTransform;
          ctx.setTransform = ctx.__originalSetTransform;
          ctx.resetTransform = ctx.__originalResetTransform;
          ctx.clip = ctx.__originalClip;
          ctx.moveTo = ctx.__originalMoveTo;
          ctx.lineTo = ctx.__originalLineTo;
          ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
          ctx.rect = ctx.__originalRect;
          ctx.closePath = ctx.__originalClosePath;
          ctx.beginPath = ctx.__originalBeginPath;
          delete ctx._removeMirroring;
        };
        ctx.save = function ctxSave() {
          destCtx.save();
          this.__originalSave();
        };
        ctx.restore = function ctxRestore() {
          destCtx.restore();
          this.__originalRestore();
        };
        ctx.translate = function ctxTranslate(x, y) {
          destCtx.translate(x, y);
          this.__originalTranslate(x, y);
        };
        ctx.scale = function ctxScale(x, y) {
          destCtx.scale(x, y);
          this.__originalScale(x, y);
        };
        ctx.transform = function ctxTransform(a, b, c, d, e, f) {
          destCtx.transform(a, b, c, d, e, f);
          this.__originalTransform(a, b, c, d, e, f);
        };
        ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
          destCtx.setTransform(a, b, c, d, e, f);
          this.__originalSetTransform(a, b, c, d, e, f);
        };
        ctx.resetTransform = function ctxResetTransform() {
          destCtx.resetTransform();
          this.__originalResetTransform();
        };
        ctx.rotate = function ctxRotate(angle) {
          destCtx.rotate(angle);
          this.__originalRotate(angle);
        };
        ctx.clip = function ctxRotate(rule) {
          destCtx.clip(rule);
          this.__originalClip(rule);
        };
        ctx.moveTo = function (x, y) {
          destCtx.moveTo(x, y);
          this.__originalMoveTo(x, y);
        };
        ctx.lineTo = function (x, y) {
          destCtx.lineTo(x, y);
          this.__originalLineTo(x, y);
        };
        ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
          destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
          this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        };
        ctx.rect = function (x, y, width, height) {
          destCtx.rect(x, y, width, height);
          this.__originalRect(x, y, width, height);
        };
        ctx.closePath = function () {
          destCtx.closePath();
          this.__originalClosePath();
        };
        ctx.beginPath = function () {
          destCtx.beginPath();
          this.__originalBeginPath();
        };
      }
      function addContextCurrentTransform(ctx) {
        if (ctx._transformStack) {
          ctx._transformStack = [];
        }
        if (ctx.mozCurrentTransform) {
          return;
        }
        ctx._originalSave = ctx.save;
        ctx._originalRestore = ctx.restore;
        ctx._originalRotate = ctx.rotate;
        ctx._originalScale = ctx.scale;
        ctx._originalTranslate = ctx.translate;
        ctx._originalTransform = ctx.transform;
        ctx._originalSetTransform = ctx.setTransform;
        ctx._originalResetTransform = ctx.resetTransform;
        ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
        ctx._transformStack = [];
        try {
          const desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), "lineWidth");
          ctx._setLineWidth = desc.set;
          ctx._getLineWidth = desc.get;
          Object.defineProperty(ctx, "lineWidth", {
            set: function setLineWidth(width) {
              this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);
            },
            get: function getLineWidth() {
              return this._getLineWidth();
            }
          });
        } catch (_) {}
        Object.defineProperty(ctx, "mozCurrentTransform", {
          get: function getCurrentTransform() {
            return this._transformMatrix;
          }
        });
        Object.defineProperty(ctx, "mozCurrentTransformInverse", {
          get: function getCurrentTransformInverse() {
            const [a, b, c, d, e, f] = this._transformMatrix;
            const ad_bc = a * d - b * c;
            const bc_ad = b * c - a * d;
            return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
          }
        });
        ctx.save = function ctxSave() {
          const old = this._transformMatrix;
          this._transformStack.push(old);
          this._transformMatrix = old.slice(0, 6);
          this._originalSave();
        };
        ctx.restore = function ctxRestore() {
          if (this._transformStack.length === 0) {
            (0, _util.warn)("Tried to restore a ctx when the stack was already empty.");
          }
          const prev = this._transformStack.pop();
          if (prev) {
            this._transformMatrix = prev;
            this._originalRestore();
          }
        };
        ctx.translate = function ctxTranslate(x, y) {
          const m = this._transformMatrix;
          m[4] = m[0] * x + m[2] * y + m[4];
          m[5] = m[1] * x + m[3] * y + m[5];
          this._originalTranslate(x, y);
        };
        ctx.scale = function ctxScale(x, y) {
          const m = this._transformMatrix;
          m[0] *= x;
          m[1] *= x;
          m[2] *= y;
          m[3] *= y;
          this._originalScale(x, y);
        };
        ctx.transform = function ctxTransform(a, b, c, d, e, f) {
          const m = this._transformMatrix;
          this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
          ctx._originalTransform(a, b, c, d, e, f);
        };
        ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
          this._transformMatrix = [a, b, c, d, e, f];
          ctx._originalSetTransform(a, b, c, d, e, f);
        };
        ctx.resetTransform = function ctxResetTransform() {
          this._transformMatrix = [1, 0, 0, 1, 0, 0];
          ctx._originalResetTransform();
        };
        ctx.rotate = function ctxRotate(angle) {
          const cosValue = Math.cos(angle);
          const sinValue = Math.sin(angle);
          const m = this._transformMatrix;
          this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
          this._originalRotate(angle);
        };
      }
      class CachedCanvases {
        constructor(canvasFactory) {
          this.canvasFactory = canvasFactory;
          this.cache = Object.create(null);
        }
        getCanvas(id, width, height, trackTransform) {
          let canvasEntry;
          if (this.cache[id] !== undefined) {
            canvasEntry = this.cache[id];
            this.canvasFactory.reset(canvasEntry, width, height);
            canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
          } else {
            canvasEntry = this.canvasFactory.create(width, height);
            this.cache[id] = canvasEntry;
          }
          if (trackTransform) {
            addContextCurrentTransform(canvasEntry.context);
          }
          return canvasEntry;
        }
        delete(id) {
          delete this.cache[id];
        }
        clear() {
          for (const id in this.cache) {
            const canvasEntry = this.cache[id];
            this.canvasFactory.destroy(canvasEntry);
            delete this.cache[id];
          }
        }
      }
      function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
        const [a, b, c, d, tx, ty] = ctx.mozCurrentTransform;
        if (b === 0 && c === 0) {
          const tlX = destX * a + tx;
          const rTlX = Math.round(tlX);
          const tlY = destY * d + ty;
          const rTlY = Math.round(tlY);
          const brX = (destX + destW) * a + tx;
          const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
          const brY = (destY + destH) * d + ty;
          const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
          ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
          ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
          ctx.setTransform(a, b, c, d, tx, ty);
          return [rWidth, rHeight];
        }
        if (a === 0 && d === 0) {
          const tlX = destY * c + tx;
          const rTlX = Math.round(tlX);
          const tlY = destX * b + ty;
          const rTlY = Math.round(tlY);
          const brX = (destY + destH) * c + tx;
          const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
          const brY = (destX + destW) * b + ty;
          const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
          ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
          ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
          ctx.setTransform(a, b, c, d, tx, ty);
          return [rHeight, rWidth];
        }
        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
        const scaleX = Math.hypot(a, b);
        const scaleY = Math.hypot(c, d);
        return [scaleX * destW, scaleY * destH];
      }
      function compileType3Glyph(imgData) {
        const {
          width,
          height
        } = imgData;
        if (!COMPILE_TYPE3_GLYPHS || width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
          return null;
        }
        const POINT_TO_PROCESS_LIMIT = 1000;
        const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
        const width1 = width + 1;
        let points = new Uint8Array(width1 * (height + 1));
        let i, j, j0;
        const lineSize = width + 7 & ~7;
        let data = new Uint8Array(lineSize * height),
          pos = 0;
        for (const elem of imgData.data) {
          let mask = 128;
          while (mask > 0) {
            data[pos++] = elem & mask ? 0 : 255;
            mask >>= 1;
          }
        }
        let count = 0;
        pos = 0;
        if (data[pos] !== 0) {
          points[0] = 1;
          ++count;
        }
        for (j = 1; j < width; j++) {
          if (data[pos] !== data[pos + 1]) {
            points[j] = data[pos] ? 2 : 1;
            ++count;
          }
          pos++;
        }
        if (data[pos] !== 0) {
          points[j] = 2;
          ++count;
        }
        for (i = 1; i < height; i++) {
          pos = i * lineSize;
          j0 = i * width1;
          if (data[pos - lineSize] !== data[pos]) {
            points[j0] = data[pos] ? 1 : 8;
            ++count;
          }
          let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
          for (j = 1; j < width; j++) {
            sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
            if (POINT_TYPES[sum]) {
              points[j0 + j] = POINT_TYPES[sum];
              ++count;
            }
            pos++;
          }
          if (data[pos - lineSize] !== data[pos]) {
            points[j0 + j] = data[pos] ? 2 : 4;
            ++count;
          }
          if (count > POINT_TO_PROCESS_LIMIT) {
            return null;
          }
        }
        pos = lineSize * (height - 1);
        j0 = i * width1;
        if (data[pos] !== 0) {
          points[j0] = 8;
          ++count;
        }
        for (j = 1; j < width; j++) {
          if (data[pos] !== data[pos + 1]) {
            points[j0 + j] = data[pos] ? 4 : 8;
            ++count;
          }
          pos++;
        }
        if (data[pos] !== 0) {
          points[j0 + j] = 4;
          ++count;
        }
        if (count > POINT_TO_PROCESS_LIMIT) {
          return null;
        }
        const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
        let path, outlines, coords;
        if (!_is_node.isNodeJS) {
          path = new Path2D();
        } else {
          outlines = [];
        }
        for (i = 0; count && i <= height; i++) {
          let p = i * width1;
          const end = p + width;
          while (p < end && !points[p]) {
            p++;
          }
          if (p === end) {
            continue;
          }
          if (path) {
            path.moveTo(p % width1, i);
          } else {
            coords = [p % width1, i];
          }
          const p0 = p;
          let type = points[p];
          do {
            const step = steps[type];
            do {
              p += step;
            } while (!points[p]);
            const pp = points[p];
            if (pp !== 5 && pp !== 10) {
              type = pp;
              points[p] = 0;
            } else {
              type = pp & 0x33 * type >> 4;
              points[p] &= type >> 2 | type << 2;
            }
            if (path) {
              path.lineTo(p % width1, p / width1 | 0);
            } else {
              coords.push(p % width1, p / width1 | 0);
            }
            if (!points[p]) {
              --count;
            }
          } while (p0 !== p);
          if (!path) {
            outlines.push(coords);
          }
          --i;
        }
        data = null;
        points = null;
        const drawOutline = function (c) {
          c.save();
          c.scale(1 / width, -1 / height);
          c.translate(0, -height);
          if (path) {
            c.fill(path);
          } else {
            c.beginPath();
            for (const o of outlines) {
              c.moveTo(o[0], o[1]);
              for (let l = 2, ll = o.length; l < ll; l += 2) {
                c.lineTo(o[l], o[l + 1]);
              }
            }
            c.fill();
          }
          c.beginPath();
          c.restore();
        };
        return drawOutline;
      }
      class CanvasExtraState {
        constructor(width, height) {
          this.alphaIsShape = false;
          this.fontSize = 0;
          this.fontSizeScale = 1;
          this.textMatrix = _util.IDENTITY_MATRIX;
          this.textMatrixScale = 1;
          this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
          this.leading = 0;
          this.x = 0;
          this.y = 0;
          this.lineX = 0;
          this.lineY = 0;
          this.charSpacing = 0;
          this.wordSpacing = 0;
          this.textHScale = 1;
          this.textRenderingMode = _util.TextRenderingMode.FILL;
          this.textRise = 0;
          this.fillColor = "#000000";
          this.strokeColor = "#000000";
          this.patternFill = false;
          this.fillAlpha = 1;
          this.strokeAlpha = 1;
          this.lineWidth = 1;
          this.activeSMask = null;
          this.transferMaps = null;
          this.startNewPathAndClipBox([0, 0, width, height]);
        }
        clone() {
          const clone = Object.create(this);
          clone.clipBox = this.clipBox.slice();
          return clone;
        }
        setCurrentPoint(x, y) {
          this.x = x;
          this.y = y;
        }
        updatePathMinMax(transform, x, y) {
          [x, y] = _util.Util.applyTransform([x, y], transform);
          this.minX = Math.min(this.minX, x);
          this.minY = Math.min(this.minY, y);
          this.maxX = Math.max(this.maxX, x);
          this.maxY = Math.max(this.maxY, y);
        }
        updateRectMinMax(transform, rect) {
          const p1 = _util.Util.applyTransform(rect, transform);
          const p2 = _util.Util.applyTransform(rect.slice(2), transform);
          this.minX = Math.min(this.minX, p1[0], p2[0]);
          this.minY = Math.min(this.minY, p1[1], p2[1]);
          this.maxX = Math.max(this.maxX, p1[0], p2[0]);
          this.maxY = Math.max(this.maxY, p1[1], p2[1]);
        }
        updateScalingPathMinMax(transform, minMax) {
          _util.Util.scaleMinMax(transform, minMax);
          this.minX = Math.min(this.minX, minMax[0]);
          this.maxX = Math.max(this.maxX, minMax[1]);
          this.minY = Math.min(this.minY, minMax[2]);
          this.maxY = Math.max(this.maxY, minMax[3]);
        }
        updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
          const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
          if (minMax) {
            minMax[0] = Math.min(minMax[0], box[0], box[2]);
            minMax[1] = Math.max(minMax[1], box[0], box[2]);
            minMax[2] = Math.min(minMax[2], box[1], box[3]);
            minMax[3] = Math.max(minMax[3], box[1], box[3]);
            return;
          }
          this.updateRectMinMax(transform, box);
        }
        getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
          const box = [this.minX, this.minY, this.maxX, this.maxY];
          if (pathType === _pattern_helper.PathType.STROKE) {
            if (!transform) {
              (0, _util.unreachable)("Stroke bounding box must include transform.");
            }
            const scale = _util.Util.singularValueDecompose2dScale(transform);
            const xStrokePad = scale[0] * this.lineWidth / 2;
            const yStrokePad = scale[1] * this.lineWidth / 2;
            box[0] -= xStrokePad;
            box[1] -= yStrokePad;
            box[2] += xStrokePad;
            box[3] += yStrokePad;
          }
          return box;
        }
        updateClipFromPath() {
          const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());
          this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
        }
        isEmptyClip() {
          return this.minX === Infinity;
        }
        startNewPathAndClipBox(box) {
          this.clipBox = box;
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = 0;
          this.maxY = 0;
        }
        getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
          return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
        }
      }
      function putBinaryImageData(ctx, imgData, transferMaps = null) {
        if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
          ctx.putImageData(imgData, 0, 0);
          return;
        }
        const height = imgData.height,
          width = imgData.width;
        const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
        const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
        const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
        const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
        let srcPos = 0,
          destPos;
        const src = imgData.data;
        const dest = chunkImgData.data;
        let i, j, thisChunkHeight, elemsInThisChunk;
        let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;
        if (transferMaps) {
          switch (transferMaps.length) {
            case 1:
              transferMapRed = transferMaps[0];
              transferMapGreen = transferMaps[0];
              transferMapBlue = transferMaps[0];
              transferMapGray = transferMaps[0];
              break;
            case 4:
              transferMapRed = transferMaps[0];
              transferMapGreen = transferMaps[1];
              transferMapBlue = transferMaps[2];
              transferMapGray = transferMaps[3];
              break;
          }
        }
        if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
          const srcLength = src.byteLength;
          const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
          const dest32DataLength = dest32.length;
          const fullSrcDiff = width + 7 >> 3;
          let white = 0xffffffff;
          let black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
          if (transferMapGray) {
            if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {
              [white, black] = [black, white];
            }
          }
          for (i = 0; i < totalChunks; i++) {
            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
            destPos = 0;
            for (j = 0; j < thisChunkHeight; j++) {
              const srcDiff = srcLength - srcPos;
              let k = 0;
              const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
              const kEndUnrolled = kEnd & ~7;
              let mask = 0;
              let srcByte = 0;
              for (; k < kEndUnrolled; k += 8) {
                srcByte = src[srcPos++];
                dest32[destPos++] = srcByte & 128 ? white : black;
                dest32[destPos++] = srcByte & 64 ? white : black;
                dest32[destPos++] = srcByte & 32 ? white : black;
                dest32[destPos++] = srcByte & 16 ? white : black;
                dest32[destPos++] = srcByte & 8 ? white : black;
                dest32[destPos++] = srcByte & 4 ? white : black;
                dest32[destPos++] = srcByte & 2 ? white : black;
                dest32[destPos++] = srcByte & 1 ? white : black;
              }
              for (; k < kEnd; k++) {
                if (mask === 0) {
                  srcByte = src[srcPos++];
                  mask = 128;
                }
                dest32[destPos++] = srcByte & mask ? white : black;
                mask >>= 1;
              }
            }
            while (destPos < dest32DataLength) {
              dest32[destPos++] = 0;
            }
            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
          }
        } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
          const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
          j = 0;
          elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
          for (i = 0; i < fullChunks; i++) {
            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
            srcPos += elemsInThisChunk;
            if (hasTransferMaps) {
              for (let k = 0; k < elemsInThisChunk; k += 4) {
                if (transferMapRed) {
                  dest[k + 0] = transferMapRed[dest[k + 0]];
                }
                if (transferMapGreen) {
                  dest[k + 1] = transferMapGreen[dest[k + 1]];
                }
                if (transferMapBlue) {
                  dest[k + 2] = transferMapBlue[dest[k + 2]];
                }
              }
            }
            ctx.putImageData(chunkImgData, 0, j);
            j += FULL_CHUNK_HEIGHT;
          }
          if (i < totalChunks) {
            elemsInThisChunk = width * partialChunkHeight * 4;
            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
            if (hasTransferMaps) {
              for (let k = 0; k < elemsInThisChunk; k += 4) {
                if (transferMapRed) {
                  dest[k + 0] = transferMapRed[dest[k + 0]];
                }
                if (transferMapGreen) {
                  dest[k + 1] = transferMapGreen[dest[k + 1]];
                }
                if (transferMapBlue) {
                  dest[k + 2] = transferMapBlue[dest[k + 2]];
                }
              }
            }
            ctx.putImageData(chunkImgData, 0, j);
          }
        } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
          const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
          thisChunkHeight = FULL_CHUNK_HEIGHT;
          elemsInThisChunk = width * thisChunkHeight;
          for (i = 0; i < totalChunks; i++) {
            if (i >= fullChunks) {
              thisChunkHeight = partialChunkHeight;
              elemsInThisChunk = width * thisChunkHeight;
            }
            destPos = 0;
            for (j = elemsInThisChunk; j--;) {
              dest[destPos++] = src[srcPos++];
              dest[destPos++] = src[srcPos++];
              dest[destPos++] = src[srcPos++];
              dest[destPos++] = 255;
            }
            if (hasTransferMaps) {
              for (let k = 0; k < destPos; k += 4) {
                if (transferMapRed) {
                  dest[k + 0] = transferMapRed[dest[k + 0]];
                }
                if (transferMapGreen) {
                  dest[k + 1] = transferMapGreen[dest[k + 1]];
                }
                if (transferMapBlue) {
                  dest[k + 2] = transferMapBlue[dest[k + 2]];
                }
              }
            }
            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
          }
        } else {
          throw new Error(`bad image kind: ${imgData.kind}`);
        }
      }
      function putBinaryImageMask(ctx, imgData) {
        if (imgData.bitmap) {
          ctx.drawImage(imgData.bitmap, 0, 0);
          return;
        }
        const height = imgData.height,
          width = imgData.width;
        const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
        const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
        const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
        const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
        let srcPos = 0;
        const src = imgData.data;
        const dest = chunkImgData.data;
        for (let i = 0; i < totalChunks; i++) {
          const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
          ({
            srcPos
          } = (0, _image_utils.applyMaskImageData)({
            src,
            srcPos,
            dest,
            width,
            height: thisChunkHeight
          }));
          ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
        }
      }
      function copyCtxState(sourceCtx, destCtx) {
        const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
        for (let i = 0, ii = properties.length; i < ii; i++) {
          const property = properties[i];
          if (sourceCtx[property] !== undefined) {
            destCtx[property] = sourceCtx[property];
          }
        }
        if (sourceCtx.setLineDash !== undefined) {
          destCtx.setLineDash(sourceCtx.getLineDash());
          destCtx.lineDashOffset = sourceCtx.lineDashOffset;
        }
      }
      function resetCtxToDefault(ctx, foregroundColor) {
        ctx.strokeStyle = ctx.fillStyle = foregroundColor || "#000000";
        ctx.fillRule = "nonzero";
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
        ctx.lineCap = "butt";
        ctx.lineJoin = "miter";
        ctx.miterLimit = 10;
        ctx.globalCompositeOperation = "source-over";
        ctx.font = "10px sans-serif";
        if (ctx.setLineDash !== undefined) {
          ctx.setLineDash([]);
          ctx.lineDashOffset = 0;
        }
      }
      function composeSMaskBackdrop(bytes, r0, g0, b0) {
        const length = bytes.length;
        for (let i = 3; i < length; i += 4) {
          const alpha = bytes[i];
          if (alpha === 0) {
            bytes[i - 3] = r0;
            bytes[i - 2] = g0;
            bytes[i - 1] = b0;
          } else if (alpha < 255) {
            const alpha_ = 255 - alpha;
            bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
            bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
            bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
          }
        }
      }
      function composeSMaskAlpha(maskData, layerData, transferMap) {
        const length = maskData.length;
        const scale = 1 / 255;
        for (let i = 3; i < length; i += 4) {
          const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
          layerData[i] = layerData[i] * alpha * scale | 0;
        }
      }
      function composeSMaskLuminosity(maskData, layerData, transferMap) {
        const length = maskData.length;
        for (let i = 3; i < length; i += 4) {
          const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
          layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
        }
      }
      function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
        const hasBackdrop = !!backdrop;
        const r0 = hasBackdrop ? backdrop[0] : 0;
        const g0 = hasBackdrop ? backdrop[1] : 0;
        const b0 = hasBackdrop ? backdrop[2] : 0;
        let composeFn;
        if (subtype === "Luminosity") {
          composeFn = composeSMaskLuminosity;
        } else {
          composeFn = composeSMaskAlpha;
        }
        const PIXELS_TO_PROCESS = 1048576;
        const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
        for (let row = 0; row < height; row += chunkSize) {
          const chunkHeight = Math.min(chunkSize, height - row);
          const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
          const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);
          if (hasBackdrop) {
            composeSMaskBackdrop(maskData.data, r0, g0, b0);
          }
          composeFn(maskData.data, layerData.data, transferMap);
          layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
        }
      }
      function composeSMask(ctx, smask, layerCtx, layerBox) {
        const layerOffsetX = layerBox[0];
        const layerOffsetY = layerBox[1];
        const layerWidth = layerBox[2] - layerOffsetX;
        const layerHeight = layerBox[3] - layerOffsetY;
        if (layerWidth === 0 || layerHeight === 0) {
          return;
        }
        genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(layerCtx.canvas, 0, 0);
        ctx.restore();
      }
      function getImageSmoothingEnabled(transform, interpolate) {
        const scale = _util.Util.singularValueDecompose2dScale(transform);
        scale[0] = Math.fround(scale[0]);
        scale[1] = Math.fround(scale[1]);
        const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);
        if (interpolate !== undefined) {
          return interpolate;
        } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
          return true;
        }
        return false;
      }
      const LINE_CAP_STYLES = ["butt", "round", "square"];
      const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
      const NORMAL_CLIP = {};
      const EO_CLIP = {};
      class CanvasGraphics {
        constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {
          this.ctx = canvasCtx;
          this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
          this.stateStack = [];
          this.pendingClip = null;
          this.pendingEOFill = false;
          this.res = null;
          this.xobjs = null;
          this.commonObjs = commonObjs;
          this.objs = objs;
          this.canvasFactory = canvasFactory;
          this.imageLayer = imageLayer;
          this.groupStack = [];
          this.processingType3 = null;
          this.baseTransform = null;
          this.baseTransformStack = [];
          this.groupLevel = 0;
          this.smaskStack = [];
          this.smaskCounter = 0;
          this.tempSMask = null;
          this.suspendedCtx = null;
          this.contentVisible = true;
          this.markedContentStack = [];
          this.optionalContentConfig = optionalContentConfig;
          this.cachedCanvases = new CachedCanvases(this.canvasFactory);
          this.cachedPatterns = new Map();
          this.annotationCanvasMap = annotationCanvasMap;
          this.viewportScale = 1;
          this.outputScaleX = 1;
          this.outputScaleY = 1;
          this.backgroundColor = (pageColors === null || pageColors === void 0 ? void 0 : pageColors.background) || null;
          this.foregroundColor = (pageColors === null || pageColors === void 0 ? void 0 : pageColors.foreground) || null;
          if (canvasCtx) {
            addContextCurrentTransform(canvasCtx);
          }
          this._cachedScaleForStroking = null;
          this._cachedGetSinglePixelWidth = null;
          this._cachedBitmapsMap = new Map();
        }
        getObject(data, fallback = null) {
          if (typeof data === "string") {
            return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
          }
          return fallback;
        }
        beginDrawing({
          transform,
          viewport,
          transparency = false,
          background = null
        }) {
          const width = this.ctx.canvas.width;
          const height = this.ctx.canvas.height;
          const defaultBackgroundColor = background || "#ffffff";
          this.ctx.save();
          if (this.foregroundColor && this.backgroundColor) {
            this.ctx.fillStyle = this.foregroundColor;
            const fg = this.foregroundColor = this.ctx.fillStyle;
            this.ctx.fillStyle = this.backgroundColor;
            const bg = this.backgroundColor = this.ctx.fillStyle;
            let isValidDefaultBg = true;
            let defaultBg = defaultBackgroundColor;
            this.ctx.fillStyle = defaultBackgroundColor;
            defaultBg = this.ctx.fillStyle;
            isValidDefaultBg = typeof defaultBg === "string" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);
            if (fg === "#000000" && bg === "#ffffff" || fg === bg || !isValidDefaultBg) {
              this.foregroundColor = this.backgroundColor = null;
            } else {
              const cB = parseInt(defaultBg.slice(1), 16);
              const rB = (cB && 0xff0000) >> 16;
              const gB = (cB && 0x00ff00) >> 8;
              const bB = cB && 0x0000ff;
              const newComp = x => {
                x /= 255;
                return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
              };
              const lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));
              this.selectColor = (r, g, b) => {
                const lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b);
                return Math.round(lumC) === lumB ? bg : fg;
              };
            }
          }
          this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;
          this.ctx.fillRect(0, 0, width, height);
          this.ctx.restore();
          if (transparency) {
            const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
            this.compositeCtx = this.ctx;
            this.transparentCanvas = transparentCanvas.canvas;
            this.ctx = transparentCanvas.context;
            this.ctx.save();
            this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
          }
          this.ctx.save();
          resetCtxToDefault(this.ctx, this.foregroundColor);
          if (transform) {
            this.ctx.transform.apply(this.ctx, transform);
            this.outputScaleX = transform[0];
            this.outputScaleY = transform[0];
          }
          this.ctx.transform.apply(this.ctx, viewport.transform);
          this.viewportScale = viewport.scale;
          this.baseTransform = this.ctx.mozCurrentTransform.slice();
          if (this.imageLayer) {
            this.imageLayer.beginLayout();
          }
        }
        executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
          const argsArray = operatorList.argsArray;
          const fnArray = operatorList.fnArray;
          let i = executionStartIdx || 0;
          const argsArrayLen = argsArray.length;
          if (argsArrayLen === i) {
            return i;
          }
          const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
          const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
          let steps = 0;
          const commonObjs = this.commonObjs;
          const objs = this.objs;
          let fnId;
          while (true) {
            if (stepper !== undefined && i === stepper.nextBreakPoint) {
              stepper.breakIt(i, continueCallback);
              return i;
            }
            fnId = fnArray[i];
            if (fnId !== _util.OPS.dependency) {
              this[fnId].apply(this, argsArray[i]);
            } else {
              for (const depObjId of argsArray[i]) {
                const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                if (!objsPool.has(depObjId)) {
                  objsPool.get(depObjId, continueCallback);
                  return i;
                }
              }
            }
            i++;
            if (i === argsArrayLen) {
              return i;
            }
            if (chunkOperations && ++steps > EXECUTION_STEPS) {
              if (Date.now() > endTime) {
                continueCallback();
                return i;
              }
              steps = 0;
            }
          }
        }
        endDrawing() {
          while (this.stateStack.length || this.inSMaskMode) {
            this.restore();
          }
          this.ctx.restore();
          if (this.transparentCanvas) {
            this.ctx = this.compositeCtx;
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.drawImage(this.transparentCanvas, 0, 0);
            this.ctx.restore();
            this.transparentCanvas = null;
          }
          this.cachedCanvases.clear();
          this.cachedPatterns.clear();
          for (const cache of this._cachedBitmapsMap.values()) {
            for (const canvas of cache.values()) {
              if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                canvas.width = canvas.height = 0;
              }
            }
            cache.clear();
          }
          this._cachedBitmapsMap.clear();
          if (this.imageLayer) {
            this.imageLayer.endLayout();
          }
        }
        _scaleImage(img, inverseTransform) {
          const width = img.width;
          const height = img.height;
          let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
          let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
          let paintWidth = width,
            paintHeight = height;
          let tmpCanvasId = "prescale1";
          let tmpCanvas, tmpCtx;
          while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
            let newWidth = paintWidth,
              newHeight = paintHeight;
            if (widthScale > 2 && paintWidth > 1) {
              newWidth = Math.ceil(paintWidth / 2);
              widthScale /= paintWidth / newWidth;
            }
            if (heightScale > 2 && paintHeight > 1) {
              newHeight = Math.ceil(paintHeight / 2);
              heightScale /= paintHeight / newHeight;
            }
            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight, false);
            tmpCtx = tmpCanvas.context;
            tmpCtx.clearRect(0, 0, newWidth, newHeight);
            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
            img = tmpCanvas.canvas;
            paintWidth = newWidth;
            paintHeight = newHeight;
            tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
          }
          return {
            img,
            paintWidth,
            paintHeight
          };
        }
        _createMaskCanvas(img) {
          const ctx = this.ctx;
          const {
            width,
            height
          } = img;
          const fillColor = this.current.fillColor;
          const isPatternFill = this.current.patternFill;
          const currentTransform = ctx.mozCurrentTransform;
          let cache, cacheKey, scaled, maskCanvas;
          if ((img.bitmap || img.data) && img.count > 1) {
            const mainKey = img.bitmap || img.data.buffer;
            const withoutTranslation = currentTransform.slice(0, 4);
            cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);
            cache = this._cachedBitmapsMap.get(mainKey);
            if (!cache) {
              cache = new Map();
              this._cachedBitmapsMap.set(mainKey, cache);
            }
            const cachedImage = cache.get(cacheKey);
            if (cachedImage && !isPatternFill) {
              const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
              const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
              return {
                canvas: cachedImage,
                offsetX,
                offsetY
              };
            }
            scaled = cachedImage;
          }
          if (!scaled) {
            maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height, false);
            putBinaryImageMask(maskCanvas.context, img);
          }
          let maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
          maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
          const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);
          const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);
          const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
          const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
          const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
          const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight, true);
          const fillCtx = fillCanvas.context;
          const offsetX = Math.min(cord1[0], cord2[0]);
          const offsetY = Math.min(cord1[1], cord2[1]);
          fillCtx.translate(-offsetX, -offsetY);
          fillCtx.transform.apply(fillCtx, maskToCanvas);
          if (!scaled) {
            scaled = this._scaleImage(maskCanvas.canvas, fillCtx.mozCurrentTransformInverse);
            scaled = scaled.img;
            if (cache && isPatternFill) {
              cache.set(cacheKey, scaled);
            }
          }
          fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(fillCtx.mozCurrentTransform, img.interpolate);
          drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
          fillCtx.globalCompositeOperation = "source-in";
          const inverse = _util.Util.transform(fillCtx.mozCurrentTransformInverse, [1, 0, 0, 1, -offsetX, -offsetY]);
          fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
          fillCtx.fillRect(0, 0, width, height);
          if (cache && !isPatternFill) {
            this.cachedCanvases.delete("fillCanvas");
            cache.set(cacheKey, fillCanvas.canvas);
          }
          return {
            canvas: fillCanvas.canvas,
            offsetX: Math.round(offsetX),
            offsetY: Math.round(offsetY)
          };
        }
        setLineWidth(width) {
          if (width !== this.current.lineWidth) {
            this._cachedScaleForStroking = null;
          }
          this.current.lineWidth = width;
          this.ctx.lineWidth = width;
        }
        setLineCap(style) {
          this.ctx.lineCap = LINE_CAP_STYLES[style];
        }
        setLineJoin(style) {
          this.ctx.lineJoin = LINE_JOIN_STYLES[style];
        }
        setMiterLimit(limit) {
          this.ctx.miterLimit = limit;
        }
        setDash(dashArray, dashPhase) {
          const ctx = this.ctx;
          if (ctx.setLineDash !== undefined) {
            ctx.setLineDash(dashArray);
            ctx.lineDashOffset = dashPhase;
          }
        }
        setRenderingIntent(intent) {}
        setFlatness(flatness) {}
        setGState(states) {
          for (let i = 0, ii = states.length; i < ii; i++) {
            const state = states[i];
            const key = state[0];
            const value = state[1];
            switch (key) {
              case "LW":
                this.setLineWidth(value);
                break;
              case "LC":
                this.setLineCap(value);
                break;
              case "LJ":
                this.setLineJoin(value);
                break;
              case "ML":
                this.setMiterLimit(value);
                break;
              case "D":
                this.setDash(value[0], value[1]);
                break;
              case "RI":
                this.setRenderingIntent(value);
                break;
              case "FL":
                this.setFlatness(value);
                break;
              case "Font":
                this.setFont(value[0], value[1]);
                break;
              case "CA":
                this.current.strokeAlpha = state[1];
                break;
              case "ca":
                this.current.fillAlpha = state[1];
                this.ctx.globalAlpha = state[1];
                break;
              case "BM":
                this.ctx.globalCompositeOperation = value;
                break;
              case "SMask":
                this.current.activeSMask = value ? this.tempSMask : null;
                this.tempSMask = null;
                this.checkSMaskState();
                break;
              case "TR":
                this.current.transferMaps = value;
            }
          }
        }
        get inSMaskMode() {
          return !!this.suspendedCtx;
        }
        checkSMaskState() {
          const inSMaskMode = this.inSMaskMode;
          if (this.current.activeSMask && !inSMaskMode) {
            this.beginSMaskMode();
          } else if (!this.current.activeSMask && inSMaskMode) {
            this.endSMaskMode();
          }
        }
        beginSMaskMode() {
          if (this.inSMaskMode) {
            throw new Error("beginSMaskMode called while already in smask mode");
          }
          const drawnWidth = this.ctx.canvas.width;
          const drawnHeight = this.ctx.canvas.height;
          const cacheId = "smaskGroupAt" + this.groupLevel;
          const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
          this.suspendedCtx = this.ctx;
          this.ctx = scratchCanvas.context;
          const ctx = this.ctx;
          ctx.setTransform.apply(ctx, this.suspendedCtx.mozCurrentTransform);
          copyCtxState(this.suspendedCtx, ctx);
          mirrorContextOperations(ctx, this.suspendedCtx);
          this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
        }
        endSMaskMode() {
          if (!this.inSMaskMode) {
            throw new Error("endSMaskMode called while not in smask mode");
          }
          this.ctx._removeMirroring();
          copyCtxState(this.ctx, this.suspendedCtx);
          this.ctx = this.suspendedCtx;
          this.suspendedCtx = null;
        }
        compose(dirtyBox) {
          if (!this.current.activeSMask) {
            return;
          }
          if (!dirtyBox) {
            dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
          } else {
            dirtyBox[0] = Math.floor(dirtyBox[0]);
            dirtyBox[1] = Math.floor(dirtyBox[1]);
            dirtyBox[2] = Math.ceil(dirtyBox[2]);
            dirtyBox[3] = Math.ceil(dirtyBox[3]);
          }
          const smask = this.current.activeSMask;
          const suspendedCtx = this.suspendedCtx;
          composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
          this.ctx.save();
          this.ctx.setTransform(1, 0, 0, 1, 0, 0);
          this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
          this.ctx.restore();
        }
        save() {
          if (this.inSMaskMode) {
            copyCtxState(this.ctx, this.suspendedCtx);
            this.suspendedCtx.save();
          } else {
            this.ctx.save();
          }
          const old = this.current;
          this.stateStack.push(old);
          this.current = old.clone();
        }
        restore() {
          if (this.stateStack.length === 0 && this.inSMaskMode) {
            this.endSMaskMode();
          }
          if (this.stateStack.length !== 0) {
            this.current = this.stateStack.pop();
            if (this.inSMaskMode) {
              this.suspendedCtx.restore();
              copyCtxState(this.suspendedCtx, this.ctx);
            } else {
              this.ctx.restore();
            }
            this.checkSMaskState();
            this.pendingClip = null;
            this._cachedScaleForStroking = null;
            this._cachedGetSinglePixelWidth = null;
          }
        }
        transform(a, b, c, d, e, f) {
          this.ctx.transform(a, b, c, d, e, f);
          this._cachedScaleForStroking = null;
          this._cachedGetSinglePixelWidth = null;
        }
        constructPath(ops, args, minMax) {
          const ctx = this.ctx;
          const current = this.current;
          let x = current.x,
            y = current.y;
          let startX, startY;
          const currentTransform = ctx.mozCurrentTransform;
          const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
          const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
          for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
            switch (ops[i] | 0) {
              case _util.OPS.rectangle:
                x = args[j++];
                y = args[j++];
                const width = args[j++];
                const height = args[j++];
                const xw = x + width;
                const yh = y + height;
                ctx.moveTo(x, y);
                if (width === 0 || height === 0) {
                  ctx.lineTo(xw, yh);
                } else {
                  ctx.lineTo(xw, y);
                  ctx.lineTo(xw, yh);
                  ctx.lineTo(x, yh);
                }
                if (!isScalingMatrix) {
                  current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
                }
                ctx.closePath();
                break;
              case _util.OPS.moveTo:
                x = args[j++];
                y = args[j++];
                ctx.moveTo(x, y);
                if (!isScalingMatrix) {
                  current.updatePathMinMax(currentTransform, x, y);
                }
                break;
              case _util.OPS.lineTo:
                x = args[j++];
                y = args[j++];
                ctx.lineTo(x, y);
                if (!isScalingMatrix) {
                  current.updatePathMinMax(currentTransform, x, y);
                }
                break;
              case _util.OPS.curveTo:
                startX = x;
                startY = y;
                x = args[j + 4];
                y = args[j + 5];
                ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
                j += 6;
                break;
              case _util.OPS.curveTo2:
                startX = x;
                startY = y;
                ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
                x = args[j + 2];
                y = args[j + 3];
                j += 4;
                break;
              case _util.OPS.curveTo3:
                startX = x;
                startY = y;
                x = args[j + 2];
                y = args[j + 3];
                ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
                j += 4;
                break;
              case _util.OPS.closePath:
                ctx.closePath();
                break;
            }
          }
          if (isScalingMatrix) {
            current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
          }
          current.setCurrentPoint(x, y);
        }
        closePath() {
          this.ctx.closePath();
        }
        stroke(consumePath) {
          consumePath = typeof consumePath !== "undefined" ? consumePath : true;
          const ctx = this.ctx;
          const strokeColor = this.current.strokeColor;
          ctx.globalAlpha = this.current.strokeAlpha;
          if (this.contentVisible) {
            if (typeof strokeColor === "object" && strokeColor !== null && strokeColor !== void 0 && strokeColor.getPattern) {
              ctx.save();
              ctx.strokeStyle = strokeColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.STROKE);
              this.rescaleAndStroke(false);
              ctx.restore();
            } else {
              this.rescaleAndStroke(true);
            }
          }
          if (consumePath) {
            this.consumePath(this.current.getClippedPathBoundingBox());
          }
          ctx.globalAlpha = this.current.fillAlpha;
        }
        closeStroke() {
          this.closePath();
          this.stroke();
        }
        fill(consumePath) {
          consumePath = typeof consumePath !== "undefined" ? consumePath : true;
          const ctx = this.ctx;
          const fillColor = this.current.fillColor;
          const isPatternFill = this.current.patternFill;
          let needRestore = false;
          if (isPatternFill) {
            ctx.save();
            ctx.fillStyle = fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
            needRestore = true;
          }
          const intersect = this.current.getClippedPathBoundingBox();
          if (this.contentVisible && intersect !== null) {
            if (this.pendingEOFill) {
              ctx.fill("evenodd");
              this.pendingEOFill = false;
            } else {
              ctx.fill();
            }
          }
          if (needRestore) {
            ctx.restore();
          }
          if (consumePath) {
            this.consumePath(intersect);
          }
        }
        eoFill() {
          this.pendingEOFill = true;
          this.fill();
        }
        fillStroke() {
          this.fill(false);
          this.stroke(false);
          this.consumePath();
        }
        eoFillStroke() {
          this.pendingEOFill = true;
          this.fillStroke();
        }
        closeFillStroke() {
          this.closePath();
          this.fillStroke();
        }
        closeEOFillStroke() {
          this.pendingEOFill = true;
          this.closePath();
          this.fillStroke();
        }
        endPath() {
          this.consumePath();
        }
        clip() {
          this.pendingClip = NORMAL_CLIP;
        }
        eoClip() {
          this.pendingClip = EO_CLIP;
        }
        beginText() {
          this.current.textMatrix = _util.IDENTITY_MATRIX;
          this.current.textMatrixScale = 1;
          this.current.x = this.current.lineX = 0;
          this.current.y = this.current.lineY = 0;
        }
        endText() {
          const paths = this.pendingTextPaths;
          const ctx = this.ctx;
          if (paths === undefined) {
            ctx.beginPath();
            return;
          }
          ctx.save();
          ctx.beginPath();
          for (let i = 0; i < paths.length; i++) {
            const path = paths[i];
            ctx.setTransform.apply(ctx, path.transform);
            ctx.translate(path.x, path.y);
            path.addToPath(ctx, path.fontSize);
          }
          ctx.restore();
          ctx.clip();
          ctx.beginPath();
          delete this.pendingTextPaths;
        }
        setCharSpacing(spacing) {
          this.current.charSpacing = spacing;
        }
        setWordSpacing(spacing) {
          this.current.wordSpacing = spacing;
        }
        setHScale(scale) {
          this.current.textHScale = scale / 100;
        }
        setLeading(leading) {
          this.current.leading = -leading;
        }
        setFont(fontRefName, size) {
          const fontObj = this.commonObjs.get(fontRefName);
          const current = this.current;
          if (!fontObj) {
            throw new Error(`Can't find font for ${fontRefName}`);
          }
          current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
          if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
            (0, _util.warn)("Invalid font matrix for font " + fontRefName);
          }
          if (size < 0) {
            size = -size;
            current.fontDirection = -1;
          } else {
            current.fontDirection = 1;
          }
          this.current.font = fontObj;
          this.current.fontSize = size;
          if (fontObj.isType3Font) {
            return;
          }
          const name = fontObj.loadedName || "sans-serif";
          let bold = "normal";
          if (fontObj.black) {
            bold = "900";
          } else if (fontObj.bold) {
            bold = "bold";
          }
          const italic = fontObj.italic ? "italic" : "normal";
          const typeface = `"${name}", ${fontObj.fallbackName}`;
          let browserFontSize = size;
          if (size < MIN_FONT_SIZE) {
            browserFontSize = MIN_FONT_SIZE;
          } else if (size > MAX_FONT_SIZE) {
            browserFontSize = MAX_FONT_SIZE;
          }
          this.current.fontSizeScale = size / browserFontSize;
          this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
        }
        setTextRenderingMode(mode) {
          this.current.textRenderingMode = mode;
        }
        setTextRise(rise) {
          this.current.textRise = rise;
        }
        moveText(x, y) {
          this.current.x = this.current.lineX += x;
          this.current.y = this.current.lineY += y;
        }
        setLeadingMoveText(x, y) {
          this.setLeading(-y);
          this.moveText(x, y);
        }
        setTextMatrix(a, b, c, d, e, f) {
          this.current.textMatrix = [a, b, c, d, e, f];
          this.current.textMatrixScale = Math.hypot(a, b);
          this.current.x = this.current.lineX = 0;
          this.current.y = this.current.lineY = 0;
        }
        nextLine() {
          this.moveText(0, this.current.leading);
        }
        paintChar(character, x, y, patternTransform) {
          const ctx = this.ctx;
          const current = this.current;
          const font = current.font;
          const textRenderingMode = current.textRenderingMode;
          const fontSize = current.fontSize / current.fontSizeScale;
          const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
          const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
          const patternFill = current.patternFill && !font.missingFile;
          let addToPath;
          if (font.disableFontFace || isAddToPathSet || patternFill) {
            addToPath = font.getPathGenerator(this.commonObjs, character);
          }
          if (font.disableFontFace || patternFill) {
            ctx.save();
            ctx.translate(x, y);
            ctx.beginPath();
            addToPath(ctx, fontSize);
            if (patternTransform) {
              ctx.setTransform.apply(ctx, patternTransform);
            }
            if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
              ctx.fill();
            }
            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
              ctx.stroke();
            }
            ctx.restore();
          } else {
            if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
              ctx.fillText(character, x, y);
            }
            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
              ctx.strokeText(character, x, y);
            }
          }
          if (isAddToPathSet) {
            const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
            paths.push({
              transform: ctx.mozCurrentTransform,
              x,
              y,
              fontSize,
              addToPath
            });
          }
        }
        get isFontSubpixelAAEnabled() {
          const {
            context: ctx
          } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10, false);
          ctx.scale(1.5, 1);
          ctx.fillText("I", 0, 10);
          const data = ctx.getImageData(0, 0, 10, 10).data;
          let enabled = false;
          for (let i = 3; i < data.length; i += 4) {
            if (data[i] > 0 && data[i] < 255) {
              enabled = true;
              break;
            }
          }
          return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
        }
        showText(glyphs) {
          const current = this.current;
          const font = current.font;
          if (font.isType3Font) {
            return this.showType3Text(glyphs);
          }
          const fontSize = current.fontSize;
          if (fontSize === 0) {
            return undefined;
          }
          const ctx = this.ctx;
          const fontSizeScale = current.fontSizeScale;
          const charSpacing = current.charSpacing;
          const wordSpacing = current.wordSpacing;
          const fontDirection = current.fontDirection;
          const textHScale = current.textHScale * fontDirection;
          const glyphsLength = glyphs.length;
          const vertical = font.vertical;
          const spacingDir = vertical ? 1 : -1;
          const defaultVMetrics = font.defaultVMetrics;
          const widthAdvanceScale = fontSize * current.fontMatrix[0];
          const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
          ctx.save();
          ctx.transform.apply(ctx, current.textMatrix);
          ctx.translate(current.x, current.y + current.textRise);
          if (fontDirection > 0) {
            ctx.scale(textHScale, -1);
          } else {
            ctx.scale(textHScale, 1);
          }
          let patternTransform;
          if (current.patternFill) {
            ctx.save();
            const pattern = current.fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);
            patternTransform = ctx.mozCurrentTransform;
            ctx.restore();
            ctx.fillStyle = pattern;
          }
          let lineWidth = current.lineWidth;
          const scale = current.textMatrixScale;
          if (scale === 0 || lineWidth === 0) {
            const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
              lineWidth = this.getSinglePixelWidth();
            }
          } else {
            lineWidth /= scale;
          }
          if (fontSizeScale !== 1.0) {
            ctx.scale(fontSizeScale, fontSizeScale);
            lineWidth /= fontSizeScale;
          }
          ctx.lineWidth = lineWidth;
          let x = 0,
            i;
          for (i = 0; i < glyphsLength; ++i) {
            const glyph = glyphs[i];
            if (typeof glyph === "number") {
              x += spacingDir * glyph * fontSize / 1000;
              continue;
            }
            let restoreNeeded = false;
            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
            const character = glyph.fontChar;
            const accent = glyph.accent;
            let scaledX, scaledY;
            let width = glyph.width;
            if (vertical) {
              const vmetric = glyph.vmetric || defaultVMetrics;
              const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
              const vy = vmetric[2] * widthAdvanceScale;
              width = vmetric ? -vmetric[0] : width;
              scaledX = vx / fontSizeScale;
              scaledY = (x + vy) / fontSizeScale;
            } else {
              scaledX = x / fontSizeScale;
              scaledY = 0;
            }
            if (font.remeasure && width > 0) {
              const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;
              if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                const characterScaleX = width / measuredWidth;
                restoreNeeded = true;
                ctx.save();
                ctx.scale(characterScaleX, 1);
                scaledX /= characterScaleX;
              } else if (width !== measuredWidth) {
                scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
              }
            }
            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
              if (simpleFillText && !accent) {
                ctx.fillText(character, scaledX, scaledY);
              } else {
                this.paintChar(character, scaledX, scaledY, patternTransform);
                if (accent) {
                  const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                  const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                  this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                }
              }
            }
            let charWidth;
            if (vertical) {
              charWidth = width * widthAdvanceScale - spacing * fontDirection;
            } else {
              charWidth = width * widthAdvanceScale + spacing * fontDirection;
            }
            x += charWidth;
            if (restoreNeeded) {
              ctx.restore();
            }
          }
          if (vertical) {
            current.y -= x;
          } else {
            current.x += x * textHScale;
          }
          ctx.restore();
          this.compose();
          return undefined;
        }
        showType3Text(glyphs) {
          const ctx = this.ctx;
          const current = this.current;
          const font = current.font;
          const fontSize = current.fontSize;
          const fontDirection = current.fontDirection;
          const spacingDir = font.vertical ? 1 : -1;
          const charSpacing = current.charSpacing;
          const wordSpacing = current.wordSpacing;
          const textHScale = current.textHScale * fontDirection;
          const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
          const glyphsLength = glyphs.length;
          const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
          let i, glyph, width, spacingLength;
          if (isTextInvisible || fontSize === 0) {
            return;
          }
          this._cachedScaleForStroking = null;
          this._cachedGetSinglePixelWidth = null;
          ctx.save();
          ctx.transform.apply(ctx, current.textMatrix);
          ctx.translate(current.x, current.y);
          ctx.scale(textHScale, fontDirection);
          for (i = 0; i < glyphsLength; ++i) {
            glyph = glyphs[i];
            if (typeof glyph === "number") {
              spacingLength = spacingDir * glyph * fontSize / 1000;
              this.ctx.translate(spacingLength, 0);
              current.x += spacingLength * textHScale;
              continue;
            }
            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
            const operatorList = font.charProcOperatorList[glyph.operatorListId];
            if (!operatorList) {
              (0, _util.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
              continue;
            }
            if (this.contentVisible) {
              this.processingType3 = glyph;
              this.save();
              ctx.scale(fontSize, fontSize);
              ctx.transform.apply(ctx, fontMatrix);
              this.executeOperatorList(operatorList);
              this.restore();
            }
            const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);
            width = transformed[0] * fontSize + spacing;
            ctx.translate(width, 0);
            current.x += width * textHScale;
          }
          ctx.restore();
          this.processingType3 = null;
        }
        setCharWidth(xWidth, yWidth) {}
        setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
          this.ctx.rect(llx, lly, urx - llx, ury - lly);
          this.ctx.clip();
          this.endPath();
        }
        getColorN_Pattern(IR) {
          let pattern;
          if (IR[0] === "TilingPattern") {
            const color = IR[1];
            const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
            const canvasGraphicsFactory = {
              createCanvasGraphics: ctx => {
                return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);
              }
            };
            pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
          } else {
            pattern = this._getPattern(IR[1], IR[2]);
          }
          return pattern;
        }
        setStrokeColorN() {
          this.current.strokeColor = this.getColorN_Pattern(arguments);
        }
        setFillColorN() {
          this.current.fillColor = this.getColorN_Pattern(arguments);
          this.current.patternFill = true;
        }
        setStrokeRGBColor(r, g, b) {
          var _this$selectColor;
          const color = ((_this$selectColor = this.selectColor) === null || _this$selectColor === void 0 ? void 0 : _this$selectColor.call(this, r, g, b)) || _util.Util.makeHexColor(r, g, b);
          this.ctx.strokeStyle = color;
          this.current.strokeColor = color;
        }
        setFillRGBColor(r, g, b) {
          var _this$selectColor2;
          const color = ((_this$selectColor2 = this.selectColor) === null || _this$selectColor2 === void 0 ? void 0 : _this$selectColor2.call(this, r, g, b)) || _util.Util.makeHexColor(r, g, b);
          this.ctx.fillStyle = color;
          this.current.fillColor = color;
          this.current.patternFill = false;
        }
        _getPattern(objId, matrix = null) {
          let pattern;
          if (this.cachedPatterns.has(objId)) {
            pattern = this.cachedPatterns.get(objId);
          } else {
            pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
            this.cachedPatterns.set(objId, pattern);
          }
          if (matrix) {
            pattern.matrix = matrix;
          }
          return pattern;
        }
        shadingFill(objId) {
          if (!this.contentVisible) {
            return;
          }
          const ctx = this.ctx;
          this.save();
          const pattern = this._getPattern(objId);
          ctx.fillStyle = pattern.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.SHADING);
          const inv = ctx.mozCurrentTransformInverse;
          if (inv) {
            const canvas = ctx.canvas;
            const width = canvas.width;
            const height = canvas.height;
            const bl = _util.Util.applyTransform([0, 0], inv);
            const br = _util.Util.applyTransform([0, height], inv);
            const ul = _util.Util.applyTransform([width, 0], inv);
            const ur = _util.Util.applyTransform([width, height], inv);
            const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
            const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
            const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
            const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
          } else {
            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
          }
          this.compose(this.current.getClippedPathBoundingBox());
          this.restore();
        }
        beginInlineImage() {
          (0, _util.unreachable)("Should not call beginInlineImage");
        }
        beginImageData() {
          (0, _util.unreachable)("Should not call beginImageData");
        }
        paintFormXObjectBegin(matrix, bbox) {
          if (!this.contentVisible) {
            return;
          }
          this.save();
          this.baseTransformStack.push(this.baseTransform);
          if (Array.isArray(matrix) && matrix.length === 6) {
            this.transform.apply(this, matrix);
          }
          this.baseTransform = this.ctx.mozCurrentTransform;
          if (bbox) {
            const width = bbox[2] - bbox[0];
            const height = bbox[3] - bbox[1];
            this.ctx.rect(bbox[0], bbox[1], width, height);
            this.current.updateRectMinMax(this.ctx.mozCurrentTransform, bbox);
            this.clip();
            this.endPath();
          }
        }
        paintFormXObjectEnd() {
          if (!this.contentVisible) {
            return;
          }
          this.restore();
          this.baseTransform = this.baseTransformStack.pop();
        }
        beginGroup(group) {
          if (!this.contentVisible) {
            return;
          }
          this.save();
          if (this.inSMaskMode) {
            this.endSMaskMode();
            this.current.activeSMask = null;
          }
          const currentCtx = this.ctx;
          if (!group.isolated) {
            (0, _util.info)("TODO: Support non-isolated groups.");
          }
          if (group.knockout) {
            (0, _util.warn)("Knockout groups not supported.");
          }
          const currentTransform = currentCtx.mozCurrentTransform;
          if (group.matrix) {
            currentCtx.transform.apply(currentCtx, group.matrix);
          }
          if (!group.bbox) {
            throw new Error("Bounding box is required.");
          }
          let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);
          const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
          bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
          const offsetX = Math.floor(bounds[0]);
          const offsetY = Math.floor(bounds[1]);
          let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
          let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
          let scaleX = 1,
            scaleY = 1;
          if (drawnWidth > MAX_GROUP_SIZE) {
            scaleX = drawnWidth / MAX_GROUP_SIZE;
            drawnWidth = MAX_GROUP_SIZE;
          }
          if (drawnHeight > MAX_GROUP_SIZE) {
            scaleY = drawnHeight / MAX_GROUP_SIZE;
            drawnHeight = MAX_GROUP_SIZE;
          }
          this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
          let cacheId = "groupAt" + this.groupLevel;
          if (group.smask) {
            cacheId += "_smask_" + this.smaskCounter++ % 2;
          }
          const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
          const groupCtx = scratchCanvas.context;
          groupCtx.scale(1 / scaleX, 1 / scaleY);
          groupCtx.translate(-offsetX, -offsetY);
          groupCtx.transform.apply(groupCtx, currentTransform);
          if (group.smask) {
            this.smaskStack.push({
              canvas: scratchCanvas.canvas,
              context: groupCtx,
              offsetX,
              offsetY,
              scaleX,
              scaleY,
              subtype: group.smask.subtype,
              backdrop: group.smask.backdrop,
              transferMap: group.smask.transferMap || null,
              startTransformInverse: null
            });
          } else {
            currentCtx.setTransform(1, 0, 0, 1, 0, 0);
            currentCtx.translate(offsetX, offsetY);
            currentCtx.scale(scaleX, scaleY);
            currentCtx.save();
          }
          copyCtxState(currentCtx, groupCtx);
          this.ctx = groupCtx;
          this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
          this.groupStack.push(currentCtx);
          this.groupLevel++;
        }
        endGroup(group) {
          if (!this.contentVisible) {
            return;
          }
          this.groupLevel--;
          const groupCtx = this.ctx;
          const ctx = this.groupStack.pop();
          this.ctx = ctx;
          this.ctx.imageSmoothingEnabled = false;
          if (group.smask) {
            this.tempSMask = this.smaskStack.pop();
            this.restore();
          } else {
            this.ctx.restore();
            const currentMtx = this.ctx.mozCurrentTransform;
            this.restore();
            this.ctx.save();
            this.ctx.setTransform.apply(this.ctx, currentMtx);
            const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
            this.ctx.drawImage(groupCtx.canvas, 0, 0);
            this.ctx.restore();
            this.compose(dirtyBox);
          }
        }
        beginAnnotations() {
          this.save();
          if (this.baseTransform) {
            this.ctx.setTransform.apply(this.ctx, this.baseTransform);
          }
        }
        endAnnotations() {
          this.restore();
        }
        beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
          this.save();
          if (Array.isArray(rect) && rect.length === 4) {
            const width = rect[2] - rect[0];
            const height = rect[3] - rect[1];
            if (hasOwnCanvas && this.annotationCanvasMap) {
              transform = transform.slice();
              transform[4] -= rect[0];
              transform[5] -= rect[1];
              rect = rect.slice();
              rect[0] = rect[1] = 0;
              rect[2] = width;
              rect[3] = height;
              const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(this.ctx.mozCurrentTransform);
              const {
                viewportScale
              } = this;
              const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
              const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
              this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
              const {
                canvas,
                context
              } = this.annotationCanvas;
              const viewportScaleFactorStr = `var(--zoom-factor) * ${_display_utils.PixelsPerInch.PDF_TO_CSS_UNITS}`;
              canvas.style.width = `calc(${width}px * ${viewportScaleFactorStr})`;
              canvas.style.height = `calc(${height}px * ${viewportScaleFactorStr})`;
              this.annotationCanvasMap.set(id, canvas);
              this.annotationCanvas.savedCtx = this.ctx;
              this.ctx = context;
              this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
              addContextCurrentTransform(this.ctx);
              resetCtxToDefault(this.ctx, this.foregroundColor);
            } else {
              resetCtxToDefault(this.ctx, this.foregroundColor);
              this.ctx.rect(rect[0], rect[1], width, height);
              this.ctx.clip();
              this.endPath();
            }
          }
          this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
          this.transform.apply(this, transform);
          this.transform.apply(this, matrix);
        }
        endAnnotation() {
          if (this.annotationCanvas) {
            this.ctx = this.annotationCanvas.savedCtx;
            delete this.annotationCanvas.savedCtx;
            delete this.annotationCanvas;
          }
          this.restore();
        }
        paintImageMaskXObject(img) {
          if (!this.contentVisible) {
            return;
          }
          const count = img.count;
          img = this.getObject(img.data, img);
          img.count = count;
          const ctx = this.ctx;
          const glyph = this.processingType3;
          if (glyph) {
            if (glyph.compiled === undefined) {
              glyph.compiled = compileType3Glyph(img);
            }
            if (glyph.compiled) {
              glyph.compiled(ctx);
              return;
            }
          }
          const mask = this._createMaskCanvas(img);
          const maskCanvas = mask.canvas;
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
          ctx.restore();
          this.compose();
        }
        paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
          if (!this.contentVisible) {
            return;
          }
          img = this.getObject(img.data, img);
          const ctx = this.ctx;
          ctx.save();
          const currentTransform = ctx.mozCurrentTransform;
          ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
          const mask = this._createMaskCanvas(img);
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          for (let i = 0, ii = positions.length; i < ii; i += 2) {
            const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
            const [x, y] = _util.Util.applyTransform([0, 0], trans);
            ctx.drawImage(mask.canvas, x, y);
          }
          ctx.restore();
          this.compose();
        }
        paintImageMaskXObjectGroup(images) {
          if (!this.contentVisible) {
            return;
          }
          const ctx = this.ctx;
          const fillColor = this.current.fillColor;
          const isPatternFill = this.current.patternFill;
          for (let i = 0, ii = images.length; i < ii; i++) {
            const image = images[i];
            const width = image.width,
              height = image.height;
            const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height, false);
            const maskCtx = maskCanvas.context;
            maskCtx.save();
            putBinaryImageMask(maskCtx, image);
            maskCtx.globalCompositeOperation = "source-in";
            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL) : fillColor;
            maskCtx.fillRect(0, 0, width, height);
            maskCtx.restore();
            ctx.save();
            ctx.transform.apply(ctx, image.transform);
            ctx.scale(1, -1);
            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
            ctx.restore();
          }
          this.compose();
        }
        paintImageXObject(objId) {
          if (!this.contentVisible) {
            return;
          }
          const imgData = this.getObject(objId);
          if (!imgData) {
            (0, _util.warn)("Dependent image isn't ready yet");
            return;
          }
          this.paintInlineImageXObject(imgData);
        }
        paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
          if (!this.contentVisible) {
            return;
          }
          const imgData = this.getObject(objId);
          if (!imgData) {
            (0, _util.warn)("Dependent image isn't ready yet");
            return;
          }
          const width = imgData.width;
          const height = imgData.height;
          const map = [];
          for (let i = 0, ii = positions.length; i < ii; i += 2) {
            map.push({
              transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
              x: 0,
              y: 0,
              w: width,
              h: height
            });
          }
          this.paintInlineImageXObjectGroup(imgData, map);
        }
        paintInlineImageXObject(imgData) {
          if (!this.contentVisible) {
            return;
          }
          const width = imgData.width;
          const height = imgData.height;
          const ctx = this.ctx;
          this.save();
          ctx.scale(1 / width, -1 / height);
          let imgToPaint;
          if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
            imgToPaint = imgData;
          } else {
            const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height, false);
            const tmpCtx = tmpCanvas.context;
            putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
            imgToPaint = tmpCanvas.canvas;
          }
          const scaled = this._scaleImage(imgToPaint, ctx.mozCurrentTransformInverse);
          ctx.imageSmoothingEnabled = getImageSmoothingEnabled(ctx.mozCurrentTransform, imgData.interpolate);
          const [rWidth, rHeight] = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
          if (this.imageLayer) {
            const position = this.getCanvasPosition(0, -height);
            this.imageLayer.appendImage({
              imgData,
              left: position[0],
              top: position[1],
              width: rWidth,
              height: rHeight
            });
          }
          this.compose();
          this.restore();
        }
        paintInlineImageXObjectGroup(imgData, map) {
          if (!this.contentVisible) {
            return;
          }
          const ctx = this.ctx;
          const w = imgData.width;
          const h = imgData.height;
          const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h, false);
          const tmpCtx = tmpCanvas.context;
          putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
          for (let i = 0, ii = map.length; i < ii; i++) {
            const entry = map[i];
            ctx.save();
            ctx.transform.apply(ctx, entry.transform);
            ctx.scale(1, -1);
            drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
            if (this.imageLayer) {
              const position = this.getCanvasPosition(entry.x, entry.y);
              this.imageLayer.appendImage({
                imgData,
                left: position[0],
                top: position[1],
                width: w,
                height: h
              });
            }
            ctx.restore();
          }
          this.compose();
        }
        paintSolidColorImageMask() {
          if (!this.contentVisible) {
            return;
          }
          this.ctx.fillRect(0, 0, 1, 1);
          this.compose();
        }
        markPoint(tag) {}
        markPointProps(tag, properties) {}
        beginMarkedContent(tag) {
          this.markedContentStack.push({
            visible: true
          });
        }
        beginMarkedContentProps(tag, properties) {
          if (tag === "OC") {
            this.markedContentStack.push({
              visible: this.optionalContentConfig.isVisible(properties)
            });
          } else {
            this.markedContentStack.push({
              visible: true
            });
          }
          this.contentVisible = this.isContentVisible();
        }
        endMarkedContent() {
          this.markedContentStack.pop();
          this.contentVisible = this.isContentVisible();
        }
        beginCompat() {}
        endCompat() {}
        consumePath(clipBox) {
          const isEmpty = this.current.isEmptyClip();
          if (this.pendingClip) {
            this.current.updateClipFromPath();
          }
          if (!this.pendingClip) {
            this.compose(clipBox);
          }
          const ctx = this.ctx;
          if (this.pendingClip) {
            if (!isEmpty) {
              if (this.pendingClip === EO_CLIP) {
                ctx.clip("evenodd");
              } else {
                ctx.clip();
              }
            }
            this.pendingClip = null;
          }
          this.current.startNewPathAndClipBox(this.current.clipBox);
          ctx.beginPath();
        }
        getSinglePixelWidth() {
          if (!this._cachedGetSinglePixelWidth) {
            const m = this.ctx.mozCurrentTransform;
            if (m[1] === 0 && m[2] === 0) {
              this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
            } else {
              const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
              const normX = Math.hypot(m[0], m[2]);
              const normY = Math.hypot(m[1], m[3]);
              this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
            }
          }
          return this._cachedGetSinglePixelWidth;
        }
        getScaleForStroking() {
          if (!this._cachedScaleForStroking) {
            const {
              lineWidth
            } = this.current;
            const m = this.ctx.mozCurrentTransform;
            let scaleX, scaleY;
            if (m[1] === 0 && m[2] === 0) {
              const normX = Math.abs(m[0]);
              const normY = Math.abs(m[3]);
              if (lineWidth === 0) {
                scaleX = 1 / normX;
                scaleY = 1 / normY;
              } else {
                const scaledXLineWidth = normX * lineWidth;
                const scaledYLineWidth = normY * lineWidth;
                scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
              }
            } else {
              const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
              const normX = Math.hypot(m[0], m[1]);
              const normY = Math.hypot(m[2], m[3]);
              if (lineWidth === 0) {
                scaleX = normY / absDet;
                scaleY = normX / absDet;
              } else {
                const baseArea = lineWidth * absDet;
                scaleX = normY > baseArea ? normY / baseArea : 1;
                scaleY = normX > baseArea ? normX / baseArea : 1;
              }
            }
            this._cachedScaleForStroking = [scaleX, scaleY];
          }
          return this._cachedScaleForStroking;
        }
        rescaleAndStroke(saveRestore) {
          const {
            ctx
          } = this;
          const {
            lineWidth
          } = this.current;
          const [scaleX, scaleY] = this.getScaleForStroking();
          ctx.lineWidth = lineWidth || 1;
          if (scaleX === 1 && scaleY === 1) {
            ctx.stroke();
            return;
          }
          let savedMatrix, savedDashes, savedDashOffset;
          if (saveRestore) {
            savedMatrix = ctx.mozCurrentTransform.slice();
            savedDashes = ctx.getLineDash().slice();
            savedDashOffset = ctx.lineDashOffset;
          }
          ctx.scale(scaleX, scaleY);
          const scale = Math.max(scaleX, scaleY);
          ctx.setLineDash(ctx.getLineDash().map(x => x / scale));
          ctx.lineDashOffset /= scale;
          ctx.stroke();
          if (saveRestore) {
            ctx.setTransform(...savedMatrix);
            ctx.setLineDash(savedDashes);
            ctx.lineDashOffset = savedDashOffset;
          }
        }
        getCanvasPosition(x, y) {
          const transform = this.ctx.mozCurrentTransform;
          return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
        }
        isContentVisible() {
          for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
            if (!this.markedContentStack[i].visible) {
              return false;
            }
          }
          return true;
        }
      }
      exports.CanvasGraphics = CanvasGraphics;
      for (const op in _util.OPS) {
        if (CanvasGraphics.prototype[op] !== undefined) {
          CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
        }
      }

      /***/
    }), ( /* 11 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TilingPattern = exports.PathType = void 0;
      exports.getShadingPattern = getShadingPattern;
      var _util = __w_pdfjs_require__(1);
      var _is_node = __w_pdfjs_require__(3);
      const PathType = {
        FILL: "Fill",
        STROKE: "Stroke",
        SHADING: "Shading"
      };
      exports.PathType = PathType;
      function applyBoundingBox(ctx, bbox) {
        if (!bbox || _is_node.isNodeJS) {
          return;
        }
        const width = bbox[2] - bbox[0];
        const height = bbox[3] - bbox[1];
        const region = new Path2D();
        region.rect(bbox[0], bbox[1], width, height);
        ctx.clip(region);
      }
      class BaseShadingPattern {
        constructor() {
          if (this.constructor === BaseShadingPattern) {
            (0, _util.unreachable)("Cannot initialize BaseShadingPattern.");
          }
        }
        getPattern() {
          (0, _util.unreachable)("Abstract method `getPattern` called.");
        }
      }
      class RadialAxialShadingPattern extends BaseShadingPattern {
        constructor(IR) {
          super();
          this._type = IR[1];
          this._bbox = IR[2];
          this._colorStops = IR[3];
          this._p0 = IR[4];
          this._p1 = IR[5];
          this._r0 = IR[6];
          this._r1 = IR[7];
          this.matrix = null;
        }
        _createGradient(ctx) {
          let grad;
          if (this._type === "axial") {
            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
          } else if (this._type === "radial") {
            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
          }
          for (const colorStop of this._colorStops) {
            grad.addColorStop(colorStop[0], colorStop[1]);
          }
          return grad;
        }
        getPattern(ctx, owner, inverse, pathType) {
          let pattern;
          if (pathType === PathType.STROKE || pathType === PathType.FILL) {
            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, ctx.mozCurrentTransform) || [0, 0, 0, 0];
            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
            const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
            const tmpCtx = tmpCanvas.context;
            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
            tmpCtx.beginPath();
            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
            inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
            tmpCtx.transform.apply(tmpCtx, owner.baseTransform);
            if (this.matrix) {
              tmpCtx.transform.apply(tmpCtx, this.matrix);
            }
            applyBoundingBox(tmpCtx, this._bbox);
            tmpCtx.fillStyle = this._createGradient(tmpCtx);
            tmpCtx.fill();
            pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
            const domMatrix = new DOMMatrix(inverse);
            try {
              pattern.setTransform(domMatrix);
            } catch (ex) {
              (0, _util.warn)(`RadialAxialShadingPattern.getPattern: "${ex === null || ex === void 0 ? void 0 : ex.message}".`);
            }
          } else {
            applyBoundingBox(ctx, this._bbox);
            pattern = this._createGradient(ctx);
          }
          return pattern;
        }
      }
      function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
        const coords = context.coords,
          colors = context.colors;
        const bytes = data.data,
          rowSize = data.width * 4;
        let tmp;
        if (coords[p1 + 1] > coords[p2 + 1]) {
          tmp = p1;
          p1 = p2;
          p2 = tmp;
          tmp = c1;
          c1 = c2;
          c2 = tmp;
        }
        if (coords[p2 + 1] > coords[p3 + 1]) {
          tmp = p2;
          p2 = p3;
          p3 = tmp;
          tmp = c2;
          c2 = c3;
          c3 = tmp;
        }
        if (coords[p1 + 1] > coords[p2 + 1]) {
          tmp = p1;
          p1 = p2;
          p2 = tmp;
          tmp = c1;
          c1 = c2;
          c2 = tmp;
        }
        const x1 = (coords[p1] + context.offsetX) * context.scaleX;
        const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
        const x2 = (coords[p2] + context.offsetX) * context.scaleX;
        const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
        const x3 = (coords[p3] + context.offsetX) * context.scaleX;
        const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
        if (y1 >= y3) {
          return;
        }
        const c1r = colors[c1],
          c1g = colors[c1 + 1],
          c1b = colors[c1 + 2];
        const c2r = colors[c2],
          c2g = colors[c2 + 1],
          c2b = colors[c2 + 2];
        const c3r = colors[c3],
          c3g = colors[c3 + 1],
          c3b = colors[c3 + 2];
        const minY = Math.round(y1),
          maxY = Math.round(y3);
        let xa, car, cag, cab;
        let xb, cbr, cbg, cbb;
        for (let y = minY; y <= maxY; y++) {
          if (y < y2) {
            let k;
            if (y < y1) {
              k = 0;
            } else {
              k = (y1 - y) / (y1 - y2);
            }
            xa = x1 - (x1 - x2) * k;
            car = c1r - (c1r - c2r) * k;
            cag = c1g - (c1g - c2g) * k;
            cab = c1b - (c1b - c2b) * k;
          } else {
            let k;
            if (y > y3) {
              k = 1;
            } else if (y2 === y3) {
              k = 0;
            } else {
              k = (y2 - y) / (y2 - y3);
            }
            xa = x2 - (x2 - x3) * k;
            car = c2r - (c2r - c3r) * k;
            cag = c2g - (c2g - c3g) * k;
            cab = c2b - (c2b - c3b) * k;
          }
          let k;
          if (y < y1) {
            k = 0;
          } else if (y > y3) {
            k = 1;
          } else {
            k = (y1 - y) / (y1 - y3);
          }
          xb = x1 - (x1 - x3) * k;
          cbr = c1r - (c1r - c3r) * k;
          cbg = c1g - (c1g - c3g) * k;
          cbb = c1b - (c1b - c3b) * k;
          const x1_ = Math.round(Math.min(xa, xb));
          const x2_ = Math.round(Math.max(xa, xb));
          let j = rowSize * y + x1_ * 4;
          for (let x = x1_; x <= x2_; x++) {
            k = (xa - x) / (xa - xb);
            if (k < 0) {
              k = 0;
            } else if (k > 1) {
              k = 1;
            }
            bytes[j++] = car - (car - cbr) * k | 0;
            bytes[j++] = cag - (cag - cbg) * k | 0;
            bytes[j++] = cab - (cab - cbb) * k | 0;
            bytes[j++] = 255;
          }
        }
      }
      function drawFigure(data, figure, context) {
        const ps = figure.coords;
        const cs = figure.colors;
        let i, ii;
        switch (figure.type) {
          case "lattice":
            const verticesPerRow = figure.verticesPerRow;
            const rows = Math.floor(ps.length / verticesPerRow) - 1;
            const cols = verticesPerRow - 1;
            for (i = 0; i < rows; i++) {
              let q = i * verticesPerRow;
              for (let j = 0; j < cols; j++, q++) {
                drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
              }
            }
            break;
          case "triangles":
            for (i = 0, ii = ps.length; i < ii; i += 3) {
              drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
            }
            break;
          default:
            throw new Error("illegal figure");
        }
      }
      class MeshShadingPattern extends BaseShadingPattern {
        constructor(IR) {
          super();
          this._coords = IR[2];
          this._colors = IR[3];
          this._figures = IR[4];
          this._bounds = IR[5];
          this._bbox = IR[7];
          this._background = IR[8];
          this.matrix = null;
        }
        _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
          const EXPECTED_SCALE = 1.1;
          const MAX_PATTERN_SIZE = 3000;
          const BORDER_SIZE = 2;
          const offsetX = Math.floor(this._bounds[0]);
          const offsetY = Math.floor(this._bounds[1]);
          const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
          const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
          const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
          const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
          const scaleX = boundsWidth / width;
          const scaleY = boundsHeight / height;
          const context = {
            coords: this._coords,
            colors: this._colors,
            offsetX: -offsetX,
            offsetY: -offsetY,
            scaleX: 1 / scaleX,
            scaleY: 1 / scaleY
          };
          const paddedWidth = width + BORDER_SIZE * 2;
          const paddedHeight = height + BORDER_SIZE * 2;
          const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
          const tmpCtx = tmpCanvas.context;
          const data = tmpCtx.createImageData(width, height);
          if (backgroundColor) {
            const bytes = data.data;
            for (let i = 0, ii = bytes.length; i < ii; i += 4) {
              bytes[i] = backgroundColor[0];
              bytes[i + 1] = backgroundColor[1];
              bytes[i + 2] = backgroundColor[2];
              bytes[i + 3] = 255;
            }
          }
          for (const figure of this._figures) {
            drawFigure(data, figure, context);
          }
          tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
          const canvas = tmpCanvas.canvas;
          return {
            canvas,
            offsetX: offsetX - BORDER_SIZE * scaleX,
            offsetY: offsetY - BORDER_SIZE * scaleY,
            scaleX,
            scaleY
          };
        }
        getPattern(ctx, owner, inverse, pathType) {
          applyBoundingBox(ctx, this._bbox);
          let scale;
          if (pathType === PathType.SHADING) {
            scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
          } else {
            scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);
            if (this.matrix) {
              const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);
              scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
            }
          }
          const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
          if (pathType !== PathType.SHADING) {
            ctx.setTransform.apply(ctx, owner.baseTransform);
            if (this.matrix) {
              ctx.transform.apply(ctx, this.matrix);
            }
          }
          ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
          ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
          return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
        }
      }
      class DummyShadingPattern extends BaseShadingPattern {
        getPattern() {
          return "hotpink";
        }
      }
      function getShadingPattern(IR) {
        switch (IR[0]) {
          case "RadialAxial":
            return new RadialAxialShadingPattern(IR);
          case "Mesh":
            return new MeshShadingPattern(IR);
          case "Dummy":
            return new DummyShadingPattern();
        }
        throw new Error(`Unknown IR type: ${IR[0]}`);
      }
      const PaintType = {
        COLORED: 1,
        UNCOLORED: 2
      };
      class TilingPattern {
        static get MAX_PATTERN_SIZE() {
          return (0, _util.shadow)(this, "MAX_PATTERN_SIZE", 3000);
        }
        constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
          this.operatorList = IR[2];
          this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
          this.bbox = IR[4];
          this.xstep = IR[5];
          this.ystep = IR[6];
          this.paintType = IR[7];
          this.tilingType = IR[8];
          this.color = color;
          this.ctx = ctx;
          this.canvasGraphicsFactory = canvasGraphicsFactory;
          this.baseTransform = baseTransform;
        }
        createPatternCanvas(owner) {
          const operatorList = this.operatorList;
          const bbox = this.bbox;
          const xstep = this.xstep;
          const ystep = this.ystep;
          const paintType = this.paintType;
          const tilingType = this.tilingType;
          const color = this.color;
          const canvasGraphicsFactory = this.canvasGraphicsFactory;
          (0, _util.info)("TilingType: " + tilingType);
          const x0 = bbox[0],
            y0 = bbox[1],
            x1 = bbox[2],
            y1 = bbox[3];
          const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);
          const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);
          const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
          const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
          const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
          const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
          const tmpCtx = tmpCanvas.context;
          const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
          graphics.groupLevel = owner.groupLevel;
          this.setFillAndStrokeStyleToContext(graphics, paintType, color);
          let adjustedX0 = x0;
          let adjustedY0 = y0;
          let adjustedX1 = x1;
          let adjustedY1 = y1;
          if (x0 < 0) {
            adjustedX0 = 0;
            adjustedX1 += Math.abs(x0);
          }
          if (y0 < 0) {
            adjustedY0 = 0;
            adjustedY1 += Math.abs(y0);
          }
          tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
          graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
          tmpCtx.save();
          this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
          graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();
          graphics.executeOperatorList(operatorList);
          graphics.endDrawing();
          return {
            canvas: tmpCanvas.canvas,
            scaleX: dimx.scale,
            scaleY: dimy.scale,
            offsetX: adjustedX0,
            offsetY: adjustedY0
          };
        }
        getSizeAndScale(step, realOutputSize, scale) {
          step = Math.abs(step);
          const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
          let size = Math.ceil(step * scale);
          if (size >= maxSize) {
            size = maxSize;
          } else {
            scale = size / step;
          }
          return {
            scale,
            size
          };
        }
        clipBbox(graphics, x0, y0, x1, y1) {
          const bboxWidth = x1 - x0;
          const bboxHeight = y1 - y0;
          graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
          graphics.current.updateRectMinMax(graphics.ctx.mozCurrentTransform, [x0, y0, x1, y1]);
          graphics.clip();
          graphics.endPath();
        }
        setFillAndStrokeStyleToContext(graphics, paintType, color) {
          const context = graphics.ctx,
            current = graphics.current;
          switch (paintType) {
            case PaintType.COLORED:
              const ctx = this.ctx;
              context.fillStyle = ctx.fillStyle;
              context.strokeStyle = ctx.strokeStyle;
              current.fillColor = ctx.fillStyle;
              current.strokeColor = ctx.strokeStyle;
              break;
            case PaintType.UNCOLORED:
              const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);
              context.fillStyle = cssColor;
              context.strokeStyle = cssColor;
              current.fillColor = cssColor;
              current.strokeColor = cssColor;
              break;
            default:
              throw new _util.FormatError(`Unsupported paint type: ${paintType}`);
          }
        }
        getPattern(ctx, owner, inverse, pathType) {
          let matrix = inverse;
          if (pathType !== PathType.SHADING) {
            matrix = _util.Util.transform(matrix, owner.baseTransform);
            if (this.matrix) {
              matrix = _util.Util.transform(matrix, this.matrix);
            }
          }
          const temporaryPatternCanvas = this.createPatternCanvas(owner);
          let domMatrix = new DOMMatrix(matrix);
          domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
          domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
          const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
          try {
            pattern.setTransform(domMatrix);
          } catch (ex) {
            (0, _util.warn)(`TilingPattern.getPattern: "${ex === null || ex === void 0 ? void 0 : ex.message}".`);
          }
          return pattern;
        }
      }
      exports.TilingPattern = TilingPattern;

      /***/
    }), ( /* 12 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.applyMaskImageData = applyMaskImageData;
      var _util = __w_pdfjs_require__(1);
      function applyMaskImageData({
        src,
        srcPos = 0,
        dest,
        destPos = 0,
        width,
        height,
        inverseDecode = false
      }) {
        const opaque = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
        const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];
        const widthInSource = width >> 3;
        const widthRemainder = width & 7;
        const srcLength = src.length;
        dest = new Uint32Array(dest.buffer);
        for (let i = 0; i < height; i++) {
          for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
            const elem = srcPos < srcLength ? src[srcPos] : 255;
            dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;
            dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;
          }
          if (widthRemainder === 0) {
            continue;
          }
          const elem = srcPos < srcLength ? src[srcPos++] : 255;
          for (let j = 0; j < widthRemainder; j++) {
            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
          }
        }
        return {
          srcPos,
          destPos
        };
      }

      /***/
    }), ( /* 13 */
    /***/(__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GlobalWorkerOptions = void 0;
      const GlobalWorkerOptions = Object.create(null);
      exports.GlobalWorkerOptions = GlobalWorkerOptions;
      GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
      GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;

      /***/
    }), ( /* 14 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MessageHandler = void 0;
      var _util = __w_pdfjs_require__(1);
      const CallbackKind = {
        UNKNOWN: 0,
        DATA: 1,
        ERROR: 2
      };
      const StreamKind = {
        UNKNOWN: 0,
        CANCEL: 1,
        CANCEL_COMPLETE: 2,
        CLOSE: 3,
        ENQUEUE: 4,
        ERROR: 5,
        PULL: 6,
        PULL_COMPLETE: 7,
        START_COMPLETE: 8
      };
      function wrapReason(reason) {
        if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
          (0, _util.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
        }
        switch (reason.name) {
          case "AbortException":
            return new _util.AbortException(reason.message);
          case "MissingPDFException":
            return new _util.MissingPDFException(reason.message);
          case "PasswordException":
            return new _util.PasswordException(reason.message, reason.code);
          case "UnexpectedResponseException":
            return new _util.UnexpectedResponseException(reason.message, reason.status);
          case "UnknownErrorException":
            return new _util.UnknownErrorException(reason.message, reason.details);
          default:
            return new _util.UnknownErrorException(reason.message, reason.toString());
        }
      }
      class MessageHandler {
        constructor(sourceName, targetName, comObj) {
          this.sourceName = sourceName;
          this.targetName = targetName;
          this.comObj = comObj;
          this.callbackId = 1;
          this.streamId = 1;
          this.streamSinks = Object.create(null);
          this.streamControllers = Object.create(null);
          this.callbackCapabilities = Object.create(null);
          this.actionHandler = Object.create(null);
          this._onComObjOnMessage = event => {
            const data = event.data;
            if (data.targetName !== this.sourceName) {
              return;
            }
            if (data.stream) {
              this._processStreamMessage(data);
              return;
            }
            if (data.callback) {
              const callbackId = data.callbackId;
              const capability = this.callbackCapabilities[callbackId];
              if (!capability) {
                throw new Error(`Cannot resolve callback ${callbackId}`);
              }
              delete this.callbackCapabilities[callbackId];
              if (data.callback === CallbackKind.DATA) {
                capability.resolve(data.data);
              } else if (data.callback === CallbackKind.ERROR) {
                capability.reject(wrapReason(data.reason));
              } else {
                throw new Error("Unexpected callback case");
              }
              return;
            }
            const action = this.actionHandler[data.action];
            if (!action) {
              throw new Error(`Unknown action from worker: ${data.action}`);
            }
            if (data.callbackId) {
              const cbSourceName = this.sourceName;
              const cbTargetName = data.sourceName;
              new Promise(function (resolve) {
                resolve(action(data.data));
              }).then(function (result) {
                comObj.postMessage({
                  sourceName: cbSourceName,
                  targetName: cbTargetName,
                  callback: CallbackKind.DATA,
                  callbackId: data.callbackId,
                  data: result
                });
              }, function (reason) {
                comObj.postMessage({
                  sourceName: cbSourceName,
                  targetName: cbTargetName,
                  callback: CallbackKind.ERROR,
                  callbackId: data.callbackId,
                  reason: wrapReason(reason)
                });
              });
              return;
            }
            if (data.streamId) {
              this._createStreamSink(data);
              return;
            }
            action(data.data);
          };
          comObj.addEventListener("message", this._onComObjOnMessage);
        }
        on(actionName, handler) {
          const ah = this.actionHandler;
          if (ah[actionName]) {
            throw new Error(`There is already an actionName called "${actionName}"`);
          }
          ah[actionName] = handler;
        }
        send(actionName, data, transfers) {
          this.comObj.postMessage({
            sourceName: this.sourceName,
            targetName: this.targetName,
            action: actionName,
            data
          }, transfers);
        }
        sendWithPromise(actionName, data, transfers) {
          const callbackId = this.callbackId++;
          const capability = (0, _util.createPromiseCapability)();
          this.callbackCapabilities[callbackId] = capability;
          try {
            this.comObj.postMessage({
              sourceName: this.sourceName,
              targetName: this.targetName,
              action: actionName,
              callbackId,
              data
            }, transfers);
          } catch (ex) {
            capability.reject(ex);
          }
          return capability.promise;
        }
        sendWithStream(actionName, data, queueingStrategy, transfers) {
          const streamId = this.streamId++,
            sourceName = this.sourceName,
            targetName = this.targetName,
            comObj = this.comObj;
          return new ReadableStream({
            start: controller => {
              const startCapability = (0, _util.createPromiseCapability)();
              this.streamControllers[streamId] = {
                controller,
                startCall: startCapability,
                pullCall: null,
                cancelCall: null,
                isClosed: false
              };
              comObj.postMessage({
                sourceName,
                targetName,
                action: actionName,
                streamId,
                data,
                desiredSize: controller.desiredSize
              }, transfers);
              return startCapability.promise;
            },
            pull: controller => {
              const pullCapability = (0, _util.createPromiseCapability)();
              this.streamControllers[streamId].pullCall = pullCapability;
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.PULL,
                streamId,
                desiredSize: controller.desiredSize
              });
              return pullCapability.promise;
            },
            cancel: reason => {
              (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
              const cancelCapability = (0, _util.createPromiseCapability)();
              this.streamControllers[streamId].cancelCall = cancelCapability;
              this.streamControllers[streamId].isClosed = true;
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.CANCEL,
                streamId,
                reason: wrapReason(reason)
              });
              return cancelCapability.promise;
            }
          }, queueingStrategy);
        }
        _createStreamSink(data) {
          const streamId = data.streamId,
            sourceName = this.sourceName,
            targetName = data.sourceName,
            comObj = this.comObj;
          const self = this,
            action = this.actionHandler[data.action];
          const streamSink = {
            enqueue(chunk, size = 1, transfers) {
              if (this.isCancelled) {
                return;
              }
              const lastDesiredSize = this.desiredSize;
              this.desiredSize -= size;
              if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                this.sinkCapability = (0, _util.createPromiseCapability)();
                this.ready = this.sinkCapability.promise;
              }
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.ENQUEUE,
                streamId,
                chunk
              }, transfers);
            },
            close() {
              if (this.isCancelled) {
                return;
              }
              this.isCancelled = true;
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.CLOSE,
                streamId
              });
              delete self.streamSinks[streamId];
            },
            error(reason) {
              (0, _util.assert)(reason instanceof Error, "error must have a valid reason");
              if (this.isCancelled) {
                return;
              }
              this.isCancelled = true;
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.ERROR,
                streamId,
                reason: wrapReason(reason)
              });
            },
            sinkCapability: (0, _util.createPromiseCapability)(),
            onPull: null,
            onCancel: null,
            isCancelled: false,
            desiredSize: data.desiredSize,
            ready: null
          };
          streamSink.sinkCapability.resolve();
          streamSink.ready = streamSink.sinkCapability.promise;
          this.streamSinks[streamId] = streamSink;
          new Promise(function (resolve) {
            resolve(action(data.data, streamSink));
          }).then(function () {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.START_COMPLETE,
              streamId,
              success: true
            });
          }, function (reason) {
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.START_COMPLETE,
              streamId,
              reason: wrapReason(reason)
            });
          });
        }
        _processStreamMessage(data) {
          const streamId = data.streamId,
            sourceName = this.sourceName,
            targetName = data.sourceName,
            comObj = this.comObj;
          const streamController = this.streamControllers[streamId],
            streamSink = this.streamSinks[streamId];
          switch (data.stream) {
            case StreamKind.START_COMPLETE:
              if (data.success) {
                streamController.startCall.resolve();
              } else {
                streamController.startCall.reject(wrapReason(data.reason));
              }
              break;
            case StreamKind.PULL_COMPLETE:
              if (data.success) {
                streamController.pullCall.resolve();
              } else {
                streamController.pullCall.reject(wrapReason(data.reason));
              }
              break;
            case StreamKind.PULL:
              if (!streamSink) {
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.PULL_COMPLETE,
                  streamId,
                  success: true
                });
                break;
              }
              if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                streamSink.sinkCapability.resolve();
              }
              streamSink.desiredSize = data.desiredSize;
              new Promise(function (resolve) {
                resolve(streamSink.onPull && streamSink.onPull());
              }).then(function () {
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.PULL_COMPLETE,
                  streamId,
                  success: true
                });
              }, function (reason) {
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.PULL_COMPLETE,
                  streamId,
                  reason: wrapReason(reason)
                });
              });
              break;
            case StreamKind.ENQUEUE:
              (0, _util.assert)(streamController, "enqueue should have stream controller");
              if (streamController.isClosed) {
                break;
              }
              streamController.controller.enqueue(data.chunk);
              break;
            case StreamKind.CLOSE:
              (0, _util.assert)(streamController, "close should have stream controller");
              if (streamController.isClosed) {
                break;
              }
              streamController.isClosed = true;
              streamController.controller.close();
              this._deleteStreamController(streamController, streamId);
              break;
            case StreamKind.ERROR:
              (0, _util.assert)(streamController, "error should have stream controller");
              streamController.controller.error(wrapReason(data.reason));
              this._deleteStreamController(streamController, streamId);
              break;
            case StreamKind.CANCEL_COMPLETE:
              if (data.success) {
                streamController.cancelCall.resolve();
              } else {
                streamController.cancelCall.reject(wrapReason(data.reason));
              }
              this._deleteStreamController(streamController, streamId);
              break;
            case StreamKind.CANCEL:
              if (!streamSink) {
                break;
              }
              new Promise(function (resolve) {
                resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
              }).then(function () {
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.CANCEL_COMPLETE,
                  streamId,
                  success: true
                });
              }, function (reason) {
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.CANCEL_COMPLETE,
                  streamId,
                  reason: wrapReason(reason)
                });
              });
              streamSink.sinkCapability.reject(wrapReason(data.reason));
              streamSink.isCancelled = true;
              delete this.streamSinks[streamId];
              break;
            default:
              throw new Error("Unexpected stream case");
          }
        }
        _deleteStreamController(streamController, streamId) {
          var _this10 = this;
          return _asyncToGenerator(function* () {
            yield Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
            delete _this10.streamControllers[streamId];
          })();
        }
        destroy() {
          this.comObj.removeEventListener("message", this._onComObjOnMessage);
        }
      }
      exports.MessageHandler = MessageHandler;

      /***/
    }), ( /* 15 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Metadata = void 0;
      var _util = __w_pdfjs_require__(1);
      var _metadataMap = /*#__PURE__*/new WeakMap();
      var _data = /*#__PURE__*/new WeakMap();
      class Metadata {
        constructor({
          parsedData,
          rawData
        }) {
          _classPrivateFieldInitSpec(this, _metadataMap, void 0);
          _classPrivateFieldInitSpec(this, _data, void 0);
          _classPrivateFieldSet(_metadataMap, this, parsedData);
          _classPrivateFieldSet(_data, this, rawData);
        }
        getRaw() {
          return _classPrivateFieldGet(_data, this);
        }
        get(name) {
          var _classPrivateFieldGet2;
          return (_classPrivateFieldGet2 = _classPrivateFieldGet(_metadataMap, this).get(name)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : null;
        }
        getAll() {
          return (0, _util.objectFromMap)(_classPrivateFieldGet(_metadataMap, this));
        }
        has(name) {
          return _classPrivateFieldGet(_metadataMap, this).has(name);
        }
      }
      exports.Metadata = Metadata;

      /***/
    }), ( /* 16 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.OptionalContentConfig = void 0;
      var _util = __w_pdfjs_require__(1);
      class OptionalContentGroup {
        constructor(name, intent) {
          this.visible = true;
          this.name = name;
          this.intent = intent;
        }
      }
      class OptionalContentConfig {
        constructor(data) {
          this.name = null;
          this.creator = null;
          this._order = null;
          this._groups = new Map();
          if (data === null) {
            return;
          }
          this.name = data.name;
          this.creator = data.creator;
          this._order = data.order;
          for (const group of data.groups) {
            this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));
          }
          if (data.baseState === "OFF") {
            for (const group of this._groups) {
              group.visible = false;
            }
          }
          for (const on of data.on) {
            this._groups.get(on).visible = true;
          }
          for (const off of data.off) {
            this._groups.get(off).visible = false;
          }
        }
        _evaluateVisibilityExpression(array) {
          const length = array.length;
          if (length < 2) {
            return true;
          }
          const operator = array[0];
          for (let i = 1; i < length; i++) {
            const element = array[i];
            let state;
            if (Array.isArray(element)) {
              state = this._evaluateVisibilityExpression(element);
            } else if (this._groups.has(element)) {
              state = this._groups.get(element).visible;
            } else {
              (0, _util.warn)(`Optional content group not found: ${element}`);
              return true;
            }
            switch (operator) {
              case "And":
                if (!state) {
                  return false;
                }
                break;
              case "Or":
                if (state) {
                  return true;
                }
                break;
              case "Not":
                return !state;
              default:
                return true;
            }
          }
          return operator === "And";
        }
        isVisible(group) {
          if (this._groups.size === 0) {
            return true;
          }
          if (!group) {
            (0, _util.warn)("Optional content group not defined.");
            return true;
          }
          if (group.type === "OCG") {
            if (!this._groups.has(group.id)) {
              (0, _util.warn)(`Optional content group not found: ${group.id}`);
              return true;
            }
            return this._groups.get(group.id).visible;
          } else if (group.type === "OCMD") {
            if (group.expression) {
              return this._evaluateVisibilityExpression(group.expression);
            }
            if (!group.policy || group.policy === "AnyOn") {
              for (const id of group.ids) {
                if (!this._groups.has(id)) {
                  (0, _util.warn)(`Optional content group not found: ${id}`);
                  return true;
                }
                if (this._groups.get(id).visible) {
                  return true;
                }
              }
              return false;
            } else if (group.policy === "AllOn") {
              for (const id of group.ids) {
                if (!this._groups.has(id)) {
                  (0, _util.warn)(`Optional content group not found: ${id}`);
                  return true;
                }
                if (!this._groups.get(id).visible) {
                  return false;
                }
              }
              return true;
            } else if (group.policy === "AnyOff") {
              for (const id of group.ids) {
                if (!this._groups.has(id)) {
                  (0, _util.warn)(`Optional content group not found: ${id}`);
                  return true;
                }
                if (!this._groups.get(id).visible) {
                  return true;
                }
              }
              return false;
            } else if (group.policy === "AllOff") {
              for (const id of group.ids) {
                if (!this._groups.has(id)) {
                  (0, _util.warn)(`Optional content group not found: ${id}`);
                  return true;
                }
                if (this._groups.get(id).visible) {
                  return false;
                }
              }
              return true;
            }
            (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);
            return true;
          }
          (0, _util.warn)(`Unknown group type ${group.type}.`);
          return true;
        }
        setVisibility(id, visible = true) {
          if (!this._groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return;
          }
          this._groups.get(id).visible = !!visible;
        }
        getOrder() {
          if (!this._groups.size) {
            return null;
          }
          if (this._order) {
            return this._order.slice();
          }
          return Array.from(this._groups.keys());
        }
        getGroups() {
          return this._groups.size > 0 ? (0, _util.objectFromMap)(this._groups) : null;
        }
        getGroup(id) {
          return this._groups.get(id) || null;
        }
      }
      exports.OptionalContentConfig = OptionalContentConfig;

      /***/
    }), ( /* 17 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFDataTransportStream = void 0;
      var _util = __w_pdfjs_require__(1);
      var _display_utils = __w_pdfjs_require__(5);
      class PDFDataTransportStream {
        constructor(params, pdfDataRangeTransport) {
          (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
          this._queuedChunks = [];
          this._progressiveDone = params.progressiveDone || false;
          this._contentDispositionFilename = params.contentDispositionFilename || null;
          const initialData = params.initialData;
          if ((initialData === null || initialData === void 0 ? void 0 : initialData.length) > 0) {
            const buffer = new Uint8Array(initialData).buffer;
            this._queuedChunks.push(buffer);
          }
          this._pdfDataRangeTransport = pdfDataRangeTransport;
          this._isStreamingSupported = !params.disableStream;
          this._isRangeSupported = !params.disableRange;
          this._contentLength = params.length;
          this._fullRequestReader = null;
          this._rangeReaders = [];
          this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
            this._onReceiveData({
              begin,
              chunk
            });
          });
          this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
            this._onProgress({
              loaded,
              total
            });
          });
          this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {
            this._onReceiveData({
              chunk
            });
          });
          this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
            this._onProgressiveDone();
          });
          this._pdfDataRangeTransport.transportReady();
        }
        _onReceiveData(args) {
          const buffer = new Uint8Array(args.chunk).buffer;
          if (args.begin === undefined) {
            if (this._fullRequestReader) {
              this._fullRequestReader._enqueue(buffer);
            } else {
              this._queuedChunks.push(buffer);
            }
          } else {
            const found = this._rangeReaders.some(function (rangeReader) {
              if (rangeReader._begin !== args.begin) {
                return false;
              }
              rangeReader._enqueue(buffer);
              return true;
            });
            (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
          }
        }
        get _progressiveDataLength() {
          var _this$_fullRequestRea, _this$_fullRequestRea2;
          return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
        }
        _onProgress(evt) {
          if (evt.total === undefined) {
            const firstReader = this._rangeReaders[0];
            if (firstReader !== null && firstReader !== void 0 && firstReader.onProgress) {
              firstReader.onProgress({
                loaded: evt.loaded
              });
            }
          } else {
            const fullReader = this._fullRequestReader;
            if (fullReader !== null && fullReader !== void 0 && fullReader.onProgress) {
              fullReader.onProgress({
                loaded: evt.loaded,
                total: evt.total
              });
            }
          }
        }
        _onProgressiveDone() {
          if (this._fullRequestReader) {
            this._fullRequestReader.progressiveDone();
          }
          this._progressiveDone = true;
        }
        _removeRangeReader(reader) {
          const i = this._rangeReaders.indexOf(reader);
          if (i >= 0) {
            this._rangeReaders.splice(i, 1);
          }
        }
        getFullReader() {
          (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
          const queuedChunks = this._queuedChunks;
          this._queuedChunks = null;
          return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
        }
        getRangeReader(begin, end) {
          if (end <= this._progressiveDataLength) {
            return null;
          }
          const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
          this._pdfDataRangeTransport.requestDataRange(begin, end);
          this._rangeReaders.push(reader);
          return reader;
        }
        cancelAllRequests(reason) {
          if (this._fullRequestReader) {
            this._fullRequestReader.cancel(reason);
          }
          for (const reader of this._rangeReaders.slice(0)) {
            reader.cancel(reason);
          }
          this._pdfDataRangeTransport.abort();
        }
      }
      exports.PDFDataTransportStream = PDFDataTransportStream;
      class PDFDataTransportStreamReader {
        constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
          this._stream = stream;
          this._done = progressiveDone || false;
          this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
          this._queuedChunks = queuedChunks || [];
          this._loaded = 0;
          for (const chunk of this._queuedChunks) {
            this._loaded += chunk.byteLength;
          }
          this._requests = [];
          this._headersReady = Promise.resolve();
          stream._fullRequestReader = this;
          this.onProgress = null;
        }
        _enqueue(chunk) {
          if (this._done) {
            return;
          }
          if (this._requests.length > 0) {
            const requestCapability = this._requests.shift();
            requestCapability.resolve({
              value: chunk,
              done: false
            });
          } else {
            this._queuedChunks.push(chunk);
          }
          this._loaded += chunk.byteLength;
        }
        get headersReady() {
          return this._headersReady;
        }
        get filename() {
          return this._filename;
        }
        get isRangeSupported() {
          return this._stream._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._stream._isStreamingSupported;
        }
        get contentLength() {
          return this._stream._contentLength;
        }
        read() {
          var _this11 = this;
          return _asyncToGenerator(function* () {
            if (_this11._queuedChunks.length > 0) {
              const chunk = _this11._queuedChunks.shift();
              return {
                value: chunk,
                done: false
              };
            }
            if (_this11._done) {
              return {
                value: undefined,
                done: true
              };
            }
            const requestCapability = (0, _util.createPromiseCapability)();
            _this11._requests.push(requestCapability);
            return requestCapability.promise;
          })();
        }
        cancel(reason) {
          this._done = true;
          for (const requestCapability of this._requests) {
            requestCapability.resolve({
              value: undefined,
              done: true
            });
          }
          this._requests.length = 0;
        }
        progressiveDone() {
          if (this._done) {
            return;
          }
          this._done = true;
        }
      }
      class PDFDataTransportStreamRangeReader {
        constructor(stream, begin, end) {
          this._stream = stream;
          this._begin = begin;
          this._end = end;
          this._queuedChunk = null;
          this._requests = [];
          this._done = false;
          this.onProgress = null;
        }
        _enqueue(chunk) {
          if (this._done) {
            return;
          }
          if (this._requests.length === 0) {
            this._queuedChunk = chunk;
          } else {
            const requestsCapability = this._requests.shift();
            requestsCapability.resolve({
              value: chunk,
              done: false
            });
            for (const requestCapability of this._requests) {
              requestCapability.resolve({
                value: undefined,
                done: true
              });
            }
            this._requests.length = 0;
          }
          this._done = true;
          this._stream._removeRangeReader(this);
        }
        get isStreamingSupported() {
          return false;
        }
        read() {
          var _this12 = this;
          return _asyncToGenerator(function* () {
            if (_this12._queuedChunk) {
              const chunk = _this12._queuedChunk;
              _this12._queuedChunk = null;
              return {
                value: chunk,
                done: false
              };
            }
            if (_this12._done) {
              return {
                value: undefined,
                done: true
              };
            }
            const requestCapability = (0, _util.createPromiseCapability)();
            _this12._requests.push(requestCapability);
            return requestCapability.promise;
          })();
        }
        cancel(reason) {
          this._done = true;
          for (const requestCapability of this._requests) {
            requestCapability.resolve({
              value: undefined,
              done: true
            });
          }
          this._requests.length = 0;
          this._stream._removeRangeReader(this);
        }
      }

      /***/
    }), ( /* 18 */
    /***/(__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.XfaText = void 0;
      class XfaText {
        static textContent(xfa) {
          const items = [];
          const output = {
            items,
            styles: Object.create(null)
          };
          function walk(node) {
            var _node$attributes;
            if (!node) {
              return;
            }
            let str = null;
            const name = node.name;
            if (name === "#text") {
              str = node.value;
            } else if (!XfaText.shouldBuildText(name)) {
              return;
            } else if (node !== null && node !== void 0 && (_node$attributes = node.attributes) !== null && _node$attributes !== void 0 && _node$attributes.textContent) {
              str = node.attributes.textContent;
            } else if (node.value) {
              str = node.value;
            }
            if (str !== null) {
              items.push({
                str
              });
            }
            if (!node.children) {
              return;
            }
            for (const child of node.children) {
              walk(child);
            }
          }
          walk(xfa);
          return output;
        }
        static shouldBuildText(name) {
          return !(name === "textarea" || name === "input" || name === "option" || name === "select");
        }
      }
      exports.XfaText = XfaText;

      /***/
    }), ( /* 19 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;
      var _base_factory = __w_pdfjs_require__(6);
      ;
      const fetchData = function (url) {
        return new Promise((resolve, reject) => {
          const fs = __webpack_require__(/*! fs */ 70172);
          fs.readFile(url, (error, data) => {
            if (error || !data) {
              reject(new Error(error));
              return;
            }
            resolve(new Uint8Array(data));
          });
        });
      };
      class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
        _createCanvas(width, height) {
          const Canvas = __webpack_require__(/*! canvas */ 93414);
          return Canvas.createCanvas(width, height);
        }
      }
      exports.NodeCanvasFactory = NodeCanvasFactory;
      class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
        _fetchData(url, compressionType) {
          return fetchData(url).then(data => {
            return {
              cMapData: data,
              compressionType
            };
          });
        }
      }
      exports.NodeCMapReaderFactory = NodeCMapReaderFactory;
      class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
        _fetchData(url) {
          return fetchData(url);
        }
      }
      exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;

      /***/
    }), ( /* 20 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AnnotationLayer = void 0;
      var _util = __w_pdfjs_require__(1);
      var _display_utils = __w_pdfjs_require__(5);
      var _annotation_storage = __w_pdfjs_require__(8);
      var _scripting_utils = __w_pdfjs_require__(21);
      var _xfa_layer = __w_pdfjs_require__(22);
      const DEFAULT_TAB_INDEX = 1000;
      const GetElementsByNameSet = new WeakSet();
      function getRectDims(rect) {
        return {
          width: rect[2] - rect[0],
          height: rect[3] - rect[1]
        };
      }
      class AnnotationElementFactory {
        static create(parameters) {
          const subtype = parameters.data.annotationType;
          switch (subtype) {
            case _util.AnnotationType.LINK:
              return new LinkAnnotationElement(parameters);
            case _util.AnnotationType.TEXT:
              return new TextAnnotationElement(parameters);
            case _util.AnnotationType.WIDGET:
              const fieldType = parameters.data.fieldType;
              switch (fieldType) {
                case "Tx":
                  return new TextWidgetAnnotationElement(parameters);
                case "Btn":
                  if (parameters.data.radioButton) {
                    return new RadioButtonWidgetAnnotationElement(parameters);
                  } else if (parameters.data.checkBox) {
                    return new CheckboxWidgetAnnotationElement(parameters);
                  }
                  return new PushButtonWidgetAnnotationElement(parameters);
                case "Ch":
                  return new ChoiceWidgetAnnotationElement(parameters);
              }
              return new WidgetAnnotationElement(parameters);
            case _util.AnnotationType.POPUP:
              return new PopupAnnotationElement(parameters);
            case _util.AnnotationType.FREETEXT:
              return new FreeTextAnnotationElement(parameters);
            case _util.AnnotationType.LINE:
              return new LineAnnotationElement(parameters);
            case _util.AnnotationType.SQUARE:
              return new SquareAnnotationElement(parameters);
            case _util.AnnotationType.CIRCLE:
              return new CircleAnnotationElement(parameters);
            case _util.AnnotationType.POLYLINE:
              return new PolylineAnnotationElement(parameters);
            case _util.AnnotationType.CARET:
              return new CaretAnnotationElement(parameters);
            case _util.AnnotationType.INK:
              return new InkAnnotationElement(parameters);
            case _util.AnnotationType.POLYGON:
              return new PolygonAnnotationElement(parameters);
            case _util.AnnotationType.HIGHLIGHT:
              return new HighlightAnnotationElement(parameters);
            case _util.AnnotationType.UNDERLINE:
              return new UnderlineAnnotationElement(parameters);
            case _util.AnnotationType.SQUIGGLY:
              return new SquigglyAnnotationElement(parameters);
            case _util.AnnotationType.STRIKEOUT:
              return new StrikeOutAnnotationElement(parameters);
            case _util.AnnotationType.STAMP:
              return new StampAnnotationElement(parameters);
            case _util.AnnotationType.FILEATTACHMENT:
              return new FileAttachmentAnnotationElement(parameters);
            default:
              return new AnnotationElement(parameters);
          }
        }
      }
      class AnnotationElement {
        constructor(parameters, {
          isRenderable = false,
          ignoreBorder = false,
          createQuadrilaterals = false
        } = {}) {
          this.isRenderable = isRenderable;
          this.data = parameters.data;
          this.layer = parameters.layer;
          this.page = parameters.page;
          this.viewport = parameters.viewport;
          this.linkService = parameters.linkService;
          this.downloadManager = parameters.downloadManager;
          this.imageResourcesPath = parameters.imageResourcesPath;
          this.renderForms = parameters.renderForms;
          this.svgFactory = parameters.svgFactory;
          this.annotationStorage = parameters.annotationStorage;
          this.enableScripting = parameters.enableScripting;
          this.hasJSActions = parameters.hasJSActions;
          this._fieldObjects = parameters.fieldObjects;
          this._mouseState = parameters.mouseState;
          if (isRenderable) {
            this.container = this._createContainer(ignoreBorder);
          }
          if (createQuadrilaterals) {
            this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
          }
        }
        _createContainer(ignoreBorder = false) {
          const data = this.data,
            page = this.page,
            viewport = this.viewport;
          const container = document.createElement("section");
          let {
            width,
            height
          } = getRectDims(data.rect);
          container.setAttribute("data-annotation-id", data.id);
          const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
          if (data.hasOwnCanvas) {
            const transform = viewport.transform.slice();
            const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(transform);
            width = Math.ceil(width * scaleX);
            height = Math.ceil(height * scaleY);
            rect[0] *= scaleX;
            rect[1] *= scaleY;
            for (let i = 0; i < 4; i++) {
              transform[i] = Math.sign(transform[i]);
            }
            container.style.transform = `matrix(${transform.join(",")})`;
          } else {
            container.style.transform = `matrix(${viewport.transform.join(",")})`;
          }
          container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;
          if (!ignoreBorder && data.borderStyle.width > 0) {
            container.style.borderWidth = `${data.borderStyle.width}px`;
            if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
              width -= 2 * data.borderStyle.width;
              height -= 2 * data.borderStyle.width;
            }
            const horizontalRadius = data.borderStyle.horizontalCornerRadius;
            const verticalRadius = data.borderStyle.verticalCornerRadius;
            if (horizontalRadius > 0 || verticalRadius > 0) {
              const radius = `${horizontalRadius}px / ${verticalRadius}px`;
              container.style.borderRadius = radius;
            }
            switch (data.borderStyle.style) {
              case _util.AnnotationBorderStyleType.SOLID:
                container.style.borderStyle = "solid";
                break;
              case _util.AnnotationBorderStyleType.DASHED:
                container.style.borderStyle = "dashed";
                break;
              case _util.AnnotationBorderStyleType.BEVELED:
                (0, _util.warn)("Unimplemented border style: beveled");
                break;
              case _util.AnnotationBorderStyleType.INSET:
                (0, _util.warn)("Unimplemented border style: inset");
                break;
              case _util.AnnotationBorderStyleType.UNDERLINE:
                container.style.borderBottomStyle = "solid";
                break;
              default:
                break;
            }
            const borderColor = data.borderColor || data.color || null;
            if (borderColor) {
              container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
            } else {
              container.style.borderWidth = 0;
            }
          }
          container.style.left = `${rect[0]}px`;
          container.style.top = `${rect[1]}px`;
          if (data.hasOwnCanvas) {
            container.style.width = container.style.height = "auto";
          } else {
            container.style.width = `${width}px`;
            container.style.height = `${height}px`;
          }
          return container;
        }
        get _commonActions() {
          const setColor = (jsName, styleName, event) => {
            const color = event.detail[jsName];
            event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
          };
          return (0, _util.shadow)(this, "_commonActions", {
            display: event => {
              const hidden = event.detail.display % 2 === 1;
              event.target.style.visibility = hidden ? "hidden" : "visible";
              this.annotationStorage.setValue(this.data.id, {
                hidden,
                print: event.detail.display === 0 || event.detail.display === 3
              });
            },
            print: event => {
              this.annotationStorage.setValue(this.data.id, {
                print: event.detail.print
              });
            },
            hidden: event => {
              event.target.style.visibility = event.detail.hidden ? "hidden" : "visible";
              this.annotationStorage.setValue(this.data.id, {
                hidden: event.detail.hidden
              });
            },
            focus: event => {
              setTimeout(() => event.target.focus({
                preventScroll: false
              }), 0);
            },
            userName: event => {
              event.target.title = event.detail.userName;
            },
            readonly: event => {
              if (event.detail.readonly) {
                event.target.setAttribute("readonly", "");
              } else {
                event.target.removeAttribute("readonly");
              }
            },
            required: event => {
              if (event.detail.required) {
                event.target.setAttribute("required", "");
              } else {
                event.target.removeAttribute("required");
              }
            },
            bgColor: event => {
              setColor("bgColor", "backgroundColor", event);
            },
            fillColor: event => {
              setColor("fillColor", "backgroundColor", event);
            },
            fgColor: event => {
              setColor("fgColor", "color", event);
            },
            textColor: event => {
              setColor("textColor", "color", event);
            },
            borderColor: event => {
              setColor("borderColor", "borderColor", event);
            },
            strokeColor: event => {
              setColor("strokeColor", "borderColor", event);
            }
          });
        }
        _dispatchEventFromSandbox(actions, jsEvent) {
          const commonActions = this._commonActions;
          for (const name of Object.keys(jsEvent.detail)) {
            const action = actions[name] || commonActions[name];
            if (action) {
              action(jsEvent);
            }
          }
        }
        _setDefaultPropertiesFromJS(element) {
          if (!this.enableScripting) {
            return;
          }
          const storedData = this.annotationStorage.getRawValue(this.data.id);
          if (!storedData) {
            return;
          }
          const commonActions = this._commonActions;
          for (const [actionName, detail] of Object.entries(storedData)) {
            const action = commonActions[actionName];
            if (action) {
              action({
                detail,
                target: element
              });
              delete storedData[actionName];
            }
          }
        }
        _createQuadrilaterals(ignoreBorder = false) {
          if (!this.data.quadPoints) {
            return null;
          }
          const quadrilaterals = [];
          const savedRect = this.data.rect;
          for (const quadPoint of this.data.quadPoints) {
            this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
            quadrilaterals.push(this._createContainer(ignoreBorder));
          }
          this.data.rect = savedRect;
          return quadrilaterals;
        }
        _createPopup(trigger, data) {
          let container = this.container;
          if (this.quadrilaterals) {
            trigger = trigger || this.quadrilaterals;
            container = this.quadrilaterals[0];
          }
          if (!trigger) {
            trigger = document.createElement("div");
            trigger.style.height = container.style.height;
            trigger.style.width = container.style.width;
            container.appendChild(trigger);
          }
          const popupElement = new PopupElement({
            container,
            trigger,
            color: data.color,
            titleObj: data.titleObj,
            modificationDate: data.modificationDate,
            contentsObj: data.contentsObj,
            richText: data.richText,
            hideWrapper: true
          });
          const popup = popupElement.render();
          popup.style.left = container.style.width;
          container.appendChild(popup);
        }
        _renderQuadrilaterals(className) {
          for (const quadrilateral of this.quadrilaterals) {
            quadrilateral.className = className;
          }
          return this.quadrilaterals;
        }
        render() {
          (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
        }
        _getElementsByName(name, skipId = null) {
          const fields = [];
          if (this._fieldObjects) {
            const fieldObj = this._fieldObjects[name];
            if (fieldObj) {
              for (const {
                page,
                id,
                exportValues
              } of fieldObj) {
                if (page === -1) {
                  continue;
                }
                if (id === skipId) {
                  continue;
                }
                const exportValue = typeof exportValues === "string" ? exportValues : null;
                const domElement = document.getElementById(id);
                if (domElement && !GetElementsByNameSet.has(domElement)) {
                  (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);
                  continue;
                }
                fields.push({
                  id,
                  exportValue,
                  domElement
                });
              }
            }
            return fields;
          }
          for (const domElement of document.getElementsByName(name)) {
            const {
              id,
              exportValue
            } = domElement;
            if (id === skipId) {
              continue;
            }
            if (!GetElementsByNameSet.has(domElement)) {
              continue;
            }
            fields.push({
              id,
              exportValue,
              domElement
            });
          }
          return fields;
        }
        static get platform() {
          const platform = typeof navigator !== "undefined" ? navigator.platform : "";
          return (0, _util.shadow)(this, "platform", {
            isWin: platform.includes("Win"),
            isMac: platform.includes("Mac")
          });
        }
      }
      class LinkAnnotationElement extends AnnotationElement {
        constructor(parameters, options = null) {
          const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.resetForm || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
          super(parameters, {
            isRenderable,
            ignoreBorder: !!(options !== null && options !== void 0 && options.ignoreBorder),
            createQuadrilaterals: true
          });
        }
        render() {
          const {
            data,
            linkService
          } = this;
          const link = document.createElement("a");
          if (data.url) {
            linkService.addLinkAttributes(link, data.url, data.newWindow);
          } else if (data.action) {
            this._bindNamedAction(link, data.action);
          } else if (data.dest) {
            this._bindLink(link, data.dest);
          } else {
            let hasClickAction = false;
            if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
              hasClickAction = true;
              this._bindJSAction(link, data);
            }
            if (data.resetForm) {
              this._bindResetFormAction(link, data.resetForm);
            } else if (!hasClickAction) {
              this._bindLink(link, "");
            }
          }
          if (this.quadrilaterals) {
            return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
              const linkElement = index === 0 ? link : link.cloneNode();
              quadrilateral.appendChild(linkElement);
              return quadrilateral;
            });
          }
          this.container.className = "linkAnnotation";
          this.container.appendChild(link);
          return this.container;
        }
        _bindLink(link, destination) {
          link.href = this.linkService.getDestinationHash(destination);
          link.onclick = () => {
            if (destination) {
              this.linkService.goToDestination(destination);
            }
            return false;
          };
          if (destination || destination === "") {
            link.className = "internalLink";
          }
        }
        _bindNamedAction(link, action) {
          link.href = this.linkService.getAnchorUrl("");
          link.onclick = () => {
            this.linkService.executeNamedAction(action);
            return false;
          };
          link.className = "internalLink";
        }
        _bindJSAction(link, data) {
          link.href = this.linkService.getAnchorUrl("");
          const map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
          for (const name of Object.keys(data.actions)) {
            const jsName = map.get(name);
            if (!jsName) {
              continue;
            }
            link[jsName] = () => {
              var _this$linkService$eve;
              (_this$linkService$eve = this.linkService.eventBus) === null || _this$linkService$eve === void 0 ? void 0 : _this$linkService$eve.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: data.id,
                  name
                }
              });
              return false;
            };
          }
          if (!link.onclick) {
            link.onclick = () => false;
          }
          link.className = "internalLink";
        }
        _bindResetFormAction(link, resetForm) {
          const otherClickAction = link.onclick;
          if (!otherClickAction) {
            link.href = this.linkService.getAnchorUrl("");
          }
          link.className = "internalLink";
          if (!this._fieldObjects) {
            (0, _util.warn)(`_bindResetFormAction - "resetForm" action not supported, ` + "ensure that the `fieldObjects` parameter is provided.");
            if (!otherClickAction) {
              link.onclick = () => false;
            }
            return;
          }
          link.onclick = () => {
            if (otherClickAction) {
              otherClickAction();
            }
            const {
              fields: resetFormFields,
              refs: resetFormRefs,
              include
            } = resetForm;
            const allFields = [];
            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
              const fieldIds = new Set(resetFormRefs);
              for (const fieldName of resetFormFields) {
                const fields = this._fieldObjects[fieldName] || [];
                for (const {
                  id
                } of fields) {
                  fieldIds.add(id);
                }
              }
              for (const fields of Object.values(this._fieldObjects)) {
                for (const field of fields) {
                  if (fieldIds.has(field.id) === include) {
                    allFields.push(field);
                  }
                }
              }
            } else {
              for (const fields of Object.values(this._fieldObjects)) {
                allFields.push(...fields);
              }
            }
            const storage = this.annotationStorage;
            const allIds = [];
            for (const field of allFields) {
              const {
                id
              } = field;
              allIds.push(id);
              switch (field.type) {
                case "text":
                  {
                    const value = field.defaultValue || "";
                    storage.setValue(id, {
                      value
                    });
                    break;
                  }
                case "checkbox":
                case "radiobutton":
                  {
                    const value = field.defaultValue === field.exportValues;
                    storage.setValue(id, {
                      value
                    });
                    break;
                  }
                case "combobox":
                case "listbox":
                  {
                    const value = field.defaultValue || "";
                    storage.setValue(id, {
                      value
                    });
                    break;
                  }
                default:
                  continue;
              }
              const domElement = document.getElementById(id);
              if (!domElement || !GetElementsByNameSet.has(domElement)) {
                continue;
              }
              domElement.dispatchEvent(new Event("resetform"));
            }
            if (this.enableScripting) {
              var _this$linkService$eve2;
              (_this$linkService$eve2 = this.linkService.eventBus) === null || _this$linkService$eve2 === void 0 ? void 0 : _this$linkService$eve2.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: "app",
                  ids: allIds,
                  name: "ResetForm"
                }
              });
            }
            return false;
          };
        }
      }
      class TextAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl, _parameters$data$cont, _parameters$data$rich;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl = parameters.data.titleObj) !== null && _parameters$data$titl !== void 0 && _parameters$data$titl.str || (_parameters$data$cont = parameters.data.contentsObj) !== null && _parameters$data$cont !== void 0 && _parameters$data$cont.str || (_parameters$data$rich = parameters.data.richText) !== null && _parameters$data$rich !== void 0 && _parameters$data$rich.str);
          super(parameters, {
            isRenderable
          });
        }
        render() {
          this.container.className = "textAnnotation";
          const image = document.createElement("img");
          image.style.height = this.container.style.height;
          image.style.width = this.container.style.width;
          image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
          image.alt = "[{{type}} Annotation]";
          image.dataset.l10nId = "text_annotation_type";
          image.dataset.l10nArgs = JSON.stringify({
            type: this.data.name
          });
          if (!this.data.hasPopup) {
            this._createPopup(image, this.data);
          }
          this.container.appendChild(image);
          return this.container;
        }
      }
      class WidgetAnnotationElement extends AnnotationElement {
        render() {
          if (this.data.alternativeText) {
            this.container.title = this.data.alternativeText;
          }
          return this.container;
        }
        _getKeyModifier(event) {
          const {
            isWin,
            isMac
          } = AnnotationElement.platform;
          return isWin && event.ctrlKey || isMac && event.metaKey;
        }
        _setEventListener(element, baseName, eventName, valueGetter) {
          if (baseName.includes("mouse")) {
            element.addEventListener(baseName, event => {
              var _this$linkService$eve3;
              (_this$linkService$eve3 = this.linkService.eventBus) === null || _this$linkService$eve3 === void 0 ? void 0 : _this$linkService$eve3.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: this.data.id,
                  name: eventName,
                  value: valueGetter(event),
                  shift: event.shiftKey,
                  modifier: this._getKeyModifier(event)
                }
              });
            });
          } else {
            element.addEventListener(baseName, event => {
              var _this$linkService$eve4;
              (_this$linkService$eve4 = this.linkService.eventBus) === null || _this$linkService$eve4 === void 0 ? void 0 : _this$linkService$eve4.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: this.data.id,
                  name: eventName,
                  value: valueGetter(event)
                }
              });
            });
          }
        }
        _setEventListeners(element, names, getter) {
          for (const [baseName, eventName] of names) {
            var _this$data$actions;
            if (eventName === "Action" || (_this$data$actions = this.data.actions) !== null && _this$data$actions !== void 0 && _this$data$actions[eventName]) {
              this._setEventListener(element, baseName, eventName, getter);
            }
          }
        }
        _setBackgroundColor(element) {
          const color = this.data.backgroundColor || null;
          element.style.backgroundColor = color === null ? "transparent" : _util.Util.makeHexColor(color[0], color[1], color[2]);
        }
      }
      class TextWidgetAnnotationElement extends WidgetAnnotationElement {
        constructor(parameters) {
          const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
          super(parameters, {
            isRenderable
          });
        }
        setPropertyOnSiblings(base, key, value, keyInStorage) {
          const storage = this.annotationStorage;
          for (const element of this._getElementsByName(base.name, base.id)) {
            if (element.domElement) {
              element.domElement[key] = value;
            }
            storage.setValue(element.id, {
              [keyInStorage]: value
            });
          }
        }
        render() {
          const storage = this.annotationStorage;
          const id = this.data.id;
          this.container.className = "textWidgetAnnotation";
          let element = null;
          if (this.renderForms) {
            const storedData = storage.getValue(id, {
              value: this.data.fieldValue
            });
            const textContent = storedData.formattedValue || storedData.value || "";
            const elementData = {
              userValue: null,
              formattedValue: null,
              valueOnFocus: ""
            };
            if (this.data.multiLine) {
              element = document.createElement("textarea");
              element.textContent = textContent;
            } else {
              element = document.createElement("input");
              element.type = "text";
              element.setAttribute("value", textContent);
            }
            GetElementsByNameSet.add(element);
            element.disabled = this.data.readOnly;
            element.name = this.data.fieldName;
            element.tabIndex = DEFAULT_TAB_INDEX;
            elementData.userValue = textContent;
            element.setAttribute("id", id);
            element.addEventListener("input", event => {
              storage.setValue(id, {
                value: event.target.value
              });
              this.setPropertyOnSiblings(element, "value", event.target.value, "value");
            });
            element.addEventListener("resetform", event => {
              var _this$data$defaultFie;
              const defaultValue = (_this$data$defaultFie = this.data.defaultFieldValue) !== null && _this$data$defaultFie !== void 0 ? _this$data$defaultFie : "";
              element.value = elementData.userValue = defaultValue;
              elementData.formattedValue = null;
            });
            let blurListener = event => {
              const {
                formattedValue
              } = elementData;
              if (formattedValue !== null && formattedValue !== undefined) {
                event.target.value = formattedValue;
              }
              event.target.scrollLeft = 0;
            };
            if (this.enableScripting && this.hasJSActions) {
              var _this$data$actions2;
              element.addEventListener("focus", event => {
                if (elementData.userValue) {
                  event.target.value = elementData.userValue;
                }
                elementData.valueOnFocus = event.target.value;
              });
              element.addEventListener("updatefromsandbox", jsEvent => {
                const actions = {
                  value(event) {
                    var _event$detail$value;
                    elementData.userValue = (_event$detail$value = event.detail.value) !== null && _event$detail$value !== void 0 ? _event$detail$value : "";
                    storage.setValue(id, {
                      value: elementData.userValue.toString()
                    });
                    event.target.value = elementData.userValue;
                  },
                  formattedValue(event) {
                    const {
                      formattedValue
                    } = event.detail;
                    elementData.formattedValue = formattedValue;
                    if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {
                      event.target.value = formattedValue;
                    }
                    storage.setValue(id, {
                      formattedValue
                    });
                  },
                  selRange(event) {
                    event.target.setSelectionRange(...event.detail.selRange);
                  }
                };
                this._dispatchEventFromSandbox(actions, jsEvent);
              });
              element.addEventListener("keydown", event => {
                var _this$linkService$eve5;
                let commitKey = -1;
                if (event.key === "Escape") {
                  commitKey = 0;
                } else if (event.key === "Enter") {
                  commitKey = 2;
                } else if (event.key === "Tab") {
                  commitKey = 3;
                }
                if (commitKey === -1) {
                  return;
                }
                const {
                  value
                } = event.target;
                if (elementData.valueOnFocus === value) {
                  return;
                }
                elementData.userValue = value;
                (_this$linkService$eve5 = this.linkService.eventBus) === null || _this$linkService$eve5 === void 0 ? void 0 : _this$linkService$eve5.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id,
                    name: "Keystroke",
                    value,
                    willCommit: true,
                    commitKey,
                    selStart: event.target.selectionStart,
                    selEnd: event.target.selectionEnd
                  }
                });
              });
              const _blurListener = blurListener;
              blurListener = null;
              element.addEventListener("blur", event => {
                const {
                  value
                } = event.target;
                elementData.userValue = value;
                if (this._mouseState.isDown && elementData.valueOnFocus !== value) {
                  var _this$linkService$eve6;
                  (_this$linkService$eve6 = this.linkService.eventBus) === null || _this$linkService$eve6 === void 0 ? void 0 : _this$linkService$eve6.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id,
                      name: "Keystroke",
                      value,
                      willCommit: true,
                      commitKey: 1,
                      selStart: event.target.selectionStart,
                      selEnd: event.target.selectionEnd
                    }
                  });
                }
                _blurListener(event);
              });
              if ((_this$data$actions2 = this.data.actions) !== null && _this$data$actions2 !== void 0 && _this$data$actions2.Keystroke) {
                element.addEventListener("beforeinput", event => {
                  var _this$linkService$eve7;
                  const {
                    data,
                    target
                  } = event;
                  const {
                    value,
                    selectionStart,
                    selectionEnd
                  } = target;
                  let selStart = selectionStart,
                    selEnd = selectionEnd;
                  switch (event.inputType) {
                    case "deleteWordBackward":
                      {
                        const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                        if (match) {
                          selStart -= match[0].length;
                        }
                        break;
                      }
                    case "deleteWordForward":
                      {
                        const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                        if (match) {
                          selEnd += match[0].length;
                        }
                        break;
                      }
                    case "deleteContentBackward":
                      if (selectionStart === selectionEnd) {
                        selStart -= 1;
                      }
                      break;
                    case "deleteContentForward":
                      if (selectionStart === selectionEnd) {
                        selEnd += 1;
                      }
                      break;
                  }
                  event.preventDefault();
                  (_this$linkService$eve7 = this.linkService.eventBus) === null || _this$linkService$eve7 === void 0 ? void 0 : _this$linkService$eve7.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id,
                      name: "Keystroke",
                      value,
                      change: data || "",
                      willCommit: false,
                      selStart,
                      selEnd
                    }
                  });
                });
              }
              this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.value);
            }
            if (blurListener) {
              element.addEventListener("blur", blurListener);
            }
            if (this.data.maxLen !== null) {
              element.maxLength = this.data.maxLen;
            }
            if (this.data.comb) {
              const fieldWidth = this.data.rect[2] - this.data.rect[0];
              const combWidth = fieldWidth / this.data.maxLen;
              element.classList.add("comb");
              element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;
            }
          } else {
            element = document.createElement("div");
            element.textContent = this.data.fieldValue;
            element.style.verticalAlign = "middle";
            element.style.display = "table-cell";
          }
          this._setTextStyle(element);
          this._setBackgroundColor(element);
          this._setDefaultPropertiesFromJS(element);
          this.container.appendChild(element);
          return this.container;
        }
        _setTextStyle(element) {
          const TEXT_ALIGNMENT = ["left", "center", "right"];
          const {
            fontSize,
            fontColor
          } = this.data.defaultAppearanceData;
          const style = element.style;
          if (fontSize) {
            style.fontSize = `${fontSize}px`;
          }
          style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
          if (this.data.textAlignment !== null) {
            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
          }
        }
      }
      class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
        constructor(parameters) {
          super(parameters, {
            isRenderable: parameters.renderForms
          });
        }
        render() {
          const storage = this.annotationStorage;
          const data = this.data;
          const id = data.id;
          let value = storage.getValue(id, {
            value: data.exportValue === data.fieldValue
          }).value;
          if (typeof value === "string") {
            value = value !== "Off";
            storage.setValue(id, {
              value
            });
          }
          this.container.className = "buttonWidgetAnnotation checkBox";
          const element = document.createElement("input");
          GetElementsByNameSet.add(element);
          element.disabled = data.readOnly;
          element.type = "checkbox";
          element.name = data.fieldName;
          if (value) {
            element.setAttribute("checked", true);
          }
          element.setAttribute("id", id);
          element.setAttribute("exportValue", data.exportValue);
          element.tabIndex = DEFAULT_TAB_INDEX;
          element.addEventListener("change", event => {
            const {
              name,
              checked
            } = event.target;
            for (const checkbox of this._getElementsByName(name, id)) {
              const curChecked = checked && checkbox.exportValue === data.exportValue;
              if (checkbox.domElement) {
                checkbox.domElement.checked = curChecked;
              }
              storage.setValue(checkbox.id, {
                value: curChecked
              });
            }
            storage.setValue(id, {
              value: checked
            });
          });
          element.addEventListener("resetform", event => {
            const defaultValue = data.defaultFieldValue || "Off";
            event.target.checked = defaultValue === data.exportValue;
          });
          if (this.enableScripting && this.hasJSActions) {
            element.addEventListener("updatefromsandbox", jsEvent => {
              const actions = {
                value(event) {
                  event.target.checked = event.detail.value !== "Off";
                  storage.setValue(id, {
                    value: event.target.checked
                  });
                }
              };
              this._dispatchEventFromSandbox(actions, jsEvent);
            });
            this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
          }
          this._setBackgroundColor(element);
          this._setDefaultPropertiesFromJS(element);
          this.container.appendChild(element);
          return this.container;
        }
      }
      class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
        constructor(parameters) {
          super(parameters, {
            isRenderable: parameters.renderForms
          });
        }
        render() {
          this.container.className = "buttonWidgetAnnotation radioButton";
          const storage = this.annotationStorage;
          const data = this.data;
          const id = data.id;
          let value = storage.getValue(id, {
            value: data.fieldValue === data.buttonValue
          }).value;
          if (typeof value === "string") {
            value = value !== data.buttonValue;
            storage.setValue(id, {
              value
            });
          }
          const element = document.createElement("input");
          GetElementsByNameSet.add(element);
          element.disabled = data.readOnly;
          element.type = "radio";
          element.name = data.fieldName;
          if (value) {
            element.setAttribute("checked", true);
          }
          element.setAttribute("id", id);
          element.tabIndex = DEFAULT_TAB_INDEX;
          element.addEventListener("change", event => {
            const {
              name,
              checked
            } = event.target;
            for (const radio of this._getElementsByName(name, id)) {
              storage.setValue(radio.id, {
                value: false
              });
            }
            storage.setValue(id, {
              value: checked
            });
          });
          element.addEventListener("resetform", event => {
            const defaultValue = data.defaultFieldValue;
            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
          });
          if (this.enableScripting && this.hasJSActions) {
            const pdfButtonValue = data.buttonValue;
            element.addEventListener("updatefromsandbox", jsEvent => {
              const actions = {
                value: event => {
                  const checked = pdfButtonValue === event.detail.value;
                  for (const radio of this._getElementsByName(event.target.name)) {
                    const curChecked = checked && radio.id === id;
                    if (radio.domElement) {
                      radio.domElement.checked = curChecked;
                    }
                    storage.setValue(radio.id, {
                      value: curChecked
                    });
                  }
                }
              };
              this._dispatchEventFromSandbox(actions, jsEvent);
            });
            this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
          }
          this._setBackgroundColor(element);
          this._setDefaultPropertiesFromJS(element);
          this.container.appendChild(element);
          return this.container;
        }
      }
      class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
        constructor(parameters) {
          super(parameters, {
            ignoreBorder: parameters.data.hasAppearance
          });
        }
        render() {
          const container = super.render();
          container.className = "buttonWidgetAnnotation pushButton";
          if (this.data.alternativeText) {
            container.title = this.data.alternativeText;
          }
          this._setDefaultPropertiesFromJS(container);
          return container;
        }
      }
      class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
        constructor(parameters) {
          super(parameters, {
            isRenderable: parameters.renderForms
          });
        }
        render() {
          this.container.className = "choiceWidgetAnnotation";
          const storage = this.annotationStorage;
          const id = this.data.id;
          const storedData = storage.getValue(id, {
            value: this.data.fieldValue
          });
          let {
            fontSize
          } = this.data.defaultAppearanceData;
          if (!fontSize) {
            fontSize = 9;
          }
          const fontSizeStyle = `calc(${fontSize}px * var(--zoom-factor))`;
          const selectElement = document.createElement("select");
          GetElementsByNameSet.add(selectElement);
          selectElement.disabled = this.data.readOnly;
          selectElement.name = this.data.fieldName;
          selectElement.setAttribute("id", id);
          selectElement.tabIndex = DEFAULT_TAB_INDEX;
          selectElement.style.fontSize = `${fontSize}px`;
          if (!this.data.combo) {
            selectElement.size = this.data.options.length;
            if (this.data.multiSelect) {
              selectElement.multiple = true;
            }
          }
          selectElement.addEventListener("resetform", event => {
            const defaultValue = this.data.defaultFieldValue;
            for (const option of selectElement.options) {
              option.selected = option.value === defaultValue;
            }
          });
          for (const option of this.data.options) {
            const optionElement = document.createElement("option");
            optionElement.textContent = option.displayValue;
            optionElement.value = option.exportValue;
            if (this.data.combo) {
              optionElement.style.fontSize = fontSizeStyle;
            }
            if (storedData.value.includes(option.exportValue)) {
              optionElement.setAttribute("selected", true);
            }
            selectElement.appendChild(optionElement);
          }
          const getValue = (event, isExport) => {
            const name = isExport ? "value" : "textContent";
            const options = event.target.options;
            if (!event.target.multiple) {
              return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
            }
            return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);
          };
          const getItems = event => {
            const options = event.target.options;
            return Array.prototype.map.call(options, option => {
              return {
                displayValue: option.textContent,
                exportValue: option.value
              };
            });
          };
          if (this.enableScripting && this.hasJSActions) {
            selectElement.addEventListener("updatefromsandbox", jsEvent => {
              const actions = {
                value(event) {
                  const value = event.detail.value;
                  const values = new Set(Array.isArray(value) ? value : [value]);
                  for (const option of selectElement.options) {
                    option.selected = values.has(option.value);
                  }
                  storage.setValue(id, {
                    value: getValue(event, true)
                  });
                },
                multipleSelection(event) {
                  selectElement.multiple = true;
                },
                remove(event) {
                  const options = selectElement.options;
                  const index = event.detail.remove;
                  options[index].selected = false;
                  selectElement.remove(index);
                  if (options.length > 0) {
                    const i = Array.prototype.findIndex.call(options, option => option.selected);
                    if (i === -1) {
                      options[0].selected = true;
                    }
                  }
                  storage.setValue(id, {
                    value: getValue(event, true),
                    items: getItems(event)
                  });
                },
                clear(event) {
                  while (selectElement.length !== 0) {
                    selectElement.remove(0);
                  }
                  storage.setValue(id, {
                    value: null,
                    items: []
                  });
                },
                insert(event) {
                  const {
                    index,
                    displayValue,
                    exportValue
                  } = event.detail.insert;
                  const optionElement = document.createElement("option");
                  optionElement.textContent = displayValue;
                  optionElement.value = exportValue;
                  selectElement.insertBefore(optionElement, selectElement.children[index]);
                  storage.setValue(id, {
                    value: getValue(event, true),
                    items: getItems(event)
                  });
                },
                items(event) {
                  const {
                    items
                  } = event.detail;
                  while (selectElement.length !== 0) {
                    selectElement.remove(0);
                  }
                  for (const item of items) {
                    const {
                      displayValue,
                      exportValue
                    } = item;
                    const optionElement = document.createElement("option");
                    optionElement.textContent = displayValue;
                    optionElement.value = exportValue;
                    selectElement.appendChild(optionElement);
                  }
                  if (selectElement.options.length > 0) {
                    selectElement.options[0].selected = true;
                  }
                  storage.setValue(id, {
                    value: getValue(event, true),
                    items: getItems(event)
                  });
                },
                indices(event) {
                  const indices = new Set(event.detail.indices);
                  for (const option of event.target.options) {
                    option.selected = indices.has(option.index);
                  }
                  storage.setValue(id, {
                    value: getValue(event, true)
                  });
                },
                editable(event) {
                  event.target.disabled = !event.detail.editable;
                }
              };
              this._dispatchEventFromSandbox(actions, jsEvent);
            });
            selectElement.addEventListener("input", event => {
              var _this$linkService$eve8;
              const exportValue = getValue(event, true);
              const value = getValue(event, false);
              storage.setValue(id, {
                value: exportValue
              });
              (_this$linkService$eve8 = this.linkService.eventBus) === null || _this$linkService$eve8 === void 0 ? void 0 : _this$linkService$eve8.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value,
                  changeEx: exportValue,
                  willCommit: true,
                  commitKey: 1,
                  keyDown: false
                }
              });
            });
            this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], event => event.target.checked);
          } else {
            selectElement.addEventListener("input", function (event) {
              storage.setValue(id, {
                value: getValue(event, true)
              });
            });
          }
          this._setBackgroundColor(selectElement);
          this._setDefaultPropertiesFromJS(selectElement);
          this.container.appendChild(selectElement);
          return this.container;
        }
      }
      class PopupAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl2, _parameters$data$cont2, _parameters$data$rich2;
          const isRenderable = !!((_parameters$data$titl2 = parameters.data.titleObj) !== null && _parameters$data$titl2 !== void 0 && _parameters$data$titl2.str || (_parameters$data$cont2 = parameters.data.contentsObj) !== null && _parameters$data$cont2 !== void 0 && _parameters$data$cont2.str || (_parameters$data$rich2 = parameters.data.richText) !== null && _parameters$data$rich2 !== void 0 && _parameters$data$rich2.str);
          super(parameters, {
            isRenderable
          });
        }
        render() {
          const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
          this.container.className = "popupAnnotation";
          if (IGNORE_TYPES.includes(this.data.parentType)) {
            return this.container;
          }
          const selector = `[data-annotation-id="${this.data.parentId}"]`;
          const parentElements = this.layer.querySelectorAll(selector);
          if (parentElements.length === 0) {
            return this.container;
          }
          const popup = new PopupElement({
            container: this.container,
            trigger: Array.from(parentElements),
            color: this.data.color,
            titleObj: this.data.titleObj,
            modificationDate: this.data.modificationDate,
            contentsObj: this.data.contentsObj,
            richText: this.data.richText
          });
          const page = this.page;
          const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);
          const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
          const popupTop = rect[1];
          this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;
          this.container.style.left = `${popupLeft}px`;
          this.container.style.top = `${popupTop}px`;
          this.container.appendChild(popup.render());
          return this.container;
        }
      }
      class PopupElement {
        constructor(parameters) {
          this.container = parameters.container;
          this.trigger = parameters.trigger;
          this.color = parameters.color;
          this.titleObj = parameters.titleObj;
          this.modificationDate = parameters.modificationDate;
          this.contentsObj = parameters.contentsObj;
          this.richText = parameters.richText;
          this.hideWrapper = parameters.hideWrapper || false;
          this.pinned = false;
        }
        render() {
          var _this$richText, _this$contentsObj;
          const BACKGROUND_ENLIGHT = 0.7;
          const wrapper = document.createElement("div");
          wrapper.className = "popupWrapper";
          this.hideElement = this.hideWrapper ? wrapper : this.container;
          this.hideElement.hidden = true;
          const popup = document.createElement("div");
          popup.className = "popup";
          const color = this.color;
          if (color) {
            const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
            const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
            const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
            popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);
          }
          const title = document.createElement("h1");
          title.dir = this.titleObj.dir;
          title.textContent = this.titleObj.str;
          popup.appendChild(title);
          const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);
          if (dateObject) {
            const modificationDate = document.createElement("span");
            modificationDate.className = "popupDate";
            modificationDate.textContent = "{{date}}, {{time}}";
            modificationDate.dataset.l10nId = "annotation_date_string";
            modificationDate.dataset.l10nArgs = JSON.stringify({
              date: dateObject.toLocaleDateString(),
              time: dateObject.toLocaleTimeString()
            });
            popup.appendChild(modificationDate);
          }
          if ((_this$richText = this.richText) !== null && _this$richText !== void 0 && _this$richText.str && (!((_this$contentsObj = this.contentsObj) !== null && _this$contentsObj !== void 0 && _this$contentsObj.str) || this.contentsObj.str === this.richText.str)) {
            _xfa_layer.XfaLayer.render({
              xfaHtml: this.richText.html,
              intent: "richText",
              div: popup
            });
            popup.lastChild.className = "richText popupContent";
          } else {
            const contents = this._formatContents(this.contentsObj);
            popup.appendChild(contents);
          }
          if (!Array.isArray(this.trigger)) {
            this.trigger = [this.trigger];
          }
          for (const element of this.trigger) {
            element.addEventListener("click", this._toggle.bind(this));
            element.addEventListener("mouseover", this._show.bind(this, false));
            element.addEventListener("mouseout", this._hide.bind(this, false));
          }
          popup.addEventListener("click", this._hide.bind(this, true));
          wrapper.appendChild(popup);
          return wrapper;
        }
        _formatContents({
          str,
          dir
        }) {
          const p = document.createElement("p");
          p.className = "popupContent";
          p.dir = dir;
          const lines = str.split(/(?:\r\n?|\n)/);
          for (let i = 0, ii = lines.length; i < ii; ++i) {
            const line = lines[i];
            p.appendChild(document.createTextNode(line));
            if (i < ii - 1) {
              p.appendChild(document.createElement("br"));
            }
          }
          return p;
        }
        _toggle() {
          if (this.pinned) {
            this._hide(true);
          } else {
            this._show(true);
          }
        }
        _show(pin = false) {
          if (pin) {
            this.pinned = true;
          }
          if (this.hideElement.hidden) {
            this.hideElement.hidden = false;
            this.container.style.zIndex += 1;
          }
        }
        _hide(unpin = true) {
          if (unpin) {
            this.pinned = false;
          }
          if (!this.hideElement.hidden && !this.pinned) {
            this.hideElement.hidden = true;
            this.container.style.zIndex -= 1;
          }
        }
      }
      class FreeTextAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl3, _parameters$data$cont3, _parameters$data$rich3;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl3 = parameters.data.titleObj) !== null && _parameters$data$titl3 !== void 0 && _parameters$data$titl3.str || (_parameters$data$cont3 = parameters.data.contentsObj) !== null && _parameters$data$cont3 !== void 0 && _parameters$data$cont3.str || (_parameters$data$rich3 = parameters.data.richText) !== null && _parameters$data$rich3 !== void 0 && _parameters$data$rich3.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true
          });
        }
        render() {
          this.container.className = "freeTextAnnotation";
          if (!this.data.hasPopup) {
            this._createPopup(null, this.data);
          }
          return this.container;
        }
      }
      class LineAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl4, _parameters$data$cont4, _parameters$data$rich4;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl4 = parameters.data.titleObj) !== null && _parameters$data$titl4 !== void 0 && _parameters$data$titl4.str || (_parameters$data$cont4 = parameters.data.contentsObj) !== null && _parameters$data$cont4 !== void 0 && _parameters$data$cont4.str || (_parameters$data$rich4 = parameters.data.richText) !== null && _parameters$data$rich4 !== void 0 && _parameters$data$rich4.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true
          });
        }
        render() {
          this.container.className = "lineAnnotation";
          const data = this.data;
          const {
            width,
            height
          } = getRectDims(data.rect);
          const svg = this.svgFactory.create(width, height);
          const line = this.svgFactory.createElement("svg:line");
          line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
          line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
          line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
          line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
          line.setAttribute("stroke-width", data.borderStyle.width || 1);
          line.setAttribute("stroke", "transparent");
          line.setAttribute("fill", "transparent");
          svg.appendChild(line);
          this.container.append(svg);
          this._createPopup(line, data);
          return this.container;
        }
      }
      class SquareAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl5, _parameters$data$cont5, _parameters$data$rich5;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl5 = parameters.data.titleObj) !== null && _parameters$data$titl5 !== void 0 && _parameters$data$titl5.str || (_parameters$data$cont5 = parameters.data.contentsObj) !== null && _parameters$data$cont5 !== void 0 && _parameters$data$cont5.str || (_parameters$data$rich5 = parameters.data.richText) !== null && _parameters$data$rich5 !== void 0 && _parameters$data$rich5.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true
          });
        }
        render() {
          this.container.className = "squareAnnotation";
          const data = this.data;
          const {
            width,
            height
          } = getRectDims(data.rect);
          const svg = this.svgFactory.create(width, height);
          const borderWidth = data.borderStyle.width;
          const square = this.svgFactory.createElement("svg:rect");
          square.setAttribute("x", borderWidth / 2);
          square.setAttribute("y", borderWidth / 2);
          square.setAttribute("width", width - borderWidth);
          square.setAttribute("height", height - borderWidth);
          square.setAttribute("stroke-width", borderWidth || 1);
          square.setAttribute("stroke", "transparent");
          square.setAttribute("fill", "transparent");
          svg.appendChild(square);
          this.container.append(svg);
          this._createPopup(square, data);
          return this.container;
        }
      }
      class CircleAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl6, _parameters$data$cont6, _parameters$data$rich6;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl6 = parameters.data.titleObj) !== null && _parameters$data$titl6 !== void 0 && _parameters$data$titl6.str || (_parameters$data$cont6 = parameters.data.contentsObj) !== null && _parameters$data$cont6 !== void 0 && _parameters$data$cont6.str || (_parameters$data$rich6 = parameters.data.richText) !== null && _parameters$data$rich6 !== void 0 && _parameters$data$rich6.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true
          });
        }
        render() {
          this.container.className = "circleAnnotation";
          const data = this.data;
          const {
            width,
            height
          } = getRectDims(data.rect);
          const svg = this.svgFactory.create(width, height);
          const borderWidth = data.borderStyle.width;
          const circle = this.svgFactory.createElement("svg:ellipse");
          circle.setAttribute("cx", width / 2);
          circle.setAttribute("cy", height / 2);
          circle.setAttribute("rx", width / 2 - borderWidth / 2);
          circle.setAttribute("ry", height / 2 - borderWidth / 2);
          circle.setAttribute("stroke-width", borderWidth || 1);
          circle.setAttribute("stroke", "transparent");
          circle.setAttribute("fill", "transparent");
          svg.appendChild(circle);
          this.container.append(svg);
          this._createPopup(circle, data);
          return this.container;
        }
      }
      class PolylineAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl7, _parameters$data$cont7, _parameters$data$rich7;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl7 = parameters.data.titleObj) !== null && _parameters$data$titl7 !== void 0 && _parameters$data$titl7.str || (_parameters$data$cont7 = parameters.data.contentsObj) !== null && _parameters$data$cont7 !== void 0 && _parameters$data$cont7.str || (_parameters$data$rich7 = parameters.data.richText) !== null && _parameters$data$rich7 !== void 0 && _parameters$data$rich7.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true
          });
          this.containerClassName = "polylineAnnotation";
          this.svgElementName = "svg:polyline";
        }
        render() {
          this.container.className = this.containerClassName;
          const data = this.data;
          const {
            width,
            height
          } = getRectDims(data.rect);
          const svg = this.svgFactory.create(width, height);
          let points = [];
          for (const coordinate of data.vertices) {
            const x = coordinate.x - data.rect[0];
            const y = data.rect[3] - coordinate.y;
            points.push(x + "," + y);
          }
          points = points.join(" ");
          const polyline = this.svgFactory.createElement(this.svgElementName);
          polyline.setAttribute("points", points);
          polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
          polyline.setAttribute("stroke", "transparent");
          polyline.setAttribute("fill", "transparent");
          svg.appendChild(polyline);
          this.container.append(svg);
          this._createPopup(polyline, data);
          return this.container;
        }
      }
      class PolygonAnnotationElement extends PolylineAnnotationElement {
        constructor(parameters) {
          super(parameters);
          this.containerClassName = "polygonAnnotation";
          this.svgElementName = "svg:polygon";
        }
      }
      class CaretAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl8, _parameters$data$cont8, _parameters$data$rich8;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl8 = parameters.data.titleObj) !== null && _parameters$data$titl8 !== void 0 && _parameters$data$titl8.str || (_parameters$data$cont8 = parameters.data.contentsObj) !== null && _parameters$data$cont8 !== void 0 && _parameters$data$cont8.str || (_parameters$data$rich8 = parameters.data.richText) !== null && _parameters$data$rich8 !== void 0 && _parameters$data$rich8.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true
          });
        }
        render() {
          this.container.className = "caretAnnotation";
          if (!this.data.hasPopup) {
            this._createPopup(null, this.data);
          }
          return this.container;
        }
      }
      class InkAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl9, _parameters$data$cont9, _parameters$data$rich9;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl9 = parameters.data.titleObj) !== null && _parameters$data$titl9 !== void 0 && _parameters$data$titl9.str || (_parameters$data$cont9 = parameters.data.contentsObj) !== null && _parameters$data$cont9 !== void 0 && _parameters$data$cont9.str || (_parameters$data$rich9 = parameters.data.richText) !== null && _parameters$data$rich9 !== void 0 && _parameters$data$rich9.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true
          });
          this.containerClassName = "inkAnnotation";
          this.svgElementName = "svg:polyline";
        }
        render() {
          this.container.className = this.containerClassName;
          const data = this.data;
          const {
            width,
            height
          } = getRectDims(data.rect);
          const svg = this.svgFactory.create(width, height);
          for (const inkList of data.inkLists) {
            let points = [];
            for (const coordinate of inkList) {
              const x = coordinate.x - data.rect[0];
              const y = data.rect[3] - coordinate.y;
              points.push(`${x},${y}`);
            }
            points = points.join(" ");
            const polyline = this.svgFactory.createElement(this.svgElementName);
            polyline.setAttribute("points", points);
            polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
            polyline.setAttribute("stroke", "transparent");
            polyline.setAttribute("fill", "transparent");
            this._createPopup(polyline, data);
            svg.appendChild(polyline);
          }
          this.container.append(svg);
          return this.container;
        }
      }
      class HighlightAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl10, _parameters$data$cont10, _parameters$data$rich10;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl10 = parameters.data.titleObj) !== null && _parameters$data$titl10 !== void 0 && _parameters$data$titl10.str || (_parameters$data$cont10 = parameters.data.contentsObj) !== null && _parameters$data$cont10 !== void 0 && _parameters$data$cont10.str || (_parameters$data$rich10 = parameters.data.richText) !== null && _parameters$data$rich10 !== void 0 && _parameters$data$rich10.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true,
            createQuadrilaterals: true
          });
        }
        render() {
          if (!this.data.hasPopup) {
            this._createPopup(null, this.data);
          }
          if (this.quadrilaterals) {
            return this._renderQuadrilaterals("highlightAnnotation");
          }
          this.container.className = "highlightAnnotation";
          return this.container;
        }
      }
      class UnderlineAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl11, _parameters$data$cont11, _parameters$data$rich11;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl11 = parameters.data.titleObj) !== null && _parameters$data$titl11 !== void 0 && _parameters$data$titl11.str || (_parameters$data$cont11 = parameters.data.contentsObj) !== null && _parameters$data$cont11 !== void 0 && _parameters$data$cont11.str || (_parameters$data$rich11 = parameters.data.richText) !== null && _parameters$data$rich11 !== void 0 && _parameters$data$rich11.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true,
            createQuadrilaterals: true
          });
        }
        render() {
          if (!this.data.hasPopup) {
            this._createPopup(null, this.data);
          }
          if (this.quadrilaterals) {
            return this._renderQuadrilaterals("underlineAnnotation");
          }
          this.container.className = "underlineAnnotation";
          return this.container;
        }
      }
      class SquigglyAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl12, _parameters$data$cont12, _parameters$data$rich12;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl12 = parameters.data.titleObj) !== null && _parameters$data$titl12 !== void 0 && _parameters$data$titl12.str || (_parameters$data$cont12 = parameters.data.contentsObj) !== null && _parameters$data$cont12 !== void 0 && _parameters$data$cont12.str || (_parameters$data$rich12 = parameters.data.richText) !== null && _parameters$data$rich12 !== void 0 && _parameters$data$rich12.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true,
            createQuadrilaterals: true
          });
        }
        render() {
          if (!this.data.hasPopup) {
            this._createPopup(null, this.data);
          }
          if (this.quadrilaterals) {
            return this._renderQuadrilaterals("squigglyAnnotation");
          }
          this.container.className = "squigglyAnnotation";
          return this.container;
        }
      }
      class StrikeOutAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl13, _parameters$data$cont13, _parameters$data$rich13;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl13 = parameters.data.titleObj) !== null && _parameters$data$titl13 !== void 0 && _parameters$data$titl13.str || (_parameters$data$cont13 = parameters.data.contentsObj) !== null && _parameters$data$cont13 !== void 0 && _parameters$data$cont13.str || (_parameters$data$rich13 = parameters.data.richText) !== null && _parameters$data$rich13 !== void 0 && _parameters$data$rich13.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true,
            createQuadrilaterals: true
          });
        }
        render() {
          if (!this.data.hasPopup) {
            this._createPopup(null, this.data);
          }
          if (this.quadrilaterals) {
            return this._renderQuadrilaterals("strikeoutAnnotation");
          }
          this.container.className = "strikeoutAnnotation";
          return this.container;
        }
      }
      class StampAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _parameters$data$titl14, _parameters$data$cont14, _parameters$data$rich14;
          const isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl14 = parameters.data.titleObj) !== null && _parameters$data$titl14 !== void 0 && _parameters$data$titl14.str || (_parameters$data$cont14 = parameters.data.contentsObj) !== null && _parameters$data$cont14 !== void 0 && _parameters$data$cont14.str || (_parameters$data$rich14 = parameters.data.richText) !== null && _parameters$data$rich14 !== void 0 && _parameters$data$rich14.str);
          super(parameters, {
            isRenderable,
            ignoreBorder: true
          });
        }
        render() {
          this.container.className = "stampAnnotation";
          if (!this.data.hasPopup) {
            this._createPopup(null, this.data);
          }
          return this.container;
        }
      }
      class FileAttachmentAnnotationElement extends AnnotationElement {
        constructor(parameters) {
          var _this$linkService$eve9;
          super(parameters, {
            isRenderable: true
          });
          const {
            filename,
            content
          } = this.data.file;
          this.filename = (0, _display_utils.getFilenameFromUrl)(filename);
          this.content = content;
          (_this$linkService$eve9 = this.linkService.eventBus) === null || _this$linkService$eve9 === void 0 ? void 0 : _this$linkService$eve9.dispatch("fileattachmentannotation", {
            source: this,
            filename,
            content
          });
        }
        render() {
          var _this$data$titleObj, _this$data$contentsOb;
          this.container.className = "fileAttachmentAnnotation";
          const trigger = document.createElement("div");
          trigger.style.height = this.container.style.height;
          trigger.style.width = this.container.style.width;
          trigger.addEventListener("dblclick", this._download.bind(this));
          if (!this.data.hasPopup && ((_this$data$titleObj = this.data.titleObj) !== null && _this$data$titleObj !== void 0 && _this$data$titleObj.str || (_this$data$contentsOb = this.data.contentsObj) !== null && _this$data$contentsOb !== void 0 && _this$data$contentsOb.str || this.data.richText)) {
            this._createPopup(trigger, this.data);
          }
          this.container.appendChild(trigger);
          return this.container;
        }
        _download() {
          var _this$downloadManager;
          (_this$downloadManager = this.downloadManager) === null || _this$downloadManager === void 0 ? void 0 : _this$downloadManager.openOrDownloadData(this.container, this.content, this.filename);
        }
      }
      class AnnotationLayer {
        static render(parameters) {
          const sortedAnnotations = [],
            popupAnnotations = [];
          for (const data of parameters.annotations) {
            if (!data) {
              continue;
            }
            const {
              width,
              height
            } = getRectDims(data.rect);
            if (width <= 0 || height <= 0) {
              continue;
            }
            if (data.annotationType === _util.AnnotationType.POPUP) {
              popupAnnotations.push(data);
              continue;
            }
            sortedAnnotations.push(data);
          }
          if (popupAnnotations.length) {
            sortedAnnotations.push(...popupAnnotations);
          }
          const div = parameters.div;
          for (const data of sortedAnnotations) {
            const element = AnnotationElementFactory.create({
              data,
              layer: div,
              page: parameters.page,
              viewport: parameters.viewport,
              linkService: parameters.linkService,
              downloadManager: parameters.downloadManager,
              imageResourcesPath: parameters.imageResourcesPath || "",
              renderForms: parameters.renderForms !== false,
              svgFactory: new _display_utils.DOMSVGFactory(),
              annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),
              enableScripting: parameters.enableScripting,
              hasJSActions: parameters.hasJSActions,
              fieldObjects: parameters.fieldObjects,
              mouseState: parameters.mouseState || {
                isDown: false
              }
            });
            if (element.isRenderable) {
              const rendered = element.render();
              if (data.hidden) {
                rendered.style.visibility = "hidden";
              }
              if (Array.isArray(rendered)) {
                for (const renderedElement of rendered) {
                  div.appendChild(renderedElement);
                }
              } else {
                if (element instanceof PopupAnnotationElement) {
                  div.prepend(rendered);
                } else {
                  div.appendChild(rendered);
                }
              }
            }
          }
          _assertClassBrand(AnnotationLayer, this, _setAnnotationCanvasMap).call(this, div, parameters.annotationCanvasMap);
        }
        static update(parameters) {
          const {
            page,
            viewport,
            annotations,
            annotationCanvasMap,
            div
          } = parameters;
          const transform = viewport.transform;
          const matrix = `matrix(${transform.join(",")})`;
          let scale, ownMatrix;
          for (const data of annotations) {
            const elements = div.querySelectorAll(`[data-annotation-id="${data.id}"]`);
            if (elements) {
              for (const element of elements) {
                if (data.hasOwnCanvas) {
                  const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                  if (!ownMatrix) {
                    scale = Math.abs(transform[0] || transform[1]);
                    const ownTransform = transform.slice();
                    for (let i = 0; i < 4; i++) {
                      ownTransform[i] = Math.sign(ownTransform[i]);
                    }
                    ownMatrix = `matrix(${ownTransform.join(",")})`;
                  }
                  const left = rect[0] * scale;
                  const top = rect[1] * scale;
                  element.style.left = `${left}px`;
                  element.style.top = `${top}px`;
                  element.style.transformOrigin = `${-left}px ${-top}px`;
                  element.style.transform = ownMatrix;
                } else {
                  element.style.transform = matrix;
                }
              }
            }
          }
          _assertClassBrand(AnnotationLayer, this, _setAnnotationCanvasMap).call(this, div, annotationCanvasMap);
          div.hidden = false;
        }
      }
      function _setAnnotationCanvasMap(div, annotationCanvasMap) {
        if (!annotationCanvasMap) {
          return;
        }
        for (const [id, canvas] of annotationCanvasMap) {
          const element = div.querySelector(`[data-annotation-id="${id}"]`);
          if (!element) {
            continue;
          }
          const {
            firstChild
          } = element;
          if (firstChild.nodeName === "CANVAS") {
            element.replaceChild(canvas, firstChild);
          } else {
            element.insertBefore(canvas, firstChild);
          }
        }
        annotationCanvasMap.clear();
      }
      exports.AnnotationLayer = AnnotationLayer;

      /***/
    }), ( /* 21 */
    /***/(__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.ColorConverters = void 0;
      function makeColorComp(n) {
        return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
      }
      class ColorConverters {
        static CMYK_G([c, y, m, k]) {
          return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
        }
        static G_CMYK([g]) {
          return ["CMYK", 0, 0, 0, 1 - g];
        }
        static G_RGB([g]) {
          return ["RGB", g, g, g];
        }
        static G_HTML([g]) {
          const G = makeColorComp(g);
          return `#${G}${G}${G}`;
        }
        static RGB_G([r, g, b]) {
          return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
        }
        static RGB_HTML([r, g, b]) {
          const R = makeColorComp(r);
          const G = makeColorComp(g);
          const B = makeColorComp(b);
          return `#${R}${G}${B}`;
        }
        static T_HTML() {
          return "#00000000";
        }
        static CMYK_RGB([c, y, m, k]) {
          return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
        }
        static CMYK_HTML(components) {
          return this.RGB_HTML(this.CMYK_RGB(components));
        }
        static RGB_CMYK([r, g, b]) {
          const c = 1 - r;
          const m = 1 - g;
          const y = 1 - b;
          const k = Math.min(c, m, y);
          return ["CMYK", c, m, y, k];
        }
      }
      exports.ColorConverters = ColorConverters;

      /***/
    }), ( /* 22 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.XfaLayer = void 0;
      var _xfa_text = __w_pdfjs_require__(18);
      class XfaLayer {
        static setupStorage(html, id, element, storage, intent) {
          const storedData = storage.getValue(id, {
            value: null
          });
          switch (element.name) {
            case "textarea":
              if (storedData.value !== null) {
                html.textContent = storedData.value;
              }
              if (intent === "print") {
                break;
              }
              html.addEventListener("input", event => {
                storage.setValue(id, {
                  value: event.target.value
                });
              });
              break;
            case "input":
              if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                if (storedData.value === element.attributes.xfaOn) {
                  html.setAttribute("checked", true);
                } else if (storedData.value === element.attributes.xfaOff) {
                  html.removeAttribute("checked");
                }
                if (intent === "print") {
                  break;
                }
                html.addEventListener("change", event => {
                  storage.setValue(id, {
                    value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                  });
                });
              } else {
                if (storedData.value !== null) {
                  html.setAttribute("value", storedData.value);
                }
                if (intent === "print") {
                  break;
                }
                html.addEventListener("input", event => {
                  storage.setValue(id, {
                    value: event.target.value
                  });
                });
              }
              break;
            case "select":
              if (storedData.value !== null) {
                for (const option of element.children) {
                  if (option.attributes.value === storedData.value) {
                    option.attributes.selected = true;
                  }
                }
              }
              html.addEventListener("input", event => {
                const options = event.target.options;
                const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                storage.setValue(id, {
                  value
                });
              });
              break;
          }
        }
        static setAttributes({
          html,
          element,
          storage = null,
          intent,
          linkService
        }) {
          const {
            attributes
          } = element;
          const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
          if (attributes.type === "radio") {
            attributes.name = `${attributes.name}-${intent}`;
          }
          for (const [key, value] of Object.entries(attributes)) {
            if (value === null || value === undefined || key === "dataId") {
              continue;
            }
            if (key !== "style") {
              if (key === "textContent") {
                html.textContent = value;
              } else if (key === "class") {
                if (value.length) {
                  html.setAttribute(key, value.join(" "));
                }
              } else {
                if (isHTMLAnchorElement && (key === "href" || key === "newWindow")) {
                  continue;
                }
                html.setAttribute(key, value);
              }
            } else {
              Object.assign(html.style, value);
            }
          }
          if (isHTMLAnchorElement) {
            linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
          }
          if (storage && attributes.dataId) {
            this.setupStorage(html, attributes.dataId, element, storage);
          }
        }
        static render(parameters) {
          const storage = parameters.annotationStorage;
          const linkService = parameters.linkService;
          const root = parameters.xfaHtml;
          const intent = parameters.intent || "display";
          const rootHtml = document.createElement(root.name);
          if (root.attributes) {
            this.setAttributes({
              html: rootHtml,
              element: root,
              intent,
              linkService
            });
          }
          const stack = [[root, -1, rootHtml]];
          const rootDiv = parameters.div;
          rootDiv.appendChild(rootHtml);
          if (parameters.viewport) {
            const transform = `matrix(${parameters.viewport.transform.join(",")})`;
            rootDiv.style.transform = transform;
          }
          if (intent !== "richText") {
            rootDiv.setAttribute("class", "xfaLayer xfaFont");
          }
          const textDivs = [];
          while (stack.length > 0) {
            var _child$attributes;
            const [parent, i, html] = stack[stack.length - 1];
            if (i + 1 === parent.children.length) {
              stack.pop();
              continue;
            }
            const child = parent.children[++stack[stack.length - 1][1]];
            if (child === null) {
              continue;
            }
            const {
              name
            } = child;
            if (name === "#text") {
              const node = document.createTextNode(child.value);
              textDivs.push(node);
              html.appendChild(node);
              continue;
            }
            let childHtml;
            if (child !== null && child !== void 0 && (_child$attributes = child.attributes) !== null && _child$attributes !== void 0 && _child$attributes.xmlns) {
              childHtml = document.createElementNS(child.attributes.xmlns, name);
            } else {
              childHtml = document.createElement(name);
            }
            html.appendChild(childHtml);
            if (child.attributes) {
              this.setAttributes({
                html: childHtml,
                element: child,
                storage,
                intent,
                linkService
              });
            }
            if (child.children && child.children.length > 0) {
              stack.push([child, -1, childHtml]);
            } else if (child.value) {
              const node = document.createTextNode(child.value);
              if (_xfa_text.XfaText.shouldBuildText(name)) {
                textDivs.push(node);
              }
              childHtml.appendChild(node);
            }
          }
          for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
            el.setAttribute("readOnly", true);
          }
          return {
            textDivs
          };
        }
        static update(parameters) {
          const transform = `matrix(${parameters.viewport.transform.join(",")})`;
          parameters.div.style.transform = transform;
          parameters.div.hidden = false;
        }
      }
      exports.XfaLayer = XfaLayer;

      /***/
    }), ( /* 23 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.renderTextLayer = renderTextLayer;
      var _util = __w_pdfjs_require__(1);
      const MAX_TEXT_DIVS_TO_RENDER = 100000;
      const DEFAULT_FONT_SIZE = 30;
      const DEFAULT_FONT_ASCENT = 0.8;
      const ascentCache = new Map();
      const AllWhitespaceRegexp = /^\s+$/g;
      function getAscent(fontFamily, ctx) {
        const cachedAscent = ascentCache.get(fontFamily);
        if (cachedAscent) {
          return cachedAscent;
        }
        ctx.save();
        ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
        const metrics = ctx.measureText("");
        let ascent = metrics.fontBoundingBoxAscent;
        let descent = Math.abs(metrics.fontBoundingBoxDescent);
        if (ascent) {
          ctx.restore();
          const ratio = ascent / (ascent + descent);
          ascentCache.set(fontFamily, ratio);
          return ratio;
        }
        ctx.strokeStyle = "red";
        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
        ctx.strokeText("g", 0, 0);
        let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
        descent = 0;
        for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
          if (pixels[i] > 0) {
            descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
            break;
          }
        }
        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
        ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
        pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
        ascent = 0;
        for (let i = 0, ii = pixels.length; i < ii; i += 4) {
          if (pixels[i] > 0) {
            ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
            break;
          }
        }
        ctx.restore();
        if (ascent) {
          const ratio = ascent / (ascent + descent);
          ascentCache.set(fontFamily, ratio);
          return ratio;
        }
        ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
        return DEFAULT_FONT_ASCENT;
      }
      function appendText(task, geom, styles, ctx) {
        const textDiv = document.createElement("span");
        const textDivProperties = task._enhanceTextSelection ? {
          angle: 0,
          canvasWidth: 0,
          hasText: geom.str !== "",
          hasEOL: geom.hasEOL,
          originalTransform: null,
          paddingBottom: 0,
          paddingLeft: 0,
          paddingRight: 0,
          paddingTop: 0,
          scale: 1
        } : {
          angle: 0,
          canvasWidth: 0,
          hasText: geom.str !== "",
          hasEOL: geom.hasEOL
        };
        task._textDivs.push(textDiv);
        const tx = _util.Util.transform(task._viewport.transform, geom.transform);
        let angle = Math.atan2(tx[1], tx[0]);
        const style = styles[geom.fontName];
        if (style.vertical) {
          angle += Math.PI / 2;
        }
        const fontHeight = Math.hypot(tx[2], tx[3]);
        const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
        let left, top;
        if (angle === 0) {
          left = tx[4];
          top = tx[5] - fontAscent;
        } else {
          left = tx[4] + fontAscent * Math.sin(angle);
          top = tx[5] - fontAscent * Math.cos(angle);
        }
        textDiv.style.left = `${left}px`;
        textDiv.style.top = `${top}px`;
        textDiv.style.fontSize = `${fontHeight}px`;
        textDiv.style.fontFamily = style.fontFamily;
        textDiv.setAttribute("role", "presentation");
        textDiv.textContent = geom.str;
        textDiv.dir = geom.dir;
        if (task._fontInspectorEnabled) {
          textDiv.dataset.fontName = geom.fontName;
        }
        if (angle !== 0) {
          textDivProperties.angle = angle * (180 / Math.PI);
        }
        let shouldScaleText = false;
        if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
          shouldScaleText = true;
        } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
          const absScaleX = Math.abs(geom.transform[0]),
            absScaleY = Math.abs(geom.transform[3]);
          if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
            shouldScaleText = true;
          }
        }
        if (shouldScaleText) {
          if (style.vertical) {
            textDivProperties.canvasWidth = geom.height * task._viewport.scale;
          } else {
            textDivProperties.canvasWidth = geom.width * task._viewport.scale;
          }
        }
        task._textDivProperties.set(textDiv, textDivProperties);
        if (task._textContentStream) {
          task._layoutText(textDiv);
        }
        if (task._enhanceTextSelection && textDivProperties.hasText) {
          let angleCos = 1,
            angleSin = 0;
          if (angle !== 0) {
            angleCos = Math.cos(angle);
            angleSin = Math.sin(angle);
          }
          const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
          const divHeight = fontHeight;
          let m, b;
          if (angle !== 0) {
            m = [angleCos, angleSin, -angleSin, angleCos, left, top];
            b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
          } else {
            b = [left, top, left + divWidth, top + divHeight];
          }
          task._bounds.push({
            left: b[0],
            top: b[1],
            right: b[2],
            bottom: b[3],
            div: textDiv,
            size: [divWidth, divHeight],
            m
          });
        }
      }
      function render(task) {
        if (task._canceled) {
          return;
        }
        const textDivs = task._textDivs;
        const capability = task._capability;
        const textDivsLength = textDivs.length;
        if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
          task._renderingDone = true;
          capability.resolve();
          return;
        }
        if (!task._textContentStream) {
          for (let i = 0; i < textDivsLength; i++) {
            task._layoutText(textDivs[i]);
          }
        }
        task._renderingDone = true;
        capability.resolve();
      }
      function findPositiveMin(ts, offset, count) {
        let result = 0;
        for (let i = 0; i < count; i++) {
          const t = ts[offset++];
          if (t > 0) {
            result = result ? Math.min(t, result) : t;
          }
        }
        return result;
      }
      function expand(task) {
        const bounds = task._bounds;
        const viewport = task._viewport;
        const expanded = expandBounds(viewport.width, viewport.height, bounds);
        for (let i = 0; i < expanded.length; i++) {
          const div = bounds[i].div;
          const divProperties = task._textDivProperties.get(div);
          if (divProperties.angle === 0) {
            divProperties.paddingLeft = bounds[i].left - expanded[i].left;
            divProperties.paddingTop = bounds[i].top - expanded[i].top;
            divProperties.paddingRight = expanded[i].right - bounds[i].right;
            divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
            task._textDivProperties.set(div, divProperties);
            continue;
          }
          const e = expanded[i],
            b = bounds[i];
          const m = b.m,
            c = m[0],
            s = m[1];
          const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
          const ts = new Float64Array(64);
          for (let j = 0, jj = points.length; j < jj; j++) {
            const t = _util.Util.applyTransform(points[j], m);
            ts[j + 0] = c && (e.left - t[0]) / c;
            ts[j + 4] = s && (e.top - t[1]) / s;
            ts[j + 8] = c && (e.right - t[0]) / c;
            ts[j + 12] = s && (e.bottom - t[1]) / s;
            ts[j + 16] = s && (e.left - t[0]) / -s;
            ts[j + 20] = c && (e.top - t[1]) / c;
            ts[j + 24] = s && (e.right - t[0]) / -s;
            ts[j + 28] = c && (e.bottom - t[1]) / c;
            ts[j + 32] = c && (e.left - t[0]) / -c;
            ts[j + 36] = s && (e.top - t[1]) / -s;
            ts[j + 40] = c && (e.right - t[0]) / -c;
            ts[j + 44] = s && (e.bottom - t[1]) / -s;
            ts[j + 48] = s && (e.left - t[0]) / s;
            ts[j + 52] = c && (e.top - t[1]) / -c;
            ts[j + 56] = s && (e.right - t[0]) / s;
            ts[j + 60] = c && (e.bottom - t[1]) / -c;
          }
          const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
          divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
          divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
          divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
          divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
          task._textDivProperties.set(div, divProperties);
        }
      }
      function expandBounds(width, height, boxes) {
        const bounds = boxes.map(function (box, i) {
          return {
            x1: box.left,
            y1: box.top,
            x2: box.right,
            y2: box.bottom,
            index: i,
            x1New: undefined,
            x2New: undefined
          };
        });
        expandBoundsLTR(width, bounds);
        const expanded = new Array(boxes.length);
        for (const b of bounds) {
          const i = b.index;
          expanded[i] = {
            left: b.x1New,
            top: 0,
            right: b.x2New,
            bottom: 0
          };
        }
        boxes.map(function (box, i) {
          const e = expanded[i],
            b = bounds[i];
          b.x1 = box.top;
          b.y1 = width - e.right;
          b.x2 = box.bottom;
          b.y2 = width - e.left;
          b.index = i;
          b.x1New = undefined;
          b.x2New = undefined;
        });
        expandBoundsLTR(height, bounds);
        for (const b of bounds) {
          const i = b.index;
          expanded[i].top = b.x1New;
          expanded[i].bottom = b.x2New;
        }
        return expanded;
      }
      function expandBoundsLTR(width, bounds) {
        bounds.sort(function (a, b) {
          return a.x1 - b.x1 || a.index - b.index;
        });
        const fakeBoundary = {
          x1: -Infinity,
          y1: -Infinity,
          x2: 0,
          y2: Infinity,
          index: -1,
          x1New: 0,
          x2New: 0
        };
        const horizon = [{
          start: -Infinity,
          end: Infinity,
          boundary: fakeBoundary
        }];
        for (const boundary of bounds) {
          let i = 0;
          while (i < horizon.length && horizon[i].end <= boundary.y1) {
            i++;
          }
          let j = horizon.length - 1;
          while (j >= 0 && horizon[j].start >= boundary.y2) {
            j--;
          }
          let horizonPart, affectedBoundary;
          let q,
            k,
            maxXNew = -Infinity;
          for (q = i; q <= j; q++) {
            horizonPart = horizon[q];
            affectedBoundary = horizonPart.boundary;
            let xNew;
            if (affectedBoundary.x2 > boundary.x1) {
              xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
            } else if (affectedBoundary.x2New === undefined) {
              xNew = (affectedBoundary.x2 + boundary.x1) / 2;
            } else {
              xNew = affectedBoundary.x2New;
            }
            if (xNew > maxXNew) {
              maxXNew = xNew;
            }
          }
          boundary.x1New = maxXNew;
          for (q = i; q <= j; q++) {
            horizonPart = horizon[q];
            affectedBoundary = horizonPart.boundary;
            if (affectedBoundary.x2New === undefined) {
              if (affectedBoundary.x2 > boundary.x1) {
                if (affectedBoundary.index > boundary.index) {
                  affectedBoundary.x2New = affectedBoundary.x2;
                }
              } else {
                affectedBoundary.x2New = maxXNew;
              }
            } else if (affectedBoundary.x2New > maxXNew) {
              affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
            }
          }
          const changedHorizon = [];
          let lastBoundary = null;
          for (q = i; q <= j; q++) {
            horizonPart = horizon[q];
            affectedBoundary = horizonPart.boundary;
            const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
            if (lastBoundary === useBoundary) {
              changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
            } else {
              changedHorizon.push({
                start: horizonPart.start,
                end: horizonPart.end,
                boundary: useBoundary
              });
              lastBoundary = useBoundary;
            }
          }
          if (horizon[i].start < boundary.y1) {
            changedHorizon[0].start = boundary.y1;
            changedHorizon.unshift({
              start: horizon[i].start,
              end: boundary.y1,
              boundary: horizon[i].boundary
            });
          }
          if (boundary.y2 < horizon[j].end) {
            changedHorizon[changedHorizon.length - 1].end = boundary.y2;
            changedHorizon.push({
              start: boundary.y2,
              end: horizon[j].end,
              boundary: horizon[j].boundary
            });
          }
          for (q = i; q <= j; q++) {
            horizonPart = horizon[q];
            affectedBoundary = horizonPart.boundary;
            if (affectedBoundary.x2New !== undefined) {
              continue;
            }
            let used = false;
            for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
              used = horizon[k].boundary === affectedBoundary;
            }
            for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
              used = horizon[k].boundary === affectedBoundary;
            }
            for (k = 0; !used && k < changedHorizon.length; k++) {
              used = changedHorizon[k].boundary === affectedBoundary;
            }
            if (!used) {
              affectedBoundary.x2New = maxXNew;
            }
          }
          Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
        }
        for (const horizonPart of horizon) {
          const affectedBoundary = horizonPart.boundary;
          if (affectedBoundary.x2New === undefined) {
            affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
          }
        }
      }
      class TextLayerRenderTask {
        constructor({
          textContent,
          textContentStream,
          container,
          viewport,
          textDivs,
          textContentItemsStr,
          enhanceTextSelection
        }) {
          var _globalThis$FontInspe2;
          this._textContent = textContent;
          this._textContentStream = textContentStream;
          this._container = container;
          this._document = container.ownerDocument;
          this._viewport = viewport;
          this._textDivs = textDivs || [];
          this._textContentItemsStr = textContentItemsStr || [];
          this._enhanceTextSelection = !!enhanceTextSelection;
          this._fontInspectorEnabled = !!((_globalThis$FontInspe2 = globalThis.FontInspector) !== null && _globalThis$FontInspe2 !== void 0 && _globalThis$FontInspe2.enabled);
          this._reader = null;
          this._layoutTextLastFontSize = null;
          this._layoutTextLastFontFamily = null;
          this._layoutTextCtx = null;
          this._textDivProperties = new WeakMap();
          this._renderingDone = false;
          this._canceled = false;
          this._capability = (0, _util.createPromiseCapability)();
          this._renderTimer = null;
          this._bounds = [];
          this._capability.promise.finally(() => {
            if (!this._enhanceTextSelection) {
              this._textDivProperties = null;
            }
            if (this._layoutTextCtx) {
              this._layoutTextCtx.canvas.width = 0;
              this._layoutTextCtx.canvas.height = 0;
              this._layoutTextCtx = null;
            }
          }).catch(() => {});
        }
        get promise() {
          return this._capability.promise;
        }
        cancel() {
          this._canceled = true;
          if (this._reader) {
            this._reader.cancel(new _util.AbortException("TextLayer task cancelled.")).catch(() => {});
            this._reader = null;
          }
          if (this._renderTimer !== null) {
            clearTimeout(this._renderTimer);
            this._renderTimer = null;
          }
          this._capability.reject(new Error("TextLayer task cancelled."));
        }
        _processItems(items, styleCache) {
          for (let i = 0, len = items.length; i < len; i++) {
            if (items[i].str === undefined) {
              if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
                const parent = this._container;
                this._container = document.createElement("span");
                this._container.classList.add("markedContent");
                if (items[i].id !== null) {
                  this._container.setAttribute("id", `${items[i].id}`);
                }
                parent.appendChild(this._container);
              } else if (items[i].type === "endMarkedContent") {
                this._container = this._container.parentNode;
              }
              continue;
            }
            this._textContentItemsStr.push(items[i].str);
            appendText(this, items[i], styleCache, this._layoutTextCtx);
          }
        }
        _layoutText(textDiv) {
          const textDivProperties = this._textDivProperties.get(textDiv);
          let transform = "";
          if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
            const {
              fontSize,
              fontFamily
            } = textDiv.style;
            if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
              this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;
              this._layoutTextLastFontSize = fontSize;
              this._layoutTextLastFontFamily = fontFamily;
            }
            const {
              width
            } = this._layoutTextCtx.measureText(textDiv.textContent);
            if (width > 0) {
              const scale = textDivProperties.canvasWidth / width;
              if (this._enhanceTextSelection) {
                textDivProperties.scale = scale;
              }
              transform = `scaleX(${scale})`;
            }
          }
          if (textDivProperties.angle !== 0) {
            transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
          }
          if (transform.length > 0) {
            if (this._enhanceTextSelection) {
              textDivProperties.originalTransform = transform;
            }
            textDiv.style.transform = transform;
          }
          if (textDivProperties.hasText) {
            this._container.appendChild(textDiv);
          }
          if (textDivProperties.hasEOL) {
            const br = document.createElement("br");
            br.setAttribute("role", "presentation");
            this._container.appendChild(br);
          }
        }
        _render(timeout = 0) {
          const capability = (0, _util.createPromiseCapability)();
          let styleCache = Object.create(null);
          const canvas = this._document.createElement("canvas");
          canvas.height = canvas.width = DEFAULT_FONT_SIZE;
          this._layoutTextCtx = canvas.getContext("2d", {
            alpha: false
          });
          if (this._textContent) {
            const textItems = this._textContent.items;
            const textStyles = this._textContent.styles;
            this._processItems(textItems, textStyles);
            capability.resolve();
          } else if (this._textContentStream) {
            const pump = () => {
              this._reader.read().then(({
                value,
                done
              }) => {
                if (done) {
                  capability.resolve();
                  return;
                }
                Object.assign(styleCache, value.styles);
                this._processItems(value.items, styleCache);
                pump();
              }, capability.reject);
            };
            this._reader = this._textContentStream.getReader();
            pump();
          } else {
            throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
          }
          capability.promise.then(() => {
            styleCache = null;
            if (!timeout) {
              render(this);
            } else {
              this._renderTimer = setTimeout(() => {
                render(this);
                this._renderTimer = null;
              }, timeout);
            }
          }, this._capability.reject);
        }
        expandTextDivs(expandDivs = false) {
          if (!this._enhanceTextSelection || !this._renderingDone) {
            return;
          }
          if (this._bounds !== null) {
            expand(this);
            this._bounds = null;
          }
          const transformBuf = [],
            paddingBuf = [];
          for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
            const div = this._textDivs[i];
            const divProps = this._textDivProperties.get(div);
            if (!divProps.hasText) {
              continue;
            }
            if (expandDivs) {
              transformBuf.length = 0;
              paddingBuf.length = 0;
              if (divProps.originalTransform) {
                transformBuf.push(divProps.originalTransform);
              }
              if (divProps.paddingTop > 0) {
                paddingBuf.push(`${divProps.paddingTop}px`);
                transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
              } else {
                paddingBuf.push(0);
              }
              if (divProps.paddingRight > 0) {
                paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
              } else {
                paddingBuf.push(0);
              }
              if (divProps.paddingBottom > 0) {
                paddingBuf.push(`${divProps.paddingBottom}px`);
              } else {
                paddingBuf.push(0);
              }
              if (divProps.paddingLeft > 0) {
                paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
                transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
              } else {
                paddingBuf.push(0);
              }
              div.style.padding = paddingBuf.join(" ");
              if (transformBuf.length) {
                div.style.transform = transformBuf.join(" ");
              }
            } else {
              div.style.padding = null;
              div.style.transform = divProps.originalTransform;
            }
          }
        }
      }
      function renderTextLayer(renderParameters) {
        const task = new TextLayerRenderTask({
          textContent: renderParameters.textContent,
          textContentStream: renderParameters.textContentStream,
          container: renderParameters.container,
          viewport: renderParameters.viewport,
          textDivs: renderParameters.textDivs,
          textContentItemsStr: renderParameters.textContentItemsStr,
          enhanceTextSelection: renderParameters.enhanceTextSelection
        });
        task._render(renderParameters.timeout);
        return task;
      }

      /***/
    }), ( /* 24 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SVGGraphics = void 0;
      var _util = __w_pdfjs_require__(1);
      var _display_utils = __w_pdfjs_require__(5);
      var _is_node = __w_pdfjs_require__(3);
      let SVGGraphics = class {
        constructor() {
          (0, _util.unreachable)("Not implemented: SVGGraphics");
        }
      };
      exports.SVGGraphics = SVGGraphics;
      {
        const SVG_DEFAULTS = {
          fontStyle: "normal",
          fontWeight: "normal",
          fillColor: "#000000"
        };
        const XML_NS = "http://www.w3.org/XML/1998/namespace";
        const XLINK_NS = "http://www.w3.org/1999/xlink";
        const LINE_CAP_STYLES = ["butt", "round", "square"];
        const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
        const createObjectURL = function (data, contentType = "", forceDataSchema = false) {
          if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
            return URL.createObjectURL(new Blob([data], {
              type: contentType
            }));
          }
          const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          let buffer = `data:${contentType};base64,`;
          for (let i = 0, ii = data.length; i < ii; i += 3) {
            const b1 = data[i] & 0xff;
            const b2 = data[i + 1] & 0xff;
            const b3 = data[i + 2] & 0xff;
            const d1 = b1 >> 2,
              d2 = (b1 & 3) << 4 | b2 >> 4;
            const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
            const d4 = i + 2 < ii ? b3 & 0x3f : 64;
            buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
          }
          return buffer;
        };
        const convertImgDataToPng = function () {
          const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
          const CHUNK_WRAPPER_SIZE = 12;
          const crcTable = new Int32Array(256);
          for (let i = 0; i < 256; i++) {
            let c = i;
            for (let h = 0; h < 8; h++) {
              if (c & 1) {
                c = 0xedb88320 ^ c >> 1 & 0x7fffffff;
              } else {
                c = c >> 1 & 0x7fffffff;
              }
            }
            crcTable[i] = c;
          }
          function crc32(data, start, end) {
            let crc = -1;
            for (let i = start; i < end; i++) {
              const a = (crc ^ data[i]) & 0xff;
              const b = crcTable[a];
              crc = crc >>> 8 ^ b;
            }
            return crc ^ -1;
          }
          function writePngChunk(type, body, data, offset) {
            let p = offset;
            const len = body.length;
            data[p] = len >> 24 & 0xff;
            data[p + 1] = len >> 16 & 0xff;
            data[p + 2] = len >> 8 & 0xff;
            data[p + 3] = len & 0xff;
            p += 4;
            data[p] = type.charCodeAt(0) & 0xff;
            data[p + 1] = type.charCodeAt(1) & 0xff;
            data[p + 2] = type.charCodeAt(2) & 0xff;
            data[p + 3] = type.charCodeAt(3) & 0xff;
            p += 4;
            data.set(body, p);
            p += body.length;
            const crc = crc32(data, offset + 4, p);
            data[p] = crc >> 24 & 0xff;
            data[p + 1] = crc >> 16 & 0xff;
            data[p + 2] = crc >> 8 & 0xff;
            data[p + 3] = crc & 0xff;
          }
          function adler32(data, start, end) {
            let a = 1;
            let b = 0;
            for (let i = start; i < end; ++i) {
              a = (a + (data[i] & 0xff)) % 65521;
              b = (b + a) % 65521;
            }
            return b << 16 | a;
          }
          function deflateSync(literals) {
            if (!_is_node.isNodeJS) {
              return deflateSyncUncompressed(literals);
            }
            try {
              let input;
              if (parseInt(process.versions.node) >= 8) {
                input = literals;
              } else {
                input = Buffer.from(literals);
              }
              const output = (__webpack_require__(/*! zlib */ 82258).deflateSync)(input, {
                level: 9
              });
              return output instanceof Uint8Array ? output : new Uint8Array(output);
            } catch (e) {
              (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
            }
            return deflateSyncUncompressed(literals);
          }
          function deflateSyncUncompressed(literals) {
            let len = literals.length;
            const maxBlockLength = 0xffff;
            const deflateBlocks = Math.ceil(len / maxBlockLength);
            const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
            let pi = 0;
            idat[pi++] = 0x78;
            idat[pi++] = 0x9c;
            let pos = 0;
            while (len > maxBlockLength) {
              idat[pi++] = 0x00;
              idat[pi++] = 0xff;
              idat[pi++] = 0xff;
              idat[pi++] = 0x00;
              idat[pi++] = 0x00;
              idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
              pi += maxBlockLength;
              pos += maxBlockLength;
              len -= maxBlockLength;
            }
            idat[pi++] = 0x01;
            idat[pi++] = len & 0xff;
            idat[pi++] = len >> 8 & 0xff;
            idat[pi++] = ~len & 0xffff & 0xff;
            idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
            idat.set(literals.subarray(pos), pi);
            pi += literals.length - pos;
            const adler = adler32(literals, 0, literals.length);
            idat[pi++] = adler >> 24 & 0xff;
            idat[pi++] = adler >> 16 & 0xff;
            idat[pi++] = adler >> 8 & 0xff;
            idat[pi++] = adler & 0xff;
            return idat;
          }
          function encode(imgData, kind, forceDataSchema, isMask) {
            const width = imgData.width;
            const height = imgData.height;
            let bitDepth, colorType, lineSize;
            const bytes = imgData.data;
            switch (kind) {
              case _util.ImageKind.GRAYSCALE_1BPP:
                colorType = 0;
                bitDepth = 1;
                lineSize = width + 7 >> 3;
                break;
              case _util.ImageKind.RGB_24BPP:
                colorType = 2;
                bitDepth = 8;
                lineSize = width * 3;
                break;
              case _util.ImageKind.RGBA_32BPP:
                colorType = 6;
                bitDepth = 8;
                lineSize = width * 4;
                break;
              default:
                throw new Error("invalid format");
            }
            const literals = new Uint8Array((1 + lineSize) * height);
            let offsetLiterals = 0,
              offsetBytes = 0;
            for (let y = 0; y < height; ++y) {
              literals[offsetLiterals++] = 0;
              literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
              offsetBytes += lineSize;
              offsetLiterals += lineSize;
            }
            if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
              offsetLiterals = 0;
              for (let y = 0; y < height; y++) {
                offsetLiterals++;
                for (let i = 0; i < lineSize; i++) {
                  literals[offsetLiterals++] ^= 0xff;
                }
              }
            }
            const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
            const idat = deflateSync(literals);
            const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
            const data = new Uint8Array(pngLength);
            let offset = 0;
            data.set(PNG_HEADER, offset);
            offset += PNG_HEADER.length;
            writePngChunk("IHDR", ihdr, data, offset);
            offset += CHUNK_WRAPPER_SIZE + ihdr.length;
            writePngChunk("IDATA", idat, data, offset);
            offset += CHUNK_WRAPPER_SIZE + idat.length;
            writePngChunk("IEND", new Uint8Array(0), data, offset);
            return createObjectURL(data, "image/png", forceDataSchema);
          }
          return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
            const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
            return encode(imgData, kind, forceDataSchema, isMask);
          };
        }();
        class SVGExtraState {
          constructor() {
            this.fontSizeScale = 1;
            this.fontWeight = SVG_DEFAULTS.fontWeight;
            this.fontSize = 0;
            this.textMatrix = _util.IDENTITY_MATRIX;
            this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
            this.leading = 0;
            this.textRenderingMode = _util.TextRenderingMode.FILL;
            this.textMatrixScale = 1;
            this.x = 0;
            this.y = 0;
            this.lineX = 0;
            this.lineY = 0;
            this.charSpacing = 0;
            this.wordSpacing = 0;
            this.textHScale = 1;
            this.textRise = 0;
            this.fillColor = SVG_DEFAULTS.fillColor;
            this.strokeColor = "#000000";
            this.fillAlpha = 1;
            this.strokeAlpha = 1;
            this.lineWidth = 1;
            this.lineJoin = "";
            this.lineCap = "";
            this.miterLimit = 0;
            this.dashArray = [];
            this.dashPhase = 0;
            this.dependencies = [];
            this.activeClipUrl = null;
            this.clipGroup = null;
            this.maskId = "";
          }
          clone() {
            return Object.create(this);
          }
          setCurrentPoint(x, y) {
            this.x = x;
            this.y = y;
          }
        }
        function opListToTree(opList) {
          let opTree = [];
          const tmp = [];
          for (const opListElement of opList) {
            if (opListElement.fn === "save") {
              opTree.push({
                fnId: 92,
                fn: "group",
                items: []
              });
              tmp.push(opTree);
              opTree = opTree[opTree.length - 1].items;
              continue;
            }
            if (opListElement.fn === "restore") {
              opTree = tmp.pop();
            } else {
              opTree.push(opListElement);
            }
          }
          return opTree;
        }
        function pf(value) {
          if (Number.isInteger(value)) {
            return value.toString();
          }
          const s = value.toFixed(10);
          let i = s.length - 1;
          if (s[i] !== "0") {
            return s;
          }
          do {
            i--;
          } while (s[i] === "0");
          return s.substring(0, s[i] === "." ? i : i + 1);
        }
        function pm(m) {
          if (m[4] === 0 && m[5] === 0) {
            if (m[1] === 0 && m[2] === 0) {
              if (m[0] === 1 && m[3] === 1) {
                return "";
              }
              return `scale(${pf(m[0])} ${pf(m[3])})`;
            }
            if (m[0] === m[3] && m[1] === -m[2]) {
              const a = Math.acos(m[0]) * 180 / Math.PI;
              return `rotate(${pf(a)})`;
            }
          } else {
            if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
              return `translate(${pf(m[4])} ${pf(m[5])})`;
            }
          }
          return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;
        }
        let clipCount = 0;
        let maskCount = 0;
        let shadingCount = 0;
        exports.SVGGraphics = SVGGraphics = class {
          constructor(commonObjs, objs, forceDataSchema = false) {
            this.svgFactory = new _display_utils.DOMSVGFactory();
            this.current = new SVGExtraState();
            this.transformMatrix = _util.IDENTITY_MATRIX;
            this.transformStack = [];
            this.extraStack = [];
            this.commonObjs = commonObjs;
            this.objs = objs;
            this.pendingClip = null;
            this.pendingEOFill = false;
            this.embedFonts = false;
            this.embeddedFonts = Object.create(null);
            this.cssStyle = null;
            this.forceDataSchema = !!forceDataSchema;
            this._operatorIdMapping = [];
            for (const op in _util.OPS) {
              this._operatorIdMapping[_util.OPS[op]] = op;
            }
          }
          save() {
            this.transformStack.push(this.transformMatrix);
            const old = this.current;
            this.extraStack.push(old);
            this.current = old.clone();
          }
          restore() {
            this.transformMatrix = this.transformStack.pop();
            this.current = this.extraStack.pop();
            this.pendingClip = null;
            this.tgrp = null;
          }
          group(items) {
            this.save();
            this.executeOpTree(items);
            this.restore();
          }
          loadDependencies(operatorList) {
            const fnArray = operatorList.fnArray;
            const argsArray = operatorList.argsArray;
            for (let i = 0, ii = fnArray.length; i < ii; i++) {
              if (fnArray[i] !== _util.OPS.dependency) {
                continue;
              }
              for (const obj of argsArray[i]) {
                const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
                const promise = new Promise(resolve => {
                  objsPool.get(obj, resolve);
                });
                this.current.dependencies.push(promise);
              }
            }
            return Promise.all(this.current.dependencies);
          }
          transform(a, b, c, d, e, f) {
            const transformMatrix = [a, b, c, d, e, f];
            this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
            this.tgrp = null;
          }
          getSVG(operatorList, viewport) {
            this.viewport = viewport;
            const svgElement = this._initialize(viewport);
            return this.loadDependencies(operatorList).then(() => {
              this.transformMatrix = _util.IDENTITY_MATRIX;
              this.executeOpTree(this.convertOpList(operatorList));
              return svgElement;
            });
          }
          convertOpList(operatorList) {
            const operatorIdMapping = this._operatorIdMapping;
            const argsArray = operatorList.argsArray;
            const fnArray = operatorList.fnArray;
            const opList = [];
            for (let i = 0, ii = fnArray.length; i < ii; i++) {
              const fnId = fnArray[i];
              opList.push({
                fnId,
                fn: operatorIdMapping[fnId],
                args: argsArray[i]
              });
            }
            return opListToTree(opList);
          }
          executeOpTree(opTree) {
            for (const opTreeElement of opTree) {
              const fn = opTreeElement.fn;
              const fnId = opTreeElement.fnId;
              const args = opTreeElement.args;
              switch (fnId | 0) {
                case _util.OPS.beginText:
                  this.beginText();
                  break;
                case _util.OPS.dependency:
                  break;
                case _util.OPS.setLeading:
                  this.setLeading(args);
                  break;
                case _util.OPS.setLeadingMoveText:
                  this.setLeadingMoveText(args[0], args[1]);
                  break;
                case _util.OPS.setFont:
                  this.setFont(args);
                  break;
                case _util.OPS.showText:
                  this.showText(args[0]);
                  break;
                case _util.OPS.showSpacedText:
                  this.showText(args[0]);
                  break;
                case _util.OPS.endText:
                  this.endText();
                  break;
                case _util.OPS.moveText:
                  this.moveText(args[0], args[1]);
                  break;
                case _util.OPS.setCharSpacing:
                  this.setCharSpacing(args[0]);
                  break;
                case _util.OPS.setWordSpacing:
                  this.setWordSpacing(args[0]);
                  break;
                case _util.OPS.setHScale:
                  this.setHScale(args[0]);
                  break;
                case _util.OPS.setTextMatrix:
                  this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                  break;
                case _util.OPS.setTextRise:
                  this.setTextRise(args[0]);
                  break;
                case _util.OPS.setTextRenderingMode:
                  this.setTextRenderingMode(args[0]);
                  break;
                case _util.OPS.setLineWidth:
                  this.setLineWidth(args[0]);
                  break;
                case _util.OPS.setLineJoin:
                  this.setLineJoin(args[0]);
                  break;
                case _util.OPS.setLineCap:
                  this.setLineCap(args[0]);
                  break;
                case _util.OPS.setMiterLimit:
                  this.setMiterLimit(args[0]);
                  break;
                case _util.OPS.setFillRGBColor:
                  this.setFillRGBColor(args[0], args[1], args[2]);
                  break;
                case _util.OPS.setStrokeRGBColor:
                  this.setStrokeRGBColor(args[0], args[1], args[2]);
                  break;
                case _util.OPS.setStrokeColorN:
                  this.setStrokeColorN(args);
                  break;
                case _util.OPS.setFillColorN:
                  this.setFillColorN(args);
                  break;
                case _util.OPS.shadingFill:
                  this.shadingFill(args[0]);
                  break;
                case _util.OPS.setDash:
                  this.setDash(args[0], args[1]);
                  break;
                case _util.OPS.setRenderingIntent:
                  this.setRenderingIntent(args[0]);
                  break;
                case _util.OPS.setFlatness:
                  this.setFlatness(args[0]);
                  break;
                case _util.OPS.setGState:
                  this.setGState(args[0]);
                  break;
                case _util.OPS.fill:
                  this.fill();
                  break;
                case _util.OPS.eoFill:
                  this.eoFill();
                  break;
                case _util.OPS.stroke:
                  this.stroke();
                  break;
                case _util.OPS.fillStroke:
                  this.fillStroke();
                  break;
                case _util.OPS.eoFillStroke:
                  this.eoFillStroke();
                  break;
                case _util.OPS.clip:
                  this.clip("nonzero");
                  break;
                case _util.OPS.eoClip:
                  this.clip("evenodd");
                  break;
                case _util.OPS.paintSolidColorImageMask:
                  this.paintSolidColorImageMask();
                  break;
                case _util.OPS.paintImageXObject:
                  this.paintImageXObject(args[0]);
                  break;
                case _util.OPS.paintInlineImageXObject:
                  this.paintInlineImageXObject(args[0]);
                  break;
                case _util.OPS.paintImageMaskXObject:
                  this.paintImageMaskXObject(args[0]);
                  break;
                case _util.OPS.paintFormXObjectBegin:
                  this.paintFormXObjectBegin(args[0], args[1]);
                  break;
                case _util.OPS.paintFormXObjectEnd:
                  this.paintFormXObjectEnd();
                  break;
                case _util.OPS.closePath:
                  this.closePath();
                  break;
                case _util.OPS.closeStroke:
                  this.closeStroke();
                  break;
                case _util.OPS.closeFillStroke:
                  this.closeFillStroke();
                  break;
                case _util.OPS.closeEOFillStroke:
                  this.closeEOFillStroke();
                  break;
                case _util.OPS.nextLine:
                  this.nextLine();
                  break;
                case _util.OPS.transform:
                  this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                  break;
                case _util.OPS.constructPath:
                  this.constructPath(args[0], args[1]);
                  break;
                case _util.OPS.endPath:
                  this.endPath();
                  break;
                case 92:
                  this.group(opTreeElement.items);
                  break;
                default:
                  (0, _util.warn)(`Unimplemented operator ${fn}`);
                  break;
              }
            }
          }
          setWordSpacing(wordSpacing) {
            this.current.wordSpacing = wordSpacing;
          }
          setCharSpacing(charSpacing) {
            this.current.charSpacing = charSpacing;
          }
          nextLine() {
            this.moveText(0, this.current.leading);
          }
          setTextMatrix(a, b, c, d, e, f) {
            const current = this.current;
            current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
            current.textMatrixScale = Math.hypot(a, b);
            current.x = current.lineX = 0;
            current.y = current.lineY = 0;
            current.xcoords = [];
            current.ycoords = [];
            current.tspan = this.svgFactory.createElement("svg:tspan");
            current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
            current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
            current.tspan.setAttributeNS(null, "y", pf(-current.y));
            current.txtElement = this.svgFactory.createElement("svg:text");
            current.txtElement.appendChild(current.tspan);
          }
          beginText() {
            const current = this.current;
            current.x = current.lineX = 0;
            current.y = current.lineY = 0;
            current.textMatrix = _util.IDENTITY_MATRIX;
            current.lineMatrix = _util.IDENTITY_MATRIX;
            current.textMatrixScale = 1;
            current.tspan = this.svgFactory.createElement("svg:tspan");
            current.txtElement = this.svgFactory.createElement("svg:text");
            current.txtgrp = this.svgFactory.createElement("svg:g");
            current.xcoords = [];
            current.ycoords = [];
          }
          moveText(x, y) {
            const current = this.current;
            current.x = current.lineX += x;
            current.y = current.lineY += y;
            current.xcoords = [];
            current.ycoords = [];
            current.tspan = this.svgFactory.createElement("svg:tspan");
            current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
            current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
            current.tspan.setAttributeNS(null, "y", pf(-current.y));
          }
          showText(glyphs) {
            const current = this.current;
            const font = current.font;
            const fontSize = current.fontSize;
            if (fontSize === 0) {
              return;
            }
            const fontSizeScale = current.fontSizeScale;
            const charSpacing = current.charSpacing;
            const wordSpacing = current.wordSpacing;
            const fontDirection = current.fontDirection;
            const textHScale = current.textHScale * fontDirection;
            const vertical = font.vertical;
            const spacingDir = vertical ? 1 : -1;
            const defaultVMetrics = font.defaultVMetrics;
            const widthAdvanceScale = fontSize * current.fontMatrix[0];
            let x = 0;
            for (const glyph of glyphs) {
              if (glyph === null) {
                x += fontDirection * wordSpacing;
                continue;
              } else if (typeof glyph === "number") {
                x += spacingDir * glyph * fontSize / 1000;
                continue;
              }
              const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
              const character = glyph.fontChar;
              let scaledX, scaledY;
              let width = glyph.width;
              if (vertical) {
                let vx;
                const vmetric = glyph.vmetric || defaultVMetrics;
                vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                vx = -vx * widthAdvanceScale;
                const vy = vmetric[2] * widthAdvanceScale;
                width = vmetric ? -vmetric[0] : width;
                scaledX = vx / fontSizeScale;
                scaledY = (x + vy) / fontSizeScale;
              } else {
                scaledX = x / fontSizeScale;
                scaledY = 0;
              }
              if (glyph.isInFont || font.missingFile) {
                current.xcoords.push(current.x + scaledX);
                if (vertical) {
                  current.ycoords.push(-current.y + scaledY);
                }
                current.tspan.textContent += character;
              } else {}
              let charWidth;
              if (vertical) {
                charWidth = width * widthAdvanceScale - spacing * fontDirection;
              } else {
                charWidth = width * widthAdvanceScale + spacing * fontDirection;
              }
              x += charWidth;
            }
            current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
            if (vertical) {
              current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
            } else {
              current.tspan.setAttributeNS(null, "y", pf(-current.y));
            }
            if (vertical) {
              current.y -= x;
            } else {
              current.x += x * textHScale;
            }
            current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
            current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
            if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
              current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
            }
            if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
              current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
            }
            const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
            if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
              if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                current.tspan.setAttributeNS(null, "fill", current.fillColor);
              }
              if (current.fillAlpha < 1) {
                current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
              }
            } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
              current.tspan.setAttributeNS(null, "fill", "transparent");
            } else {
              current.tspan.setAttributeNS(null, "fill", "none");
            }
            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
              const lineWidthScale = 1 / (current.textMatrixScale || 1);
              this._setStrokeAttributes(current.tspan, lineWidthScale);
            }
            let textMatrix = current.textMatrix;
            if (current.textRise !== 0) {
              textMatrix = textMatrix.slice();
              textMatrix[5] += current.textRise;
            }
            current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
            current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
            current.txtElement.appendChild(current.tspan);
            current.txtgrp.appendChild(current.txtElement);
            this._ensureTransformGroup().appendChild(current.txtElement);
          }
          setLeadingMoveText(x, y) {
            this.setLeading(-y);
            this.moveText(x, y);
          }
          addFontStyle(fontObj) {
            if (!fontObj.data) {
              throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
            }
            if (!this.cssStyle) {
              this.cssStyle = this.svgFactory.createElement("svg:style");
              this.cssStyle.setAttributeNS(null, "type", "text/css");
              this.defs.appendChild(this.cssStyle);
            }
            const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
            this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}";` + ` src: url(${url}); }\n`;
          }
          setFont(details) {
            const current = this.current;
            const fontObj = this.commonObjs.get(details[0]);
            let size = details[1];
            current.font = fontObj;
            if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
              this.addFontStyle(fontObj);
              this.embeddedFonts[fontObj.loadedName] = fontObj;
            }
            current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
            let bold = "normal";
            if (fontObj.black) {
              bold = "900";
            } else if (fontObj.bold) {
              bold = "bold";
            }
            const italic = fontObj.italic ? "italic" : "normal";
            if (size < 0) {
              size = -size;
              current.fontDirection = -1;
            } else {
              current.fontDirection = 1;
            }
            current.fontSize = size;
            current.fontFamily = fontObj.loadedName;
            current.fontWeight = bold;
            current.fontStyle = italic;
            current.tspan = this.svgFactory.createElement("svg:tspan");
            current.tspan.setAttributeNS(null, "y", pf(-current.y));
            current.xcoords = [];
            current.ycoords = [];
          }
          endText() {
            var _current$txtElement;
            const current = this.current;
            if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && (_current$txtElement = current.txtElement) !== null && _current$txtElement !== void 0 && _current$txtElement.hasChildNodes()) {
              current.element = current.txtElement;
              this.clip("nonzero");
              this.endPath();
            }
          }
          setLineWidth(width) {
            if (width > 0) {
              this.current.lineWidth = width;
            }
          }
          setLineCap(style) {
            this.current.lineCap = LINE_CAP_STYLES[style];
          }
          setLineJoin(style) {
            this.current.lineJoin = LINE_JOIN_STYLES[style];
          }
          setMiterLimit(limit) {
            this.current.miterLimit = limit;
          }
          setStrokeAlpha(strokeAlpha) {
            this.current.strokeAlpha = strokeAlpha;
          }
          setStrokeRGBColor(r, g, b) {
            this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
          }
          setFillAlpha(fillAlpha) {
            this.current.fillAlpha = fillAlpha;
          }
          setFillRGBColor(r, g, b) {
            this.current.fillColor = _util.Util.makeHexColor(r, g, b);
            this.current.tspan = this.svgFactory.createElement("svg:tspan");
            this.current.xcoords = [];
            this.current.ycoords = [];
          }
          setStrokeColorN(args) {
            this.current.strokeColor = this._makeColorN_Pattern(args);
          }
          setFillColorN(args) {
            this.current.fillColor = this._makeColorN_Pattern(args);
          }
          shadingFill(args) {
            const width = this.viewport.width;
            const height = this.viewport.height;
            const inv = _util.Util.inverseTransform(this.transformMatrix);
            const bl = _util.Util.applyTransform([0, 0], inv);
            const br = _util.Util.applyTransform([0, height], inv);
            const ul = _util.Util.applyTransform([width, 0], inv);
            const ur = _util.Util.applyTransform([width, height], inv);
            const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
            const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
            const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
            const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
            const rect = this.svgFactory.createElement("svg:rect");
            rect.setAttributeNS(null, "x", x0);
            rect.setAttributeNS(null, "y", y0);
            rect.setAttributeNS(null, "width", x1 - x0);
            rect.setAttributeNS(null, "height", y1 - y0);
            rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
            if (this.current.fillAlpha < 1) {
              rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
            }
            this._ensureTransformGroup().appendChild(rect);
          }
          _makeColorN_Pattern(args) {
            if (args[0] === "TilingPattern") {
              return this._makeTilingPattern(args);
            }
            return this._makeShadingPattern(args);
          }
          _makeTilingPattern(args) {
            const color = args[1];
            const operatorList = args[2];
            const matrix = args[3] || _util.IDENTITY_MATRIX;
            const [x0, y0, x1, y1] = args[4];
            const xstep = args[5];
            const ystep = args[6];
            const paintType = args[7];
            const tilingId = `shading${shadingCount++}`;
            const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);
            const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);
            const txstep = xstep * xscale;
            const tystep = ystep * yscale;
            const tiling = this.svgFactory.createElement("svg:pattern");
            tiling.setAttributeNS(null, "id", tilingId);
            tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
            tiling.setAttributeNS(null, "width", txstep);
            tiling.setAttributeNS(null, "height", tystep);
            tiling.setAttributeNS(null, "x", `${tx0}`);
            tiling.setAttributeNS(null, "y", `${ty0}`);
            const svg = this.svg;
            const transformMatrix = this.transformMatrix;
            const fillColor = this.current.fillColor;
            const strokeColor = this.current.strokeColor;
            const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
            this.svg = bbox;
            this.transformMatrix = matrix;
            if (paintType === 2) {
              const cssColor = _util.Util.makeHexColor(...color);
              this.current.fillColor = cssColor;
              this.current.strokeColor = cssColor;
            }
            this.executeOpTree(this.convertOpList(operatorList));
            this.svg = svg;
            this.transformMatrix = transformMatrix;
            this.current.fillColor = fillColor;
            this.current.strokeColor = strokeColor;
            tiling.appendChild(bbox.childNodes[0]);
            this.defs.appendChild(tiling);
            return `url(#${tilingId})`;
          }
          _makeShadingPattern(args) {
            if (typeof args === "string") {
              args = this.objs.get(args);
            }
            switch (args[0]) {
              case "RadialAxial":
                const shadingId = `shading${shadingCount++}`;
                const colorStops = args[3];
                let gradient;
                switch (args[1]) {
                  case "axial":
                    const point0 = args[4];
                    const point1 = args[5];
                    gradient = this.svgFactory.createElement("svg:linearGradient");
                    gradient.setAttributeNS(null, "id", shadingId);
                    gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                    gradient.setAttributeNS(null, "x1", point0[0]);
                    gradient.setAttributeNS(null, "y1", point0[1]);
                    gradient.setAttributeNS(null, "x2", point1[0]);
                    gradient.setAttributeNS(null, "y2", point1[1]);
                    break;
                  case "radial":
                    const focalPoint = args[4];
                    const circlePoint = args[5];
                    const focalRadius = args[6];
                    const circleRadius = args[7];
                    gradient = this.svgFactory.createElement("svg:radialGradient");
                    gradient.setAttributeNS(null, "id", shadingId);
                    gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                    gradient.setAttributeNS(null, "cx", circlePoint[0]);
                    gradient.setAttributeNS(null, "cy", circlePoint[1]);
                    gradient.setAttributeNS(null, "r", circleRadius);
                    gradient.setAttributeNS(null, "fx", focalPoint[0]);
                    gradient.setAttributeNS(null, "fy", focalPoint[1]);
                    gradient.setAttributeNS(null, "fr", focalRadius);
                    break;
                  default:
                    throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                }
                for (const colorStop of colorStops) {
                  const stop = this.svgFactory.createElement("svg:stop");
                  stop.setAttributeNS(null, "offset", colorStop[0]);
                  stop.setAttributeNS(null, "stop-color", colorStop[1]);
                  gradient.appendChild(stop);
                }
                this.defs.appendChild(gradient);
                return `url(#${shadingId})`;
              case "Mesh":
                (0, _util.warn)("Unimplemented pattern Mesh");
                return null;
              case "Dummy":
                return "hotpink";
              default:
                throw new Error(`Unknown IR type: ${args[0]}`);
            }
          }
          setDash(dashArray, dashPhase) {
            this.current.dashArray = dashArray;
            this.current.dashPhase = dashPhase;
          }
          constructPath(ops, args) {
            const current = this.current;
            let x = current.x,
              y = current.y;
            let d = [];
            let j = 0;
            for (const op of ops) {
              switch (op | 0) {
                case _util.OPS.rectangle:
                  x = args[j++];
                  y = args[j++];
                  const width = args[j++];
                  const height = args[j++];
                  const xw = x + width;
                  const yh = y + height;
                  d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                  break;
                case _util.OPS.moveTo:
                  x = args[j++];
                  y = args[j++];
                  d.push("M", pf(x), pf(y));
                  break;
                case _util.OPS.lineTo:
                  x = args[j++];
                  y = args[j++];
                  d.push("L", pf(x), pf(y));
                  break;
                case _util.OPS.curveTo:
                  x = args[j + 4];
                  y = args[j + 5];
                  d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                  j += 6;
                  break;
                case _util.OPS.curveTo2:
                  d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                  x = args[j + 2];
                  y = args[j + 3];
                  j += 4;
                  break;
                case _util.OPS.curveTo3:
                  x = args[j + 2];
                  y = args[j + 3];
                  d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                  j += 4;
                  break;
                case _util.OPS.closePath:
                  d.push("Z");
                  break;
              }
            }
            d = d.join(" ");
            if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
              d = current.path.getAttributeNS(null, "d") + d;
            } else {
              current.path = this.svgFactory.createElement("svg:path");
              this._ensureTransformGroup().appendChild(current.path);
            }
            current.path.setAttributeNS(null, "d", d);
            current.path.setAttributeNS(null, "fill", "none");
            current.element = current.path;
            current.setCurrentPoint(x, y);
          }
          endPath() {
            const current = this.current;
            current.path = null;
            if (!this.pendingClip) {
              return;
            }
            if (!current.element) {
              this.pendingClip = null;
              return;
            }
            const clipId = `clippath${clipCount++}`;
            const clipPath = this.svgFactory.createElement("svg:clipPath");
            clipPath.setAttributeNS(null, "id", clipId);
            clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
            const clipElement = current.element.cloneNode(true);
            if (this.pendingClip === "evenodd") {
              clipElement.setAttributeNS(null, "clip-rule", "evenodd");
            } else {
              clipElement.setAttributeNS(null, "clip-rule", "nonzero");
            }
            this.pendingClip = null;
            clipPath.appendChild(clipElement);
            this.defs.appendChild(clipPath);
            if (current.activeClipUrl) {
              current.clipGroup = null;
              for (const prev of this.extraStack) {
                prev.clipGroup = null;
              }
              clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
            }
            current.activeClipUrl = `url(#${clipId})`;
            this.tgrp = null;
          }
          clip(type) {
            this.pendingClip = type;
          }
          closePath() {
            const current = this.current;
            if (current.path) {
              const d = `${current.path.getAttributeNS(null, "d")}Z`;
              current.path.setAttributeNS(null, "d", d);
            }
          }
          setLeading(leading) {
            this.current.leading = -leading;
          }
          setTextRise(textRise) {
            this.current.textRise = textRise;
          }
          setTextRenderingMode(textRenderingMode) {
            this.current.textRenderingMode = textRenderingMode;
          }
          setHScale(scale) {
            this.current.textHScale = scale / 100;
          }
          setRenderingIntent(intent) {}
          setFlatness(flatness) {}
          setGState(states) {
            for (const [key, value] of states) {
              switch (key) {
                case "LW":
                  this.setLineWidth(value);
                  break;
                case "LC":
                  this.setLineCap(value);
                  break;
                case "LJ":
                  this.setLineJoin(value);
                  break;
                case "ML":
                  this.setMiterLimit(value);
                  break;
                case "D":
                  this.setDash(value[0], value[1]);
                  break;
                case "RI":
                  this.setRenderingIntent(value);
                  break;
                case "FL":
                  this.setFlatness(value);
                  break;
                case "Font":
                  this.setFont(value);
                  break;
                case "CA":
                  this.setStrokeAlpha(value);
                  break;
                case "ca":
                  this.setFillAlpha(value);
                  break;
                default:
                  (0, _util.warn)(`Unimplemented graphic state operator ${key}`);
                  break;
              }
            }
          }
          fill() {
            const current = this.current;
            if (current.element) {
              current.element.setAttributeNS(null, "fill", current.fillColor);
              current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
              this.endPath();
            }
          }
          stroke() {
            const current = this.current;
            if (current.element) {
              this._setStrokeAttributes(current.element);
              current.element.setAttributeNS(null, "fill", "none");
              this.endPath();
            }
          }
          _setStrokeAttributes(element, lineWidthScale = 1) {
            const current = this.current;
            let dashArray = current.dashArray;
            if (lineWidthScale !== 1 && dashArray.length > 0) {
              dashArray = dashArray.map(function (value) {
                return lineWidthScale * value;
              });
            }
            element.setAttributeNS(null, "stroke", current.strokeColor);
            element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
            element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
            element.setAttributeNS(null, "stroke-linecap", current.lineCap);
            element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
            element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
            element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
            element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
          }
          eoFill() {
            if (this.current.element) {
              this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
            }
            this.fill();
          }
          fillStroke() {
            this.stroke();
            this.fill();
          }
          eoFillStroke() {
            if (this.current.element) {
              this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
            }
            this.fillStroke();
          }
          closeStroke() {
            this.closePath();
            this.stroke();
          }
          closeFillStroke() {
            this.closePath();
            this.fillStroke();
          }
          closeEOFillStroke() {
            this.closePath();
            this.eoFillStroke();
          }
          paintSolidColorImageMask() {
            const rect = this.svgFactory.createElement("svg:rect");
            rect.setAttributeNS(null, "x", "0");
            rect.setAttributeNS(null, "y", "0");
            rect.setAttributeNS(null, "width", "1px");
            rect.setAttributeNS(null, "height", "1px");
            rect.setAttributeNS(null, "fill", this.current.fillColor);
            this._ensureTransformGroup().appendChild(rect);
          }
          paintImageXObject(objId) {
            const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
            if (!imgData) {
              (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);
              return;
            }
            this.paintInlineImageXObject(imgData);
          }
          paintInlineImageXObject(imgData, mask) {
            const width = imgData.width;
            const height = imgData.height;
            const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
            const cliprect = this.svgFactory.createElement("svg:rect");
            cliprect.setAttributeNS(null, "x", "0");
            cliprect.setAttributeNS(null, "y", "0");
            cliprect.setAttributeNS(null, "width", pf(width));
            cliprect.setAttributeNS(null, "height", pf(height));
            this.current.element = cliprect;
            this.clip("nonzero");
            const imgEl = this.svgFactory.createElement("svg:image");
            imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
            imgEl.setAttributeNS(null, "x", "0");
            imgEl.setAttributeNS(null, "y", pf(-height));
            imgEl.setAttributeNS(null, "width", pf(width) + "px");
            imgEl.setAttributeNS(null, "height", pf(height) + "px");
            imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);
            if (mask) {
              mask.appendChild(imgEl);
            } else {
              this._ensureTransformGroup().appendChild(imgEl);
            }
          }
          paintImageMaskXObject(imgData) {
            const current = this.current;
            const width = imgData.width;
            const height = imgData.height;
            const fillColor = current.fillColor;
            current.maskId = `mask${maskCount++}`;
            const mask = this.svgFactory.createElement("svg:mask");
            mask.setAttributeNS(null, "id", current.maskId);
            const rect = this.svgFactory.createElement("svg:rect");
            rect.setAttributeNS(null, "x", "0");
            rect.setAttributeNS(null, "y", "0");
            rect.setAttributeNS(null, "width", pf(width));
            rect.setAttributeNS(null, "height", pf(height));
            rect.setAttributeNS(null, "fill", fillColor);
            rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
            this.defs.appendChild(mask);
            this._ensureTransformGroup().appendChild(rect);
            this.paintInlineImageXObject(imgData, mask);
          }
          paintFormXObjectBegin(matrix, bbox) {
            if (Array.isArray(matrix) && matrix.length === 6) {
              this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
            }
            if (bbox) {
              const width = bbox[2] - bbox[0];
              const height = bbox[3] - bbox[1];
              const cliprect = this.svgFactory.createElement("svg:rect");
              cliprect.setAttributeNS(null, "x", bbox[0]);
              cliprect.setAttributeNS(null, "y", bbox[1]);
              cliprect.setAttributeNS(null, "width", pf(width));
              cliprect.setAttributeNS(null, "height", pf(height));
              this.current.element = cliprect;
              this.clip("nonzero");
              this.endPath();
            }
          }
          paintFormXObjectEnd() {}
          _initialize(viewport) {
            const svg = this.svgFactory.create(viewport.width, viewport.height);
            const definitions = this.svgFactory.createElement("svg:defs");
            svg.appendChild(definitions);
            this.defs = definitions;
            const rootGroup = this.svgFactory.createElement("svg:g");
            rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
            svg.appendChild(rootGroup);
            this.svg = rootGroup;
            return svg;
          }
          _ensureClipGroup() {
            if (!this.current.clipGroup) {
              const clipGroup = this.svgFactory.createElement("svg:g");
              clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
              this.svg.appendChild(clipGroup);
              this.current.clipGroup = clipGroup;
            }
            return this.current.clipGroup;
          }
          _ensureTransformGroup() {
            if (!this.tgrp) {
              this.tgrp = this.svgFactory.createElement("svg:g");
              this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
              if (this.current.activeClipUrl) {
                this._ensureClipGroup().appendChild(this.tgrp);
              } else {
                this.svg.appendChild(this.tgrp);
              }
            }
            return this.tgrp;
          }
        };
      }

      /***/
    }), ( /* 25 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFNodeStream = void 0;
      var _util = __w_pdfjs_require__(1);
      var _network_utils = __w_pdfjs_require__(26);
      ;
      const fs = __webpack_require__(/*! fs */ 70172);
      const http = __webpack_require__(/*! http */ 2001);
      const https = __webpack_require__(/*! https */ 33779);
      const url = __webpack_require__(/*! url */ 66558);
      const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
      function parseUrl(sourceUrl) {
        const parsedUrl = url.parse(sourceUrl);
        if (parsedUrl.protocol === "file:" || parsedUrl.host) {
          return parsedUrl;
        }
        if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
          return url.parse(`file:///${sourceUrl}`);
        }
        if (!parsedUrl.host) {
          parsedUrl.protocol = "file:";
        }
        return parsedUrl;
      }
      class PDFNodeStream {
        constructor(source) {
          this.source = source;
          this.url = parseUrl(source.url);
          this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
          this.isFsUrl = this.url.protocol === "file:";
          this.httpHeaders = this.isHttp && source.httpHeaders || {};
          this._fullRequestReader = null;
          this._rangeRequestReaders = [];
        }
        get _progressiveDataLength() {
          var _this$_fullRequestRea3, _this$_fullRequestRea4;
          return (_this$_fullRequestRea3 = (_this$_fullRequestRea4 = this._fullRequestReader) === null || _this$_fullRequestRea4 === void 0 ? void 0 : _this$_fullRequestRea4._loaded) !== null && _this$_fullRequestRea3 !== void 0 ? _this$_fullRequestRea3 : 0;
        }
        getFullReader() {
          (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
          this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
          return this._fullRequestReader;
        }
        getRangeReader(start, end) {
          if (end <= this._progressiveDataLength) {
            return null;
          }
          const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
          this._rangeRequestReaders.push(rangeReader);
          return rangeReader;
        }
        cancelAllRequests(reason) {
          if (this._fullRequestReader) {
            this._fullRequestReader.cancel(reason);
          }
          for (const reader of this._rangeRequestReaders.slice(0)) {
            reader.cancel(reason);
          }
        }
      }
      exports.PDFNodeStream = PDFNodeStream;
      class BaseFullReader {
        constructor(stream) {
          this._url = stream.url;
          this._done = false;
          this._storedError = null;
          this.onProgress = null;
          const source = stream.source;
          this._contentLength = source.length;
          this._loaded = 0;
          this._filename = null;
          this._disableRange = source.disableRange || false;
          this._rangeChunkSize = source.rangeChunkSize;
          if (!this._rangeChunkSize && !this._disableRange) {
            this._disableRange = true;
          }
          this._isStreamingSupported = !source.disableStream;
          this._isRangeSupported = !source.disableRange;
          this._readableStream = null;
          this._readCapability = (0, _util.createPromiseCapability)();
          this._headersCapability = (0, _util.createPromiseCapability)();
        }
        get headersReady() {
          return this._headersCapability.promise;
        }
        get filename() {
          return this._filename;
        }
        get contentLength() {
          return this._contentLength;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        read() {
          var _this13 = this;
          return _asyncToGenerator(function* () {
            yield _this13._readCapability.promise;
            if (_this13._done) {
              return {
                value: undefined,
                done: true
              };
            }
            if (_this13._storedError) {
              throw _this13._storedError;
            }
            const chunk = _this13._readableStream.read();
            if (chunk === null) {
              _this13._readCapability = (0, _util.createPromiseCapability)();
              return _this13.read();
            }
            _this13._loaded += chunk.length;
            if (_this13.onProgress) {
              _this13.onProgress({
                loaded: _this13._loaded,
                total: _this13._contentLength
              });
            }
            const buffer = new Uint8Array(chunk).buffer;
            return {
              value: buffer,
              done: false
            };
          })();
        }
        cancel(reason) {
          if (!this._readableStream) {
            this._error(reason);
            return;
          }
          this._readableStream.destroy(reason);
        }
        _error(reason) {
          this._storedError = reason;
          this._readCapability.resolve();
        }
        _setReadableStream(readableStream) {
          this._readableStream = readableStream;
          readableStream.on("readable", () => {
            this._readCapability.resolve();
          });
          readableStream.on("end", () => {
            readableStream.destroy();
            this._done = true;
            this._readCapability.resolve();
          });
          readableStream.on("error", reason => {
            this._error(reason);
          });
          if (!this._isStreamingSupported && this._isRangeSupported) {
            this._error(new _util.AbortException("streaming is disabled"));
          }
          if (this._storedError) {
            this._readableStream.destroy(this._storedError);
          }
        }
      }
      class BaseRangeReader {
        constructor(stream) {
          this._url = stream.url;
          this._done = false;
          this._storedError = null;
          this.onProgress = null;
          this._loaded = 0;
          this._readableStream = null;
          this._readCapability = (0, _util.createPromiseCapability)();
          const source = stream.source;
          this._isStreamingSupported = !source.disableStream;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        read() {
          var _this14 = this;
          return _asyncToGenerator(function* () {
            yield _this14._readCapability.promise;
            if (_this14._done) {
              return {
                value: undefined,
                done: true
              };
            }
            if (_this14._storedError) {
              throw _this14._storedError;
            }
            const chunk = _this14._readableStream.read();
            if (chunk === null) {
              _this14._readCapability = (0, _util.createPromiseCapability)();
              return _this14.read();
            }
            _this14._loaded += chunk.length;
            if (_this14.onProgress) {
              _this14.onProgress({
                loaded: _this14._loaded
              });
            }
            const buffer = new Uint8Array(chunk).buffer;
            return {
              value: buffer,
              done: false
            };
          })();
        }
        cancel(reason) {
          if (!this._readableStream) {
            this._error(reason);
            return;
          }
          this._readableStream.destroy(reason);
        }
        _error(reason) {
          this._storedError = reason;
          this._readCapability.resolve();
        }
        _setReadableStream(readableStream) {
          this._readableStream = readableStream;
          readableStream.on("readable", () => {
            this._readCapability.resolve();
          });
          readableStream.on("end", () => {
            readableStream.destroy();
            this._done = true;
            this._readCapability.resolve();
          });
          readableStream.on("error", reason => {
            this._error(reason);
          });
          if (this._storedError) {
            this._readableStream.destroy(this._storedError);
          }
        }
      }
      function createRequestOptions(parsedUrl, headers) {
        return {
          protocol: parsedUrl.protocol,
          auth: parsedUrl.auth,
          host: parsedUrl.hostname,
          port: parsedUrl.port,
          path: parsedUrl.path,
          method: "GET",
          headers
        };
      }
      class PDFNodeStreamFullReader extends BaseFullReader {
        constructor(stream) {
          super(stream);
          const handleResponse = response => {
            if (response.statusCode === 404) {
              const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
              this._storedError = error;
              this._headersCapability.reject(error);
              return;
            }
            this._headersCapability.resolve();
            this._setReadableStream(response);
            const getResponseHeader = name => {
              return this._readableStream.headers[name.toLowerCase()];
            };
            const {
              allowRangeRequests,
              suggestedLength
            } = (0, _network_utils.validateRangeRequestCapabilities)({
              getResponseHeader,
              isHttp: stream.isHttp,
              rangeChunkSize: this._rangeChunkSize,
              disableRange: this._disableRange
            });
            this._isRangeSupported = allowRangeRequests;
            this._contentLength = suggestedLength || this._contentLength;
            this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
          };
          this._request = null;
          if (this._url.protocol === "http:") {
            this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
          } else {
            this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
          }
          this._request.on("error", reason => {
            this._storedError = reason;
            this._headersCapability.reject(reason);
          });
          this._request.end();
        }
      }
      class PDFNodeStreamRangeReader extends BaseRangeReader {
        constructor(stream, start, end) {
          super(stream);
          this._httpHeaders = {};
          for (const property in stream.httpHeaders) {
            const value = stream.httpHeaders[property];
            if (typeof value === "undefined") {
              continue;
            }
            this._httpHeaders[property] = value;
          }
          this._httpHeaders.Range = `bytes=${start}-${end - 1}`;
          const handleResponse = response => {
            if (response.statusCode === 404) {
              const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
              this._storedError = error;
              return;
            }
            this._setReadableStream(response);
          };
          this._request = null;
          if (this._url.protocol === "http:") {
            this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
          } else {
            this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
          }
          this._request.on("error", reason => {
            this._storedError = reason;
          });
          this._request.end();
        }
      }
      class PDFNodeStreamFsFullReader extends BaseFullReader {
        constructor(stream) {
          super(stream);
          let path = decodeURIComponent(this._url.path);
          if (fileUriRegex.test(this._url.href)) {
            path = path.replace(/^\//, "");
          }
          fs.lstat(path, (error, stat) => {
            if (error) {
              if (error.code === "ENOENT") {
                error = new _util.MissingPDFException(`Missing PDF "${path}".`);
              }
              this._storedError = error;
              this._headersCapability.reject(error);
              return;
            }
            this._contentLength = stat.size;
            this._setReadableStream(fs.createReadStream(path));
            this._headersCapability.resolve();
          });
        }
      }
      class PDFNodeStreamFsRangeReader extends BaseRangeReader {
        constructor(stream, start, end) {
          super(stream);
          let path = decodeURIComponent(this._url.path);
          if (fileUriRegex.test(this._url.href)) {
            path = path.replace(/^\//, "");
          }
          this._setReadableStream(fs.createReadStream(path, {
            start,
            end: end - 1
          }));
        }
      }

      /***/
    }), ( /* 26 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createResponseStatusError = createResponseStatusError;
      exports.extractFilenameFromHeader = extractFilenameFromHeader;
      exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
      exports.validateResponseStatus = validateResponseStatus;
      var _util = __w_pdfjs_require__(1);
      var _content_disposition = __w_pdfjs_require__(27);
      var _display_utils = __w_pdfjs_require__(5);
      function validateRangeRequestCapabilities({
        getResponseHeader,
        isHttp,
        rangeChunkSize,
        disableRange
      }) {
        const returnValues = {
          allowRangeRequests: false,
          suggestedLength: undefined
        };
        const length = parseInt(getResponseHeader("Content-Length"), 10);
        if (!Number.isInteger(length)) {
          return returnValues;
        }
        returnValues.suggestedLength = length;
        if (length <= 2 * rangeChunkSize) {
          return returnValues;
        }
        if (disableRange || !isHttp) {
          return returnValues;
        }
        if (getResponseHeader("Accept-Ranges") !== "bytes") {
          return returnValues;
        }
        const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
        if (contentEncoding !== "identity") {
          return returnValues;
        }
        returnValues.allowRangeRequests = true;
        return returnValues;
      }
      function extractFilenameFromHeader(getResponseHeader) {
        const contentDisposition = getResponseHeader("Content-Disposition");
        if (contentDisposition) {
          let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
          if (filename.includes("%")) {
            try {
              filename = decodeURIComponent(filename);
            } catch (ex) {}
          }
          if ((0, _display_utils.isPdfFile)(filename)) {
            return filename;
          }
        }
        return null;
      }
      function createResponseStatusError(status, url) {
        if (status === 404 || status === 0 && url.startsWith("file:")) {
          return new _util.MissingPDFException('Missing PDF "' + url + '".');
        }
        return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
      }
      function validateResponseStatus(status) {
        return status === 200 || status === 206;
      }

      /***/
    }), ( /* 27 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
      var _util = __w_pdfjs_require__(1);
      function getFilenameFromContentDispositionHeader(contentDisposition) {
        let needsEncodingFixup = true;
        let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
        if (tmp) {
          tmp = tmp[1];
          let filename = rfc2616unquote(tmp);
          filename = unescape(filename);
          filename = rfc5987decode(filename);
          filename = rfc2047decode(filename);
          return fixupEncoding(filename);
        }
        tmp = rfc2231getparam(contentDisposition);
        if (tmp) {
          const filename = rfc2047decode(tmp);
          return fixupEncoding(filename);
        }
        tmp = toParamRegExp("filename", "i").exec(contentDisposition);
        if (tmp) {
          tmp = tmp[1];
          let filename = rfc2616unquote(tmp);
          filename = rfc2047decode(filename);
          return fixupEncoding(filename);
        }
        function toParamRegExp(attributePattern, flags) {
          return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
        }
        function textdecode(encoding, value) {
          if (encoding) {
            if (!/^[\x00-\xFF]+$/.test(value)) {
              return value;
            }
            try {
              const decoder = new TextDecoder(encoding, {
                fatal: true
              });
              const buffer = (0, _util.stringToBytes)(value);
              value = decoder.decode(buffer);
              needsEncodingFixup = false;
            } catch (e) {}
          }
          return value;
        }
        function fixupEncoding(value) {
          if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
            value = textdecode("utf-8", value);
            if (needsEncodingFixup) {
              value = textdecode("iso-8859-1", value);
            }
          }
          return value;
        }
        function rfc2231getparam(contentDispositionStr) {
          const matches = [];
          let match;
          const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
          while ((match = iter.exec(contentDispositionStr)) !== null) {
            let [, n, quot, part] = match;
            n = parseInt(n, 10);
            if (n in matches) {
              if (n === 0) {
                break;
              }
              continue;
            }
            matches[n] = [quot, part];
          }
          const parts = [];
          for (let n = 0; n < matches.length; ++n) {
            if (!(n in matches)) {
              break;
            }
            let [quot, part] = matches[n];
            part = rfc2616unquote(part);
            if (quot) {
              part = unescape(part);
              if (n === 0) {
                part = rfc5987decode(part);
              }
            }
            parts.push(part);
          }
          return parts.join("");
        }
        function rfc2616unquote(value) {
          if (value.startsWith('"')) {
            const parts = value.slice(1).split('\\"');
            for (let i = 0; i < parts.length; ++i) {
              const quotindex = parts[i].indexOf('"');
              if (quotindex !== -1) {
                parts[i] = parts[i].slice(0, quotindex);
                parts.length = i + 1;
              }
              parts[i] = parts[i].replace(/\\(.)/g, "$1");
            }
            value = parts.join('"');
          }
          return value;
        }
        function rfc5987decode(extvalue) {
          const encodingend = extvalue.indexOf("'");
          if (encodingend === -1) {
            return extvalue;
          }
          const encoding = extvalue.slice(0, encodingend);
          const langvalue = extvalue.slice(encodingend + 1);
          const value = langvalue.replace(/^[^']*'/, "");
          return textdecode(encoding, value);
        }
        function rfc2047decode(value) {
          if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
            return value;
          }
          return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
            if (encoding === "q" || encoding === "Q") {
              text = text.replace(/_/g, " ");
              text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {
                return String.fromCharCode(parseInt(hex, 16));
              });
              return textdecode(charset, text);
            }
            try {
              text = atob(text);
            } catch (e) {}
            return textdecode(charset, text);
          });
        }
        return "";
      }

      /***/
    }), ( /* 28 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFNetworkStream = void 0;
      var _util = __w_pdfjs_require__(1);
      var _network_utils = __w_pdfjs_require__(26);
      ;
      const OK_RESPONSE = 200;
      const PARTIAL_CONTENT_RESPONSE = 206;
      function getArrayBuffer(xhr) {
        const data = xhr.response;
        if (typeof data !== "string") {
          return data;
        }
        const array = (0, _util.stringToBytes)(data);
        return array.buffer;
      }
      class NetworkManager {
        constructor(url, args = {}) {
          this.url = url;
          this.isHttp = /^https?:/i.test(url);
          this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);
          this.withCredentials = args.withCredentials || false;
          this.getXhr = args.getXhr || function NetworkManager_getXhr() {
            return new XMLHttpRequest();
          };
          this.currXhrId = 0;
          this.pendingRequests = Object.create(null);
        }
        requestRange(begin, end, listeners) {
          const args = {
            begin,
            end
          };
          for (const prop in listeners) {
            args[prop] = listeners[prop];
          }
          return this.request(args);
        }
        requestFull(listeners) {
          return this.request(listeners);
        }
        request(args) {
          const xhr = this.getXhr();
          const xhrId = this.currXhrId++;
          const pendingRequest = this.pendingRequests[xhrId] = {
            xhr
          };
          xhr.open("GET", this.url);
          xhr.withCredentials = this.withCredentials;
          for (const property in this.httpHeaders) {
            const value = this.httpHeaders[property];
            if (typeof value === "undefined") {
              continue;
            }
            xhr.setRequestHeader(property, value);
          }
          if (this.isHttp && "begin" in args && "end" in args) {
            xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
          } else {
            pendingRequest.expectedStatus = OK_RESPONSE;
          }
          xhr.responseType = "arraybuffer";
          if (args.onError) {
            xhr.onerror = function (evt) {
              args.onError(xhr.status);
            };
          }
          xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
          xhr.onprogress = this.onProgress.bind(this, xhrId);
          pendingRequest.onHeadersReceived = args.onHeadersReceived;
          pendingRequest.onDone = args.onDone;
          pendingRequest.onError = args.onError;
          pendingRequest.onProgress = args.onProgress;
          xhr.send(null);
          return xhrId;
        }
        onProgress(xhrId, evt) {
          var _pendingRequest$onPro;
          const pendingRequest = this.pendingRequests[xhrId];
          if (!pendingRequest) {
            return;
          }
          (_pendingRequest$onPro = pendingRequest.onProgress) === null || _pendingRequest$onPro === void 0 ? void 0 : _pendingRequest$onPro.call(pendingRequest, evt);
        }
        onStateChange(xhrId, evt) {
          const pendingRequest = this.pendingRequests[xhrId];
          if (!pendingRequest) {
            return;
          }
          const xhr = pendingRequest.xhr;
          if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
            pendingRequest.onHeadersReceived();
            delete pendingRequest.onHeadersReceived;
          }
          if (xhr.readyState !== 4) {
            return;
          }
          if (!(xhrId in this.pendingRequests)) {
            return;
          }
          delete this.pendingRequests[xhrId];
          if (xhr.status === 0 && this.isHttp) {
            var _pendingRequest$onErr;
            (_pendingRequest$onErr = pendingRequest.onError) === null || _pendingRequest$onErr === void 0 ? void 0 : _pendingRequest$onErr.call(pendingRequest, xhr.status);
            return;
          }
          const xhrStatus = xhr.status || OK_RESPONSE;
          const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
          if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
            var _pendingRequest$onErr2;
            (_pendingRequest$onErr2 = pendingRequest.onError) === null || _pendingRequest$onErr2 === void 0 ? void 0 : _pendingRequest$onErr2.call(pendingRequest, xhr.status);
            return;
          }
          const chunk = getArrayBuffer(xhr);
          if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
            const rangeHeader = xhr.getResponseHeader("Content-Range");
            const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
            pendingRequest.onDone({
              begin: parseInt(matches[1], 10),
              chunk
            });
          } else if (chunk) {
            pendingRequest.onDone({
              begin: 0,
              chunk
            });
          } else {
            var _pendingRequest$onErr3;
            (_pendingRequest$onErr3 = pendingRequest.onError) === null || _pendingRequest$onErr3 === void 0 ? void 0 : _pendingRequest$onErr3.call(pendingRequest, xhr.status);
          }
        }
        getRequestXhr(xhrId) {
          return this.pendingRequests[xhrId].xhr;
        }
        isPendingRequest(xhrId) {
          return xhrId in this.pendingRequests;
        }
        abortRequest(xhrId) {
          const xhr = this.pendingRequests[xhrId].xhr;
          delete this.pendingRequests[xhrId];
          xhr.abort();
        }
      }
      class PDFNetworkStream {
        constructor(source) {
          this._source = source;
          this._manager = new NetworkManager(source.url, {
            httpHeaders: source.httpHeaders,
            withCredentials: source.withCredentials
          });
          this._rangeChunkSize = source.rangeChunkSize;
          this._fullRequestReader = null;
          this._rangeRequestReaders = [];
        }
        _onRangeRequestReaderClosed(reader) {
          const i = this._rangeRequestReaders.indexOf(reader);
          if (i >= 0) {
            this._rangeRequestReaders.splice(i, 1);
          }
        }
        getFullReader() {
          (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
          this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
          return this._fullRequestReader;
        }
        getRangeReader(begin, end) {
          const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
          reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
          this._rangeRequestReaders.push(reader);
          return reader;
        }
        cancelAllRequests(reason) {
          var _this$_fullRequestRea5;
          (_this$_fullRequestRea5 = this._fullRequestReader) === null || _this$_fullRequestRea5 === void 0 ? void 0 : _this$_fullRequestRea5.cancel(reason);
          for (const reader of this._rangeRequestReaders.slice(0)) {
            reader.cancel(reason);
          }
        }
      }
      exports.PDFNetworkStream = PDFNetworkStream;
      class PDFNetworkStreamFullRequestReader {
        constructor(manager, source) {
          this._manager = manager;
          const args = {
            onHeadersReceived: this._onHeadersReceived.bind(this),
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this)
          };
          this._url = source.url;
          this._fullRequestId = manager.requestFull(args);
          this._headersReceivedCapability = (0, _util.createPromiseCapability)();
          this._disableRange = source.disableRange || false;
          this._contentLength = source.length;
          this._rangeChunkSize = source.rangeChunkSize;
          if (!this._rangeChunkSize && !this._disableRange) {
            this._disableRange = true;
          }
          this._isStreamingSupported = false;
          this._isRangeSupported = false;
          this._cachedChunks = [];
          this._requests = [];
          this._done = false;
          this._storedError = undefined;
          this._filename = null;
          this.onProgress = null;
        }
        _onHeadersReceived() {
          const fullRequestXhrId = this._fullRequestId;
          const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
          const getResponseHeader = name => {
            return fullRequestXhr.getResponseHeader(name);
          };
          const {
            allowRangeRequests,
            suggestedLength
          } = (0, _network_utils.validateRangeRequestCapabilities)({
            getResponseHeader,
            isHttp: this._manager.isHttp,
            rangeChunkSize: this._rangeChunkSize,
            disableRange: this._disableRange
          });
          if (allowRangeRequests) {
            this._isRangeSupported = true;
          }
          this._contentLength = suggestedLength || this._contentLength;
          this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
          if (this._isRangeSupported) {
            this._manager.abortRequest(fullRequestXhrId);
          }
          this._headersReceivedCapability.resolve();
        }
        _onDone(data) {
          if (data) {
            if (this._requests.length > 0) {
              const requestCapability = this._requests.shift();
              requestCapability.resolve({
                value: data.chunk,
                done: false
              });
            } else {
              this._cachedChunks.push(data.chunk);
            }
          }
          this._done = true;
          if (this._cachedChunks.length > 0) {
            return;
          }
          for (const requestCapability of this._requests) {
            requestCapability.resolve({
              value: undefined,
              done: true
            });
          }
          this._requests.length = 0;
        }
        _onError(status) {
          this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
          this._headersReceivedCapability.reject(this._storedError);
          for (const requestCapability of this._requests) {
            requestCapability.reject(this._storedError);
          }
          this._requests.length = 0;
          this._cachedChunks.length = 0;
        }
        _onProgress(evt) {
          var _this$onProgress;
          (_this$onProgress = this.onProgress) === null || _this$onProgress === void 0 ? void 0 : _this$onProgress.call(this, {
            loaded: evt.loaded,
            total: evt.lengthComputable ? evt.total : this._contentLength
          });
        }
        get filename() {
          return this._filename;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        get contentLength() {
          return this._contentLength;
        }
        get headersReady() {
          return this._headersReceivedCapability.promise;
        }
        read() {
          var _this15 = this;
          return _asyncToGenerator(function* () {
            if (_this15._storedError) {
              throw _this15._storedError;
            }
            if (_this15._cachedChunks.length > 0) {
              const chunk = _this15._cachedChunks.shift();
              return {
                value: chunk,
                done: false
              };
            }
            if (_this15._done) {
              return {
                value: undefined,
                done: true
              };
            }
            const requestCapability = (0, _util.createPromiseCapability)();
            _this15._requests.push(requestCapability);
            return requestCapability.promise;
          })();
        }
        cancel(reason) {
          this._done = true;
          this._headersReceivedCapability.reject(reason);
          for (const requestCapability of this._requests) {
            requestCapability.resolve({
              value: undefined,
              done: true
            });
          }
          this._requests.length = 0;
          if (this._manager.isPendingRequest(this._fullRequestId)) {
            this._manager.abortRequest(this._fullRequestId);
          }
          this._fullRequestReader = null;
        }
      }
      class PDFNetworkStreamRangeRequestReader {
        constructor(manager, begin, end) {
          this._manager = manager;
          const args = {
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this)
          };
          this._url = manager.url;
          this._requestId = manager.requestRange(begin, end, args);
          this._requests = [];
          this._queuedChunk = null;
          this._done = false;
          this._storedError = undefined;
          this.onProgress = null;
          this.onClosed = null;
        }
        _close() {
          var _this$onClosed;
          (_this$onClosed = this.onClosed) === null || _this$onClosed === void 0 ? void 0 : _this$onClosed.call(this, this);
        }
        _onDone(data) {
          const chunk = data.chunk;
          if (this._requests.length > 0) {
            const requestCapability = this._requests.shift();
            requestCapability.resolve({
              value: chunk,
              done: false
            });
          } else {
            this._queuedChunk = chunk;
          }
          this._done = true;
          for (const requestCapability of this._requests) {
            requestCapability.resolve({
              value: undefined,
              done: true
            });
          }
          this._requests.length = 0;
          this._close();
        }
        _onError(status) {
          this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
          for (const requestCapability of this._requests) {
            requestCapability.reject(this._storedError);
          }
          this._requests.length = 0;
          this._queuedChunk = null;
        }
        _onProgress(evt) {
          if (!this.isStreamingSupported) {
            var _this$onProgress2;
            (_this$onProgress2 = this.onProgress) === null || _this$onProgress2 === void 0 ? void 0 : _this$onProgress2.call(this, {
              loaded: evt.loaded
            });
          }
        }
        get isStreamingSupported() {
          return false;
        }
        read() {
          var _this16 = this;
          return _asyncToGenerator(function* () {
            if (_this16._storedError) {
              throw _this16._storedError;
            }
            if (_this16._queuedChunk !== null) {
              const chunk = _this16._queuedChunk;
              _this16._queuedChunk = null;
              return {
                value: chunk,
                done: false
              };
            }
            if (_this16._done) {
              return {
                value: undefined,
                done: true
              };
            }
            const requestCapability = (0, _util.createPromiseCapability)();
            _this16._requests.push(requestCapability);
            return requestCapability.promise;
          })();
        }
        cancel(reason) {
          this._done = true;
          for (const requestCapability of this._requests) {
            requestCapability.resolve({
              value: undefined,
              done: true
            });
          }
          this._requests.length = 0;
          if (this._manager.isPendingRequest(this._requestId)) {
            this._manager.abortRequest(this._requestId);
          }
          this._close();
        }
      }

      /***/
    }), ( /* 29 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFFetchStream = void 0;
      var _util = __w_pdfjs_require__(1);
      var _network_utils = __w_pdfjs_require__(26);
      ;
      function createFetchOptions(headers, withCredentials, abortController) {
        return {
          method: "GET",
          headers,
          signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
          mode: "cors",
          credentials: withCredentials ? "include" : "same-origin",
          redirect: "follow"
        };
      }
      function createHeaders(httpHeaders) {
        const headers = new Headers();
        for (const property in httpHeaders) {
          const value = httpHeaders[property];
          if (typeof value === "undefined") {
            continue;
          }
          headers.append(property, value);
        }
        return headers;
      }
      class PDFFetchStream {
        constructor(source) {
          this.source = source;
          this.isHttp = /^https?:/i.test(source.url);
          this.httpHeaders = this.isHttp && source.httpHeaders || {};
          this._fullRequestReader = null;
          this._rangeRequestReaders = [];
        }
        get _progressiveDataLength() {
          var _this$_fullRequestRea6, _this$_fullRequestRea7;
          return (_this$_fullRequestRea6 = (_this$_fullRequestRea7 = this._fullRequestReader) === null || _this$_fullRequestRea7 === void 0 ? void 0 : _this$_fullRequestRea7._loaded) !== null && _this$_fullRequestRea6 !== void 0 ? _this$_fullRequestRea6 : 0;
        }
        getFullReader() {
          (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
          this._fullRequestReader = new PDFFetchStreamReader(this);
          return this._fullRequestReader;
        }
        getRangeReader(begin, end) {
          if (end <= this._progressiveDataLength) {
            return null;
          }
          const reader = new PDFFetchStreamRangeReader(this, begin, end);
          this._rangeRequestReaders.push(reader);
          return reader;
        }
        cancelAllRequests(reason) {
          if (this._fullRequestReader) {
            this._fullRequestReader.cancel(reason);
          }
          for (const reader of this._rangeRequestReaders.slice(0)) {
            reader.cancel(reason);
          }
        }
      }
      exports.PDFFetchStream = PDFFetchStream;
      class PDFFetchStreamReader {
        constructor(stream) {
          this._stream = stream;
          this._reader = null;
          this._loaded = 0;
          this._filename = null;
          const source = stream.source;
          this._withCredentials = source.withCredentials || false;
          this._contentLength = source.length;
          this._headersCapability = (0, _util.createPromiseCapability)();
          this._disableRange = source.disableRange || false;
          this._rangeChunkSize = source.rangeChunkSize;
          if (!this._rangeChunkSize && !this._disableRange) {
            this._disableRange = true;
          }
          if (typeof AbortController !== "undefined") {
            this._abortController = new AbortController();
          }
          this._isStreamingSupported = !source.disableStream;
          this._isRangeSupported = !source.disableRange;
          this._headers = createHeaders(this._stream.httpHeaders);
          const url = source.url;
          fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
            if (!(0, _network_utils.validateResponseStatus)(response.status)) {
              throw (0, _network_utils.createResponseStatusError)(response.status, url);
            }
            this._reader = response.body.getReader();
            this._headersCapability.resolve();
            const getResponseHeader = name => {
              return response.headers.get(name);
            };
            const {
              allowRangeRequests,
              suggestedLength
            } = (0, _network_utils.validateRangeRequestCapabilities)({
              getResponseHeader,
              isHttp: this._stream.isHttp,
              rangeChunkSize: this._rangeChunkSize,
              disableRange: this._disableRange
            });
            this._isRangeSupported = allowRangeRequests;
            this._contentLength = suggestedLength || this._contentLength;
            this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
            if (!this._isStreamingSupported && this._isRangeSupported) {
              this.cancel(new _util.AbortException("Streaming is disabled."));
            }
          }).catch(this._headersCapability.reject);
          this.onProgress = null;
        }
        get headersReady() {
          return this._headersCapability.promise;
        }
        get filename() {
          return this._filename;
        }
        get contentLength() {
          return this._contentLength;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        read() {
          var _this17 = this;
          return _asyncToGenerator(function* () {
            yield _this17._headersCapability.promise;
            const {
              value,
              done
            } = yield _this17._reader.read();
            if (done) {
              return {
                value,
                done
              };
            }
            _this17._loaded += value.byteLength;
            if (_this17.onProgress) {
              _this17.onProgress({
                loaded: _this17._loaded,
                total: _this17._contentLength
              });
            }
            const buffer = new Uint8Array(value).buffer;
            return {
              value: buffer,
              done: false
            };
          })();
        }
        cancel(reason) {
          if (this._reader) {
            this._reader.cancel(reason);
          }
          if (this._abortController) {
            this._abortController.abort();
          }
        }
      }
      class PDFFetchStreamRangeReader {
        constructor(stream, begin, end) {
          this._stream = stream;
          this._reader = null;
          this._loaded = 0;
          const source = stream.source;
          this._withCredentials = source.withCredentials || false;
          this._readCapability = (0, _util.createPromiseCapability)();
          this._isStreamingSupported = !source.disableStream;
          if (typeof AbortController !== "undefined") {
            this._abortController = new AbortController();
          }
          this._headers = createHeaders(this._stream.httpHeaders);
          this._headers.append("Range", `bytes=${begin}-${end - 1}`);
          const url = source.url;
          fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
            if (!(0, _network_utils.validateResponseStatus)(response.status)) {
              throw (0, _network_utils.createResponseStatusError)(response.status, url);
            }
            this._readCapability.resolve();
            this._reader = response.body.getReader();
          }).catch(this._readCapability.reject);
          this.onProgress = null;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        read() {
          var _this18 = this;
          return _asyncToGenerator(function* () {
            yield _this18._readCapability.promise;
            const {
              value,
              done
            } = yield _this18._reader.read();
            if (done) {
              return {
                value,
                done
              };
            }
            _this18._loaded += value.byteLength;
            if (_this18.onProgress) {
              _this18.onProgress({
                loaded: _this18._loaded
              });
            }
            const buffer = new Uint8Array(value).buffer;
            return {
              value: buffer,
              done: false
            };
          })();
        }
        cancel(reason) {
          if (this._reader) {
            this._reader.cancel(reason);
          }
          if (this._abortController) {
            this._abortController.abort();
          }
        }
      }

      /***/
    }
    /******/)];
    /************************************************************************/
    /******/ // The module cache
    /******/
    var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/
    function __w_pdfjs_require__(moduleId) {
      /******/ // Check if module is in cache
      /******/var cachedModule = __webpack_module_cache__[moduleId];
      /******/
      if (cachedModule !== undefined) {
        /******/return cachedModule.exports;
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/
      var module = __webpack_module_cache__[moduleId] = {
        /******/ // no module.id needed
        /******/ // no module.loaded needed
        /******/exports: {}
        /******/
      };
      /******/
      /******/ // Execute the module function
      /******/
      __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
      /******/
      /******/ // Return the exports of the module
      /******/
      return module.exports;
      /******/
    }
    /******/
    /************************************************************************/
    var __webpack_exports__ = {};
    // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
    (() => {
      var exports = __webpack_exports__;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "AnnotationLayer", {
        enumerable: true,
        get: function () {
          return _annotation_layer.AnnotationLayer;
        }
      });
      Object.defineProperty(exports, "AnnotationMode", {
        enumerable: true,
        get: function () {
          return _util.AnnotationMode;
        }
      });
      Object.defineProperty(exports, "CMapCompressionType", {
        enumerable: true,
        get: function () {
          return _util.CMapCompressionType;
        }
      });
      Object.defineProperty(exports, "GlobalWorkerOptions", {
        enumerable: true,
        get: function () {
          return _worker_options.GlobalWorkerOptions;
        }
      });
      Object.defineProperty(exports, "InvalidPDFException", {
        enumerable: true,
        get: function () {
          return _util.InvalidPDFException;
        }
      });
      Object.defineProperty(exports, "LoopbackPort", {
        enumerable: true,
        get: function () {
          return _api.LoopbackPort;
        }
      });
      Object.defineProperty(exports, "MissingPDFException", {
        enumerable: true,
        get: function () {
          return _util.MissingPDFException;
        }
      });
      Object.defineProperty(exports, "OPS", {
        enumerable: true,
        get: function () {
          return _util.OPS;
        }
      });
      Object.defineProperty(exports, "PDFDataRangeTransport", {
        enumerable: true,
        get: function () {
          return _api.PDFDataRangeTransport;
        }
      });
      Object.defineProperty(exports, "PDFDateString", {
        enumerable: true,
        get: function () {
          return _display_utils.PDFDateString;
        }
      });
      Object.defineProperty(exports, "PDFWorker", {
        enumerable: true,
        get: function () {
          return _api.PDFWorker;
        }
      });
      Object.defineProperty(exports, "PasswordResponses", {
        enumerable: true,
        get: function () {
          return _util.PasswordResponses;
        }
      });
      Object.defineProperty(exports, "PermissionFlag", {
        enumerable: true,
        get: function () {
          return _util.PermissionFlag;
        }
      });
      Object.defineProperty(exports, "PixelsPerInch", {
        enumerable: true,
        get: function () {
          return _display_utils.PixelsPerInch;
        }
      });
      Object.defineProperty(exports, "RenderingCancelledException", {
        enumerable: true,
        get: function () {
          return _display_utils.RenderingCancelledException;
        }
      });
      Object.defineProperty(exports, "SVGGraphics", {
        enumerable: true,
        get: function () {
          return _svg.SVGGraphics;
        }
      });
      Object.defineProperty(exports, "UNSUPPORTED_FEATURES", {
        enumerable: true,
        get: function () {
          return _util.UNSUPPORTED_FEATURES;
        }
      });
      Object.defineProperty(exports, "UnexpectedResponseException", {
        enumerable: true,
        get: function () {
          return _util.UnexpectedResponseException;
        }
      });
      Object.defineProperty(exports, "Util", {
        enumerable: true,
        get: function () {
          return _util.Util;
        }
      });
      Object.defineProperty(exports, "VerbosityLevel", {
        enumerable: true,
        get: function () {
          return _util.VerbosityLevel;
        }
      });
      Object.defineProperty(exports, "XfaLayer", {
        enumerable: true,
        get: function () {
          return _xfa_layer.XfaLayer;
        }
      });
      Object.defineProperty(exports, "build", {
        enumerable: true,
        get: function () {
          return _api.build;
        }
      });
      Object.defineProperty(exports, "createPromiseCapability", {
        enumerable: true,
        get: function () {
          return _util.createPromiseCapability;
        }
      });
      Object.defineProperty(exports, "createValidAbsoluteUrl", {
        enumerable: true,
        get: function () {
          return _util.createValidAbsoluteUrl;
        }
      });
      Object.defineProperty(exports, "getDocument", {
        enumerable: true,
        get: function () {
          return _api.getDocument;
        }
      });
      Object.defineProperty(exports, "getFilenameFromUrl", {
        enumerable: true,
        get: function () {
          return _display_utils.getFilenameFromUrl;
        }
      });
      Object.defineProperty(exports, "getPdfFilenameFromUrl", {
        enumerable: true,
        get: function () {
          return _display_utils.getPdfFilenameFromUrl;
        }
      });
      Object.defineProperty(exports, "getXfaPageViewport", {
        enumerable: true,
        get: function () {
          return _display_utils.getXfaPageViewport;
        }
      });
      Object.defineProperty(exports, "isPdfFile", {
        enumerable: true,
        get: function () {
          return _display_utils.isPdfFile;
        }
      });
      Object.defineProperty(exports, "loadScript", {
        enumerable: true,
        get: function () {
          return _display_utils.loadScript;
        }
      });
      Object.defineProperty(exports, "renderTextLayer", {
        enumerable: true,
        get: function () {
          return _text_layer.renderTextLayer;
        }
      });
      Object.defineProperty(exports, "shadow", {
        enumerable: true,
        get: function () {
          return _util.shadow;
        }
      });
      Object.defineProperty(exports, "version", {
        enumerable: true,
        get: function () {
          return _api.version;
        }
      });
      var _util = __w_pdfjs_require__(1);
      var _api = __w_pdfjs_require__(4);
      var _display_utils = __w_pdfjs_require__(5);
      var _annotation_layer = __w_pdfjs_require__(20);
      var _worker_options = __w_pdfjs_require__(13);
      var _is_node = __w_pdfjs_require__(3);
      var _text_layer = __w_pdfjs_require__(23);
      var _svg = __w_pdfjs_require__(24);
      var _xfa_layer = __w_pdfjs_require__(22);
      const pdfjsVersion = '2.14.305';
      const pdfjsBuild = 'eaaa8b4ad';
      {
        if (_is_node.isNodeJS) {
          const {
            PDFNodeStream
          } = __w_pdfjs_require__(25);
          (0, _api.setPDFNetworkStreamFactory)(params => {
            return new PDFNodeStream(params);
          });
        } else {
          const {
            PDFNetworkStream
          } = __w_pdfjs_require__(28);
          const {
            PDFFetchStream
          } = __w_pdfjs_require__(29);
          (0, _api.setPDFNetworkStreamFactory)(params => {
            if ((0, _display_utils.isValidFetchUrl)(params.url)) {
              return new PDFFetchStream(params);
            }
            return new PDFNetworkStream(params);
          });
        }
      }
    })();

    /******/
    return __webpack_exports__;
    /******/
  })();
});

/***/ }),

/***/ 90638:
/*!***************************************************!*\
  !*** ./node_modules/pdfjs-dist/web/pdf_viewer.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _classPrivateMethodInitSpec = (__webpack_require__(/*! ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js */ 43798)["default"]);
var _classPrivateFieldInitSpec = (__webpack_require__(/*! ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js */ 97218)["default"]);
var _asyncToGenerator = (__webpack_require__(/*! ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/asyncToGenerator.js */ 79717)["default"]);
function _classPrivateGetter(s, r, a) { return a(_assertClassBrand(s, r)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else {}
})(this, () => {
  return /******/(() => {
    // webpackBootstrap
    /******/
    "use strict";

    /******/
    var __webpack_modules__ = [
      /* 0 */
    , ( /* 1 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DefaultXfaLayerFactory = exports.DefaultTextLayerFactory = exports.DefaultStructTreeLayerFactory = exports.DefaultAnnotationLayerFactory = void 0;
      var _annotation_layer_builder = __w_pdfjs_require__(2);
      var _l10n_utils = __w_pdfjs_require__(4);
      var _pdf_link_service = __w_pdfjs_require__(5);
      var _struct_tree_layer_builder = __w_pdfjs_require__(7);
      var _text_layer_builder = __w_pdfjs_require__(8);
      var _xfa_layer_builder = __w_pdfjs_require__(9);
      class DefaultAnnotationLayerFactory {
        createAnnotationLayerBuilder(pageDiv, pdfPage, annotationStorage = null, imageResourcesPath = "", renderForms = true, l10n = _l10n_utils.NullL10n, enableScripting = false, hasJSActionsPromise = null, mouseState = null, fieldObjectsPromise = null, annotationCanvasMap = null) {
          return new _annotation_layer_builder.AnnotationLayerBuilder({
            pageDiv,
            pdfPage,
            imageResourcesPath,
            renderForms,
            linkService: new _pdf_link_service.SimpleLinkService(),
            l10n,
            annotationStorage,
            enableScripting,
            hasJSActionsPromise,
            fieldObjectsPromise,
            mouseState,
            annotationCanvasMap
          });
        }
      }
      exports.DefaultAnnotationLayerFactory = DefaultAnnotationLayerFactory;
      class DefaultStructTreeLayerFactory {
        createStructTreeLayerBuilder(pdfPage) {
          return new _struct_tree_layer_builder.StructTreeLayerBuilder({
            pdfPage
          });
        }
      }
      exports.DefaultStructTreeLayerFactory = DefaultStructTreeLayerFactory;
      class DefaultTextLayerFactory {
        createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus, highlighter) {
          return new _text_layer_builder.TextLayerBuilder({
            textLayerDiv,
            pageIndex,
            viewport,
            enhanceTextSelection,
            eventBus,
            highlighter
          });
        }
      }
      exports.DefaultTextLayerFactory = DefaultTextLayerFactory;
      class DefaultXfaLayerFactory {
        createXfaLayerBuilder(pageDiv, pdfPage, annotationStorage = null, xfaHtml = null) {
          return new _xfa_layer_builder.XfaLayerBuilder({
            pageDiv,
            pdfPage,
            annotationStorage,
            linkService: new _pdf_link_service.SimpleLinkService(),
            xfaHtml
          });
        }
      }
      exports.DefaultXfaLayerFactory = DefaultXfaLayerFactory;

      /***/
    }), ( /* 2 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.AnnotationLayerBuilder = void 0;
      var _pdfjsLib = __w_pdfjs_require__(3);
      var _l10n_utils = __w_pdfjs_require__(4);
      class AnnotationLayerBuilder {
        constructor({
          pageDiv,
          pdfPage,
          linkService,
          downloadManager,
          annotationStorage = null,
          imageResourcesPath = "",
          renderForms = true,
          l10n = _l10n_utils.NullL10n,
          enableScripting = false,
          hasJSActionsPromise = null,
          fieldObjectsPromise = null,
          mouseState = null,
          annotationCanvasMap = null
        }) {
          this.pageDiv = pageDiv;
          this.pdfPage = pdfPage;
          this.linkService = linkService;
          this.downloadManager = downloadManager;
          this.imageResourcesPath = imageResourcesPath;
          this.renderForms = renderForms;
          this.l10n = l10n;
          this.annotationStorage = annotationStorage;
          this.enableScripting = enableScripting;
          this._hasJSActionsPromise = hasJSActionsPromise;
          this._fieldObjectsPromise = fieldObjectsPromise;
          this._mouseState = mouseState;
          this._annotationCanvasMap = annotationCanvasMap;
          this.div = null;
          this._cancelled = false;
        }
        render(viewport, intent = "display") {
          var _this = this;
          return _asyncToGenerator(function* () {
            const [annotations, hasJSActions = false, fieldObjects = null] = yield Promise.all([_this.pdfPage.getAnnotations({
              intent
            }), _this._hasJSActionsPromise, _this._fieldObjectsPromise]);
            if (_this._cancelled || annotations.length === 0) {
              return;
            }
            const parameters = {
              viewport: viewport.clone({
                dontFlip: true
              }),
              div: _this.div,
              annotations,
              page: _this.pdfPage,
              imageResourcesPath: _this.imageResourcesPath,
              renderForms: _this.renderForms,
              linkService: _this.linkService,
              downloadManager: _this.downloadManager,
              annotationStorage: _this.annotationStorage,
              enableScripting: _this.enableScripting,
              hasJSActions,
              fieldObjects,
              mouseState: _this._mouseState,
              annotationCanvasMap: _this._annotationCanvasMap
            };
            if (_this.div) {
              _pdfjsLib.AnnotationLayer.update(parameters);
            } else {
              _this.div = document.createElement("div");
              _this.div.className = "annotationLayer";
              _this.pageDiv.appendChild(_this.div);
              parameters.div = _this.div;
              _pdfjsLib.AnnotationLayer.render(parameters);
              _this.l10n.translate(_this.div);
            }
          })();
        }
        cancel() {
          this._cancelled = true;
        }
        hide() {
          if (!this.div) {
            return;
          }
          this.div.hidden = true;
        }
      }
      exports.AnnotationLayerBuilder = AnnotationLayerBuilder;

      /***/
    }), ( /* 3 */
    /***/module => {
      let pdfjsLib;
      if (typeof window !== "undefined" && window["pdfjs-dist/build/pdf"]) {
        pdfjsLib = window["pdfjs-dist/build/pdf"];
      } else {
        pdfjsLib = __webpack_require__(/*! ../build/pdf.js */ 7787);
      }
      module.exports = pdfjsLib;

      /***/
    }), ( /* 4 */
    /***/(__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.NullL10n = void 0;
      exports.fixupLangCode = fixupLangCode;
      exports.getL10nFallback = getL10nFallback;
      const DEFAULT_L10N_STRINGS = {
        of_pages: "of {{pagesCount}}",
        page_of_pages: "({{pageNumber}} of {{pagesCount}})",
        document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
        document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
        document_properties_date_string: "{{date}}, {{time}}",
        document_properties_page_size_unit_inches: "in",
        document_properties_page_size_unit_millimeters: "mm",
        document_properties_page_size_orientation_portrait: "portrait",
        document_properties_page_size_orientation_landscape: "landscape",
        document_properties_page_size_name_a3: "A3",
        document_properties_page_size_name_a4: "A4",
        document_properties_page_size_name_letter: "Letter",
        document_properties_page_size_name_legal: "Legal",
        document_properties_page_size_dimension_string: "{{width}}  {{height}} {{unit}} ({{orientation}})",
        document_properties_page_size_dimension_name_string: "{{width}}  {{height}} {{unit}} ({{name}}, {{orientation}})",
        document_properties_linearized_yes: "Yes",
        document_properties_linearized_no: "No",
        print_progress_percent: "{{progress}}%",
        "toggle_sidebar.title": "Toggle Sidebar",
        "toggle_sidebar_notification2.title": "Toggle Sidebar (document contains outline/attachments/layers)",
        additional_layers: "Additional Layers",
        page_landmark: "Page {{page}}",
        thumb_page_title: "Page {{page}}",
        thumb_page_canvas: "Thumbnail of Page {{page}}",
        find_reached_top: "Reached top of document, continued from bottom",
        find_reached_bottom: "Reached end of document, continued from top",
        "find_match_count[one]": "{{current}} of {{total}} match",
        "find_match_count[other]": "{{current}} of {{total}} matches",
        "find_match_count_limit[one]": "More than {{limit}} match",
        "find_match_count_limit[other]": "More than {{limit}} matches",
        find_not_found: "Phrase not found",
        error_version_info: "PDF.js v{{version}} (build: {{build}})",
        error_message: "Message: {{message}}",
        error_stack: "Stack: {{stack}}",
        error_file: "File: {{file}}",
        error_line: "Line: {{line}}",
        rendering_error: "An error occurred while rendering the page.",
        page_scale_width: "Page Width",
        page_scale_fit: "Page Fit",
        page_scale_auto: "Automatic Zoom",
        page_scale_actual: "Actual Size",
        page_scale_percent: "{{scale}}%",
        loading: "Loading",
        loading_error: "An error occurred while loading the PDF.",
        invalid_file_error: "Invalid or corrupted PDF file.",
        missing_file_error: "Missing PDF file.",
        unexpected_response_error: "Unexpected server response.",
        printing_not_supported: "Warning: Printing is not fully supported by this browser.",
        printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
        web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts."
      };
      function getL10nFallback(key, args) {
        switch (key) {
          case "find_match_count":
            key = `find_match_count[${args.total === 1 ? "one" : "other"}]`;
            break;
          case "find_match_count_limit":
            key = `find_match_count_limit[${args.limit === 1 ? "one" : "other"}]`;
            break;
        }
        return DEFAULT_L10N_STRINGS[key] || "";
      }
      const PARTIAL_LANG_CODES = {
        en: "en-US",
        es: "es-ES",
        fy: "fy-NL",
        ga: "ga-IE",
        gu: "gu-IN",
        hi: "hi-IN",
        hy: "hy-AM",
        nb: "nb-NO",
        ne: "ne-NP",
        nn: "nn-NO",
        pa: "pa-IN",
        pt: "pt-PT",
        sv: "sv-SE",
        zh: "zh-CN"
      };
      function fixupLangCode(langCode) {
        return PARTIAL_LANG_CODES[langCode === null || langCode === void 0 ? void 0 : langCode.toLowerCase()] || langCode;
      }
      function formatL10nValue(text, args) {
        if (!args) {
          return text;
        }
        return text.replace(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => {
          return name in args ? args[name] : "{{" + name + "}}";
        });
      }
      const NullL10n = {
        getLanguage() {
          return _asyncToGenerator(function* () {
            return "en-us";
          })();
        },
        getDirection() {
          return _asyncToGenerator(function* () {
            return "ltr";
          })();
        },
        get(key, args = null, fallback = getL10nFallback(key, args)) {
          return _asyncToGenerator(function* () {
            return formatL10nValue(fallback, args);
          })();
        },
        translate(element) {
          return _asyncToGenerator(function* () {})();
        }
      };
      exports.NullL10n = NullL10n;

      /***/
    }), ( /* 5 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SimpleLinkService = exports.PDFLinkService = exports.LinkTarget = void 0;
      var _ui_utils = __w_pdfjs_require__(6);
      const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
      const LinkTarget = {
        NONE: 0,
        SELF: 1,
        BLANK: 2,
        PARENT: 3,
        TOP: 4
      };
      exports.LinkTarget = LinkTarget;
      function addLinkAttributes(link, {
        url,
        target,
        rel,
        enabled = true
      } = {}) {
        if (!url || typeof url !== "string") {
          throw new Error('A valid "url" parameter must provided.');
        }
        const urlNullRemoved = (0, _ui_utils.removeNullCharacters)(url);
        if (enabled) {
          link.href = link.title = urlNullRemoved;
        } else {
          link.href = "";
          link.title = `Disabled: ${urlNullRemoved}`;
          link.onclick = () => {
            return false;
          };
        }
        let targetStr = "";
        switch (target) {
          case LinkTarget.NONE:
            break;
          case LinkTarget.SELF:
            targetStr = "_self";
            break;
          case LinkTarget.BLANK:
            targetStr = "_blank";
            break;
          case LinkTarget.PARENT:
            targetStr = "_parent";
            break;
          case LinkTarget.TOP:
            targetStr = "_top";
            break;
        }
        link.target = targetStr;
        link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
      }
      var _pagesRefCache = /*#__PURE__*/new WeakMap();
      var _PDFLinkService_brand = /*#__PURE__*/new WeakSet();
      class PDFLinkService {
        constructor({
          eventBus,
          externalLinkTarget = null,
          externalLinkRel = null,
          ignoreDestinationZoom = false
        } = {}) {
          _classPrivateMethodInitSpec(this, _PDFLinkService_brand);
          _classPrivateFieldInitSpec(this, _pagesRefCache, new Map());
          this.eventBus = eventBus;
          this.externalLinkTarget = externalLinkTarget;
          this.externalLinkRel = externalLinkRel;
          this.externalLinkEnabled = true;
          this._ignoreDestinationZoom = ignoreDestinationZoom;
          this.baseUrl = null;
          this.pdfDocument = null;
          this.pdfViewer = null;
          this.pdfHistory = null;
        }
        setDocument(pdfDocument, baseUrl = null) {
          this.baseUrl = baseUrl;
          this.pdfDocument = pdfDocument;
          _classPrivateFieldGet(_pagesRefCache, this).clear();
        }
        setViewer(pdfViewer) {
          this.pdfViewer = pdfViewer;
        }
        setHistory(pdfHistory) {
          this.pdfHistory = pdfHistory;
        }
        get pagesCount() {
          return this.pdfDocument ? this.pdfDocument.numPages : 0;
        }
        get page() {
          return this.pdfViewer.currentPageNumber;
        }
        set page(value) {
          this.pdfViewer.currentPageNumber = value;
        }
        get rotation() {
          return this.pdfViewer.pagesRotation;
        }
        set rotation(value) {
          this.pdfViewer.pagesRotation = value;
        }
        goToDestination(dest) {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            if (!_this2.pdfDocument) {
              return;
            }
            let namedDest, explicitDest;
            if (typeof dest === "string") {
              namedDest = dest;
              explicitDest = yield _this2.pdfDocument.getDestination(dest);
            } else {
              namedDest = null;
              explicitDest = yield dest;
            }
            if (!Array.isArray(explicitDest)) {
              console.error(`PDFLinkService.goToDestination: "${explicitDest}" is not ` + `a valid destination array, for dest="${dest}".`);
              return;
            }
            _assertClassBrand(_PDFLinkService_brand, _this2, _goToDestinationHelper).call(_this2, dest, namedDest, explicitDest);
          })();
        }
        goToPage(val) {
          if (!this.pdfDocument) {
            return;
          }
          const pageNumber = typeof val === "string" && this.pdfViewer.pageLabelToPageNumber(val) || val | 0;
          if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
            console.error(`PDFLinkService.goToPage: "${val}" is not a valid page.`);
            return;
          }
          if (this.pdfHistory) {
            this.pdfHistory.pushCurrentPosition();
            this.pdfHistory.pushPage(pageNumber);
          }
          this.pdfViewer.scrollPageIntoView({
            pageNumber
          });
        }
        addLinkAttributes(link, url, newWindow = false) {
          addLinkAttributes(link, {
            url,
            target: newWindow ? LinkTarget.BLANK : this.externalLinkTarget,
            rel: this.externalLinkRel,
            enabled: this.externalLinkEnabled
          });
        }
        getDestinationHash(dest) {
          if (typeof dest === "string") {
            if (dest.length > 0) {
              return this.getAnchorUrl("#" + escape(dest));
            }
          } else if (Array.isArray(dest)) {
            const str = JSON.stringify(dest);
            if (str.length > 0) {
              return this.getAnchorUrl("#" + escape(str));
            }
          }
          return this.getAnchorUrl("");
        }
        getAnchorUrl(anchor) {
          return (this.baseUrl || "") + anchor;
        }
        setHash(hash) {
          if (!this.pdfDocument) {
            return;
          }
          let pageNumber, dest;
          if (hash.includes("=")) {
            const params = (0, _ui_utils.parseQueryString)(hash);
            if (params.has("search")) {
              this.eventBus.dispatch("findfromurlhash", {
                source: this,
                query: params.get("search").replace(/"/g, ""),
                phraseSearch: params.get("phrase") === "true"
              });
            }
            if (params.has("page")) {
              pageNumber = params.get("page") | 0 || 1;
            }
            if (params.has("zoom")) {
              const zoomArgs = params.get("zoom").split(",");
              const zoomArg = zoomArgs[0];
              const zoomArgNumber = parseFloat(zoomArg);
              if (!zoomArg.includes("Fit")) {
                dest = [null, {
                  name: "XYZ"
                }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
              } else {
                if (zoomArg === "Fit" || zoomArg === "FitB") {
                  dest = [null, {
                    name: zoomArg
                  }];
                } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
                  dest = [null, {
                    name: zoomArg
                  }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
                } else if (zoomArg === "FitR") {
                  if (zoomArgs.length !== 5) {
                    console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
                  } else {
                    dest = [null, {
                      name: zoomArg
                    }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
                  }
                } else {
                  console.error(`PDFLinkService.setHash: "${zoomArg}" is not a valid zoom value.`);
                }
              }
            }
            if (dest) {
              this.pdfViewer.scrollPageIntoView({
                pageNumber: pageNumber || this.page,
                destArray: dest,
                allowNegativeOffset: true
              });
            } else if (pageNumber) {
              this.page = pageNumber;
            }
            if (params.has("pagemode")) {
              this.eventBus.dispatch("pagemode", {
                source: this,
                mode: params.get("pagemode")
              });
            }
            if (params.has("nameddest")) {
              this.goToDestination(params.get("nameddest"));
            }
          } else {
            dest = unescape(hash);
            try {
              dest = JSON.parse(dest);
              if (!Array.isArray(dest)) {
                dest = dest.toString();
              }
            } catch (ex) {}
            if (typeof dest === "string" || _isValidExplicitDestination.call(PDFLinkService, dest)) {
              this.goToDestination(dest);
              return;
            }
            console.error(`PDFLinkService.setHash: "${unescape(hash)}" is not a valid destination.`);
          }
        }
        executeNamedAction(action) {
          var _this$pdfHistory, _this$pdfHistory2;
          switch (action) {
            case "GoBack":
              (_this$pdfHistory = this.pdfHistory) === null || _this$pdfHistory === void 0 ? void 0 : _this$pdfHistory.back();
              break;
            case "GoForward":
              (_this$pdfHistory2 = this.pdfHistory) === null || _this$pdfHistory2 === void 0 ? void 0 : _this$pdfHistory2.forward();
              break;
            case "NextPage":
              this.pdfViewer.nextPage();
              break;
            case "PrevPage":
              this.pdfViewer.previousPage();
              break;
            case "LastPage":
              this.page = this.pagesCount;
              break;
            case "FirstPage":
              this.page = 1;
              break;
            default:
              break;
          }
          this.eventBus.dispatch("namedaction", {
            source: this,
            action
          });
        }
        cachePageRef(pageNum, pageRef) {
          if (!pageRef) {
            return;
          }
          const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
          _classPrivateFieldGet(_pagesRefCache, this).set(refStr, pageNum);
        }
        _cachedPageNumber(pageRef) {
          if (!pageRef) {
            return null;
          }
          const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`;
          return _classPrivateFieldGet(_pagesRefCache, this).get(refStr) || null;
        }
        isPageVisible(pageNumber) {
          return this.pdfViewer.isPageVisible(pageNumber);
        }
        isPageCached(pageNumber) {
          return this.pdfViewer.isPageCached(pageNumber);
        }
      }
      function _goToDestinationHelper(rawDest, namedDest = null, explicitDest) {
        const destRef = explicitDest[0];
        let pageNumber;
        if (typeof destRef === "object" && destRef !== null) {
          pageNumber = this._cachedPageNumber(destRef);
          if (!pageNumber) {
            this.pdfDocument.getPageIndex(destRef).then(pageIndex => {
              this.cachePageRef(pageIndex + 1, destRef);
              _assertClassBrand(_PDFLinkService_brand, this, _goToDestinationHelper).call(this, rawDest, namedDest, explicitDest);
            }).catch(() => {
              console.error(`PDFLinkService.#goToDestinationHelper: "${destRef}" is not ` + `a valid page reference, for dest="${rawDest}".`);
            });
            return;
          }
        } else if (Number.isInteger(destRef)) {
          pageNumber = destRef + 1;
        } else {
          console.error(`PDFLinkService.#goToDestinationHelper: "${destRef}" is not ` + `a valid destination reference, for dest="${rawDest}".`);
          return;
        }
        if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {
          console.error(`PDFLinkService.#goToDestinationHelper: "${pageNumber}" is not ` + `a valid page number, for dest="${rawDest}".`);
          return;
        }
        if (this.pdfHistory) {
          this.pdfHistory.pushCurrentPosition();
          this.pdfHistory.push({
            namedDest,
            explicitDest,
            pageNumber
          });
        }
        this.pdfViewer.scrollPageIntoView({
          pageNumber,
          destArray: explicitDest,
          ignoreDestinationZoom: this._ignoreDestinationZoom
        });
      }
      function _isValidExplicitDestination(dest) {
        if (!Array.isArray(dest)) {
          return false;
        }
        const destLength = dest.length;
        if (destLength < 2) {
          return false;
        }
        const page = dest[0];
        if (!(typeof page === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
          return false;
        }
        const zoom = dest[1];
        if (!(typeof zoom === "object" && typeof zoom.name === "string")) {
          return false;
        }
        let allowNull = true;
        switch (zoom.name) {
          case "XYZ":
            if (destLength !== 5) {
              return false;
            }
            break;
          case "Fit":
          case "FitB":
            return destLength === 2;
          case "FitH":
          case "FitBH":
          case "FitV":
          case "FitBV":
            if (destLength !== 3) {
              return false;
            }
            break;
          case "FitR":
            if (destLength !== 6) {
              return false;
            }
            allowNull = false;
            break;
          default:
            return false;
        }
        for (let i = 2; i < destLength; i++) {
          const param = dest[i];
          if (!(typeof param === "number" || allowNull && param === null)) {
            return false;
          }
        }
        return true;
      }
      exports.PDFLinkService = PDFLinkService;
      class SimpleLinkService {
        constructor() {
          this.externalLinkEnabled = true;
        }
        get pagesCount() {
          return 0;
        }
        get page() {
          return 0;
        }
        set page(value) {}
        get rotation() {
          return 0;
        }
        set rotation(value) {}
        goToDestination(dest) {
          return _asyncToGenerator(function* () {})();
        }
        goToPage(val) {}
        addLinkAttributes(link, url, newWindow = false) {
          addLinkAttributes(link, {
            url,
            enabled: this.externalLinkEnabled
          });
        }
        getDestinationHash(dest) {
          return "#";
        }
        getAnchorUrl(hash) {
          return "#";
        }
        setHash(hash) {}
        executeNamedAction(action) {}
        cachePageRef(pageNum, pageRef) {}
        isPageVisible(pageNumber) {
          return true;
        }
        isPageCached(pageNumber) {
          return true;
        }
      }
      exports.SimpleLinkService = SimpleLinkService;

      /***/
    }), ( /* 6 */
    /***/(__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.animationStarted = exports.VERTICAL_PADDING = exports.UNKNOWN_SCALE = exports.TextLayerMode = exports.SpreadMode = exports.SidebarView = exports.ScrollMode = exports.SCROLLBAR_PADDING = exports.RenderingStates = exports.RendererType = exports.ProgressBar = exports.PresentationModeState = exports.OutputScale = exports.MIN_SCALE = exports.MAX_SCALE = exports.MAX_AUTO_SCALE = exports.DEFAULT_SCALE_VALUE = exports.DEFAULT_SCALE_DELTA = exports.DEFAULT_SCALE = exports.AutoPrintRegExp = void 0;
      exports.apiPageLayoutToViewerModes = apiPageLayoutToViewerModes;
      exports.apiPageModeToSidebarView = apiPageModeToSidebarView;
      exports.approximateFraction = approximateFraction;
      exports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;
      exports.binarySearchFirstItem = binarySearchFirstItem;
      exports.getActiveOrFocusedElement = getActiveOrFocusedElement;
      exports.getPageSizeInches = getPageSizeInches;
      exports.getVisibleElements = getVisibleElements;
      exports.isPortraitOrientation = isPortraitOrientation;
      exports.isValidRotation = isValidRotation;
      exports.isValidScrollMode = isValidScrollMode;
      exports.isValidSpreadMode = isValidSpreadMode;
      exports.noContextMenuHandler = noContextMenuHandler;
      exports.normalizeWheelEventDelta = normalizeWheelEventDelta;
      exports.normalizeWheelEventDirection = normalizeWheelEventDirection;
      exports.parseQueryString = parseQueryString;
      exports.removeNullCharacters = removeNullCharacters;
      exports.roundToDivide = roundToDivide;
      exports.scrollIntoView = scrollIntoView;
      exports.watchScroll = watchScroll;
      const DEFAULT_SCALE_VALUE = "auto";
      exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
      const DEFAULT_SCALE = 1.0;
      exports.DEFAULT_SCALE = DEFAULT_SCALE;
      const DEFAULT_SCALE_DELTA = 1.1;
      exports.DEFAULT_SCALE_DELTA = DEFAULT_SCALE_DELTA;
      const MIN_SCALE = 0.1;
      exports.MIN_SCALE = MIN_SCALE;
      const MAX_SCALE = 10.0;
      exports.MAX_SCALE = MAX_SCALE;
      const UNKNOWN_SCALE = 0;
      exports.UNKNOWN_SCALE = UNKNOWN_SCALE;
      const MAX_AUTO_SCALE = 1.25;
      exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
      const SCROLLBAR_PADDING = 40;
      exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
      const VERTICAL_PADDING = 5;
      exports.VERTICAL_PADDING = VERTICAL_PADDING;
      const RenderingStates = {
        INITIAL: 0,
        RUNNING: 1,
        PAUSED: 2,
        FINISHED: 3
      };
      exports.RenderingStates = RenderingStates;
      const PresentationModeState = {
        UNKNOWN: 0,
        NORMAL: 1,
        CHANGING: 2,
        FULLSCREEN: 3
      };
      exports.PresentationModeState = PresentationModeState;
      const SidebarView = {
        UNKNOWN: -1,
        NONE: 0,
        THUMBS: 1,
        OUTLINE: 2,
        ATTACHMENTS: 3,
        LAYERS: 4
      };
      exports.SidebarView = SidebarView;
      const RendererType = {
        CANVAS: "canvas",
        SVG: "svg"
      };
      exports.RendererType = RendererType;
      const TextLayerMode = {
        DISABLE: 0,
        ENABLE: 1,
        ENABLE_ENHANCE: 2
      };
      exports.TextLayerMode = TextLayerMode;
      const ScrollMode = {
        UNKNOWN: -1,
        VERTICAL: 0,
        HORIZONTAL: 1,
        WRAPPED: 2,
        PAGE: 3
      };
      exports.ScrollMode = ScrollMode;
      const SpreadMode = {
        UNKNOWN: -1,
        NONE: 0,
        ODD: 1,
        EVEN: 2
      };
      exports.SpreadMode = SpreadMode;
      const AutoPrintRegExp = /\bprint\s*\(/;
      exports.AutoPrintRegExp = AutoPrintRegExp;
      class OutputScale {
        constructor() {
          const pixelRatio = window.devicePixelRatio || 1;
          this.sx = pixelRatio;
          this.sy = pixelRatio;
        }
        get scaled() {
          return this.sx !== 1 || this.sy !== 1;
        }
      }
      exports.OutputScale = OutputScale;
      function scrollIntoView(element, spot, scrollMatches = false) {
        let parent = element.offsetParent;
        if (!parent) {
          console.error("offsetParent is not set -- cannot scroll");
          return;
        }
        let offsetY = element.offsetTop + element.clientTop;
        let offsetX = element.offsetLeft + element.clientLeft;
        while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || scrollMatches && (parent.classList.contains("markedContent") || getComputedStyle(parent).overflow === "hidden")) {
          offsetY += parent.offsetTop;
          offsetX += parent.offsetLeft;
          parent = parent.offsetParent;
          if (!parent) {
            return;
          }
        }
        if (spot) {
          if (spot.top !== undefined) {
            offsetY += spot.top;
          }
          if (spot.left !== undefined) {
            offsetX += spot.left;
            parent.scrollLeft = offsetX;
          }
        }
        parent.scrollTop = offsetY;
      }
      function watchScroll(viewAreaElement, callback) {
        const debounceScroll = function (evt) {
          if (rAF) {
            return;
          }
          rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
            rAF = null;
            const currentX = viewAreaElement.scrollLeft;
            const lastX = state.lastX;
            if (currentX !== lastX) {
              state.right = currentX > lastX;
            }
            state.lastX = currentX;
            const currentY = viewAreaElement.scrollTop;
            const lastY = state.lastY;
            if (currentY !== lastY) {
              state.down = currentY > lastY;
            }
            state.lastY = currentY;
            callback(state);
          });
        };
        const state = {
          right: true,
          down: true,
          lastX: viewAreaElement.scrollLeft,
          lastY: viewAreaElement.scrollTop,
          _eventHandler: debounceScroll
        };
        let rAF = null;
        viewAreaElement.addEventListener("scroll", debounceScroll, true);
        return state;
      }
      function parseQueryString(query) {
        const params = new Map();
        for (const [key, value] of new URLSearchParams(query)) {
          params.set(key.toLowerCase(), value);
        }
        return params;
      }
      const NullCharactersRegExp = /\x00/g;
      const InvisibleCharactersRegExp = /[\x01-\x1F]/g;
      function removeNullCharacters(str, replaceInvisible = false) {
        if (typeof str !== "string") {
          console.error(`The argument must be a string.`);
          return str;
        }
        if (replaceInvisible) {
          str = str.replace(InvisibleCharactersRegExp, " ");
        }
        return str.replace(NullCharactersRegExp, "");
      }
      function binarySearchFirstItem(items, condition, start = 0) {
        let minIndex = start;
        let maxIndex = items.length - 1;
        if (maxIndex < 0 || !condition(items[maxIndex])) {
          return items.length;
        }
        if (condition(items[minIndex])) {
          return minIndex;
        }
        while (minIndex < maxIndex) {
          const currentIndex = minIndex + maxIndex >> 1;
          const currentItem = items[currentIndex];
          if (condition(currentItem)) {
            maxIndex = currentIndex;
          } else {
            minIndex = currentIndex + 1;
          }
        }
        return minIndex;
      }
      function approximateFraction(x) {
        if (Math.floor(x) === x) {
          return [x, 1];
        }
        const xinv = 1 / x;
        const limit = 8;
        if (xinv > limit) {
          return [1, limit];
        } else if (Math.floor(xinv) === xinv) {
          return [1, xinv];
        }
        const x_ = x > 1 ? xinv : x;
        let a = 0,
          b = 1,
          c = 1,
          d = 1;
        while (true) {
          const p = a + c,
            q = b + d;
          if (q > limit) {
            break;
          }
          if (x_ <= p / q) {
            c = p;
            d = q;
          } else {
            a = p;
            b = q;
          }
        }
        let result;
        if (x_ - a / b < c / d - x_) {
          result = x_ === x ? [a, b] : [b, a];
        } else {
          result = x_ === x ? [c, d] : [d, c];
        }
        return result;
      }
      function roundToDivide(x, div) {
        const r = x % div;
        return r === 0 ? x : Math.round(x - r + div);
      }
      function getPageSizeInches({
        view,
        userUnit,
        rotate
      }) {
        const [x1, y1, x2, y2] = view;
        const changeOrientation = rotate % 180 !== 0;
        const width = (x2 - x1) / 72 * userUnit;
        const height = (y2 - y1) / 72 * userUnit;
        return {
          width: changeOrientation ? height : width,
          height: changeOrientation ? width : height
        };
      }
      function backtrackBeforeAllVisibleElements(index, views, top) {
        if (index < 2) {
          return index;
        }
        let elt = views[index].div;
        let pageTop = elt.offsetTop + elt.clientTop;
        if (pageTop >= top) {
          elt = views[index - 1].div;
          pageTop = elt.offsetTop + elt.clientTop;
        }
        for (let i = index - 2; i >= 0; --i) {
          elt = views[i].div;
          if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
            break;
          }
          index = i;
        }
        return index;
      }
      function getVisibleElements({
        scrollEl,
        views,
        sortByVisibility = false,
        horizontal = false,
        rtl = false
      }) {
        const top = scrollEl.scrollTop,
          bottom = top + scrollEl.clientHeight;
        const left = scrollEl.scrollLeft,
          right = left + scrollEl.clientWidth;
        function isElementBottomAfterViewTop(view) {
          const element = view.div;
          const elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
          return elementBottom > top;
        }
        function isElementNextAfterViewHorizontally(view) {
          const element = view.div;
          const elementLeft = element.offsetLeft + element.clientLeft;
          const elementRight = elementLeft + element.clientWidth;
          return rtl ? elementLeft < right : elementRight > left;
        }
        const visible = [],
          ids = new Set(),
          numViews = views.length;
        let firstVisibleElementInd = binarySearchFirstItem(views, horizontal ? isElementNextAfterViewHorizontally : isElementBottomAfterViewTop);
        if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
          firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
        }
        let lastEdge = horizontal ? right : -1;
        for (let i = firstVisibleElementInd; i < numViews; i++) {
          const view = views[i],
            element = view.div;
          const currentWidth = element.offsetLeft + element.clientLeft;
          const currentHeight = element.offsetTop + element.clientTop;
          const viewWidth = element.clientWidth,
            viewHeight = element.clientHeight;
          const viewRight = currentWidth + viewWidth;
          const viewBottom = currentHeight + viewHeight;
          if (lastEdge === -1) {
            if (viewBottom >= bottom) {
              lastEdge = viewBottom;
            }
          } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
            break;
          }
          if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
            continue;
          }
          const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
          const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
          const fractionHeight = (viewHeight - hiddenHeight) / viewHeight,
            fractionWidth = (viewWidth - hiddenWidth) / viewWidth;
          const percent = fractionHeight * fractionWidth * 100 | 0;
          visible.push({
            id: view.id,
            x: currentWidth,
            y: currentHeight,
            view,
            percent,
            widthPercent: fractionWidth * 100 | 0
          });
          ids.add(view.id);
        }
        const first = visible[0],
          last = visible[visible.length - 1];
        if (sortByVisibility) {
          visible.sort(function (a, b) {
            const pc = a.percent - b.percent;
            if (Math.abs(pc) > 0.001) {
              return -pc;
            }
            return a.id - b.id;
          });
        }
        return {
          first,
          last,
          views: visible,
          ids
        };
      }
      function noContextMenuHandler(evt) {
        evt.preventDefault();
      }
      function normalizeWheelEventDirection(evt) {
        let delta = Math.hypot(evt.deltaX, evt.deltaY);
        const angle = Math.atan2(evt.deltaY, evt.deltaX);
        if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
          delta = -delta;
        }
        return delta;
      }
      function normalizeWheelEventDelta(evt) {
        let delta = normalizeWheelEventDirection(evt);
        const MOUSE_DOM_DELTA_PIXEL_MODE = 0;
        const MOUSE_DOM_DELTA_LINE_MODE = 1;
        const MOUSE_PIXELS_PER_LINE = 30;
        const MOUSE_LINES_PER_PAGE = 30;
        if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
          delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
        } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
          delta /= MOUSE_LINES_PER_PAGE;
        }
        return delta;
      }
      function isValidRotation(angle) {
        return Number.isInteger(angle) && angle % 90 === 0;
      }
      function isValidScrollMode(mode) {
        return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
      }
      function isValidSpreadMode(mode) {
        return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
      }
      function isPortraitOrientation(size) {
        return size.width <= size.height;
      }
      const animationStarted = new Promise(function (resolve) {
        window.requestAnimationFrame(resolve);
      });
      exports.animationStarted = animationStarted;
      function clamp(v, min, max) {
        return Math.min(Math.max(v, min), max);
      }
      var _ProgressBar_brand = /*#__PURE__*/new WeakSet();
      class ProgressBar {
        constructor(id) {
          _classPrivateMethodInitSpec(this, _ProgressBar_brand);
          if (arguments.length > 1) {
            throw new Error("ProgressBar no longer accepts any additional options, " + "please use CSS rules to modify its appearance instead.");
          }
          this.visible = true;
          this.div = document.querySelector(id + " .progress");
          this.bar = this.div.parentNode;
          this.percent = 0;
        }
        get percent() {
          return this._percent;
        }
        set percent(val) {
          this._indeterminate = isNaN(val);
          this._percent = clamp(val, 0, 100);
          _assertClassBrand(_ProgressBar_brand, this, _updateBar).call(this);
        }
        setWidth(viewer) {
          if (!viewer) {
            return;
          }
          const container = viewer.parentNode;
          const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;
          if (scrollbarWidth > 0) {
            const doc = document.documentElement;
            doc.style.setProperty("--progressBar-end-offset", `${scrollbarWidth}px`);
          }
        }
        hide() {
          if (!this.visible) {
            return;
          }
          this.visible = false;
          this.bar.classList.add("hidden");
        }
        show() {
          if (this.visible) {
            return;
          }
          this.visible = true;
          this.bar.classList.remove("hidden");
        }
      }
      function _updateBar() {
        if (this._indeterminate) {
          this.div.classList.add("indeterminate");
          return;
        }
        this.div.classList.remove("indeterminate");
        const doc = document.documentElement;
        doc.style.setProperty("--progressBar-percent", `${this._percent}%`);
      }
      exports.ProgressBar = ProgressBar;
      function getActiveOrFocusedElement() {
        let curRoot = document;
        let curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");
        while ((_curActiveOrFocused = curActiveOrFocused) !== null && _curActiveOrFocused !== void 0 && _curActiveOrFocused.shadowRoot) {
          var _curActiveOrFocused;
          curRoot = curActiveOrFocused.shadowRoot;
          curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");
        }
        return curActiveOrFocused;
      }
      function apiPageLayoutToViewerModes(layout) {
        let scrollMode = ScrollMode.VERTICAL,
          spreadMode = SpreadMode.NONE;
        switch (layout) {
          case "SinglePage":
            scrollMode = ScrollMode.PAGE;
            break;
          case "OneColumn":
            break;
          case "TwoPageLeft":
            scrollMode = ScrollMode.PAGE;
          case "TwoColumnLeft":
            spreadMode = SpreadMode.ODD;
            break;
          case "TwoPageRight":
            scrollMode = ScrollMode.PAGE;
          case "TwoColumnRight":
            spreadMode = SpreadMode.EVEN;
            break;
        }
        return {
          scrollMode,
          spreadMode
        };
      }
      function apiPageModeToSidebarView(mode) {
        switch (mode) {
          case "UseNone":
            return SidebarView.NONE;
          case "UseThumbs":
            return SidebarView.THUMBS;
          case "UseOutlines":
            return SidebarView.OUTLINE;
          case "UseAttachments":
            return SidebarView.ATTACHMENTS;
          case "UseOC":
            return SidebarView.LAYERS;
        }
        return SidebarView.NONE;
      }

      /***/
    }), ( /* 7 */
    /***/(__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.StructTreeLayerBuilder = void 0;
      const PDF_ROLE_TO_HTML_ROLE = {
        Document: null,
        DocumentFragment: null,
        Part: "group",
        Sect: "group",
        Div: "group",
        Aside: "note",
        NonStruct: "none",
        P: null,
        H: "heading",
        Title: null,
        FENote: "note",
        Sub: "group",
        Lbl: null,
        Span: null,
        Em: null,
        Strong: null,
        Link: "link",
        Annot: "note",
        Form: "form",
        Ruby: null,
        RB: null,
        RT: null,
        RP: null,
        Warichu: null,
        WT: null,
        WP: null,
        L: "list",
        LI: "listitem",
        LBody: null,
        Table: "table",
        TR: "row",
        TH: "columnheader",
        TD: "cell",
        THead: "columnheader",
        TBody: null,
        TFoot: null,
        Caption: null,
        Figure: "figure",
        Formula: null,
        Artifact: null
      };
      const HEADING_PATTERN = /^H(\d+)$/;
      class StructTreeLayerBuilder {
        constructor({
          pdfPage
        }) {
          this.pdfPage = pdfPage;
        }
        render(structTree) {
          return this._walk(structTree);
        }
        _setAttributes(structElement, htmlElement) {
          if (structElement.alt !== undefined) {
            htmlElement.setAttribute("aria-label", structElement.alt);
          }
          if (structElement.id !== undefined) {
            htmlElement.setAttribute("aria-owns", structElement.id);
          }
          if (structElement.lang !== undefined) {
            htmlElement.setAttribute("lang", structElement.lang);
          }
        }
        _walk(node) {
          if (!node) {
            return null;
          }
          const element = document.createElement("span");
          if ("role" in node) {
            const {
              role
            } = node;
            const match = role.match(HEADING_PATTERN);
            if (match) {
              element.setAttribute("role", "heading");
              element.setAttribute("aria-level", match[1]);
            } else if (PDF_ROLE_TO_HTML_ROLE[role]) {
              element.setAttribute("role", PDF_ROLE_TO_HTML_ROLE[role]);
            }
          }
          this._setAttributes(node, element);
          if (node.children) {
            if (node.children.length === 1 && "id" in node.children[0]) {
              this._setAttributes(node.children[0], element);
            } else {
              for (const kid of node.children) {
                element.appendChild(this._walk(kid));
              }
            }
          }
          return element;
        }
      }
      exports.StructTreeLayerBuilder = StructTreeLayerBuilder;

      /***/
    }), ( /* 8 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TextLayerBuilder = void 0;
      var _pdfjsLib = __w_pdfjs_require__(3);
      const EXPAND_DIVS_TIMEOUT = 300;
      class TextLayerBuilder {
        constructor({
          textLayerDiv,
          eventBus,
          pageIndex,
          viewport,
          highlighter = null,
          enhanceTextSelection = false
        }) {
          this.textLayerDiv = textLayerDiv;
          this.eventBus = eventBus;
          this.textContent = null;
          this.textContentItemsStr = [];
          this.textContentStream = null;
          this.renderingDone = false;
          this.pageNumber = pageIndex + 1;
          this.viewport = viewport;
          this.textDivs = [];
          this.textLayerRenderTask = null;
          this.highlighter = highlighter;
          this.enhanceTextSelection = enhanceTextSelection;
          this._bindMouse();
        }
        _finishRendering() {
          this.renderingDone = true;
          if (!this.enhanceTextSelection) {
            const endOfContent = document.createElement("div");
            endOfContent.className = "endOfContent";
            this.textLayerDiv.appendChild(endOfContent);
          }
          this.eventBus.dispatch("textlayerrendered", {
            source: this,
            pageNumber: this.pageNumber,
            numTextDivs: this.textDivs.length
          });
        }
        render(timeout = 0) {
          var _this$highlighter;
          if (!(this.textContent || this.textContentStream) || this.renderingDone) {
            return;
          }
          this.cancel();
          this.textDivs.length = 0;
          (_this$highlighter = this.highlighter) === null || _this$highlighter === void 0 ? void 0 : _this$highlighter.setTextMapping(this.textDivs, this.textContentItemsStr);
          const textLayerFrag = document.createDocumentFragment();
          this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({
            textContent: this.textContent,
            textContentStream: this.textContentStream,
            container: textLayerFrag,
            viewport: this.viewport,
            textDivs: this.textDivs,
            textContentItemsStr: this.textContentItemsStr,
            timeout,
            enhanceTextSelection: this.enhanceTextSelection
          });
          this.textLayerRenderTask.promise.then(() => {
            var _this$highlighter2;
            this.textLayerDiv.appendChild(textLayerFrag);
            this._finishRendering();
            (_this$highlighter2 = this.highlighter) === null || _this$highlighter2 === void 0 ? void 0 : _this$highlighter2.enable();
          }, function (reason) {});
        }
        cancel() {
          var _this$highlighter3;
          if (this.textLayerRenderTask) {
            this.textLayerRenderTask.cancel();
            this.textLayerRenderTask = null;
          }
          (_this$highlighter3 = this.highlighter) === null || _this$highlighter3 === void 0 ? void 0 : _this$highlighter3.disable();
        }
        setTextContentStream(readableStream) {
          this.cancel();
          this.textContentStream = readableStream;
        }
        setTextContent(textContent) {
          this.cancel();
          this.textContent = textContent;
        }
        _bindMouse() {
          const div = this.textLayerDiv;
          let expandDivsTimer = null;
          div.addEventListener("mousedown", evt => {
            if (this.enhanceTextSelection && this.textLayerRenderTask) {
              this.textLayerRenderTask.expandTextDivs(true);
              if (expandDivsTimer) {
                clearTimeout(expandDivsTimer);
                expandDivsTimer = null;
              }
              return;
            }
            const end = div.querySelector(".endOfContent");
            if (!end) {
              return;
            }
            let adjustTop = evt.target !== div;
            adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue("-moz-user-select") !== "none";
            if (adjustTop) {
              const divBounds = div.getBoundingClientRect();
              const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
              end.style.top = (r * 100).toFixed(2) + "%";
            }
            end.classList.add("active");
          });
          div.addEventListener("mouseup", () => {
            if (this.enhanceTextSelection && this.textLayerRenderTask) {
              expandDivsTimer = setTimeout(() => {
                if (this.textLayerRenderTask) {
                  this.textLayerRenderTask.expandTextDivs(false);
                }
                expandDivsTimer = null;
              }, EXPAND_DIVS_TIMEOUT);
              return;
            }
            const end = div.querySelector(".endOfContent");
            if (!end) {
              return;
            }
            end.style.top = "";
            end.classList.remove("active");
          });
        }
      }
      exports.TextLayerBuilder = TextLayerBuilder;

      /***/
    }), ( /* 9 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.XfaLayerBuilder = void 0;
      var _pdfjsLib = __w_pdfjs_require__(3);
      class XfaLayerBuilder {
        constructor({
          pageDiv,
          pdfPage,
          annotationStorage = null,
          linkService,
          xfaHtml = null
        }) {
          this.pageDiv = pageDiv;
          this.pdfPage = pdfPage;
          this.annotationStorage = annotationStorage;
          this.linkService = linkService;
          this.xfaHtml = xfaHtml;
          this.div = null;
          this._cancelled = false;
        }
        render(viewport, intent = "display") {
          if (intent === "print") {
            const parameters = {
              viewport: viewport.clone({
                dontFlip: true
              }),
              div: this.div,
              xfaHtml: this.xfaHtml,
              annotationStorage: this.annotationStorage,
              linkService: this.linkService,
              intent
            };
            const div = document.createElement("div");
            this.pageDiv.appendChild(div);
            parameters.div = div;
            const result = _pdfjsLib.XfaLayer.render(parameters);
            return Promise.resolve(result);
          }
          return this.pdfPage.getXfa().then(xfaHtml => {
            if (this._cancelled || !xfaHtml) {
              return {
                textDivs: []
              };
            }
            const parameters = {
              viewport: viewport.clone({
                dontFlip: true
              }),
              div: this.div,
              xfaHtml,
              annotationStorage: this.annotationStorage,
              linkService: this.linkService,
              intent
            };
            if (this.div) {
              return _pdfjsLib.XfaLayer.update(parameters);
            }
            this.div = document.createElement("div");
            this.pageDiv.appendChild(this.div);
            parameters.div = this.div;
            return _pdfjsLib.XfaLayer.render(parameters);
          }).catch(error => {
            console.error(error);
          });
        }
        cancel() {
          this._cancelled = true;
        }
        hide() {
          if (!this.div) {
            return;
          }
          this.div.hidden = true;
        }
      }
      exports.XfaLayerBuilder = XfaLayerBuilder;

      /***/
    }), ( /* 10 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFViewer = exports.PDFSinglePageViewer = void 0;
      var _ui_utils = __w_pdfjs_require__(6);
      var _base_viewer = __w_pdfjs_require__(11);
      class PDFViewer extends _base_viewer.BaseViewer {}
      exports.PDFViewer = PDFViewer;
      class PDFSinglePageViewer extends _base_viewer.BaseViewer {
        _resetView() {
          super._resetView();
          this._scrollMode = _ui_utils.ScrollMode.PAGE;
          this._spreadMode = _ui_utils.SpreadMode.NONE;
        }
        set scrollMode(mode) {}
        _updateScrollMode() {}
        set spreadMode(mode) {}
        _updateSpreadMode() {}
      }
      exports.PDFSinglePageViewer = PDFSinglePageViewer;

      /***/
    }), ( /* 11 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PagesCountLimit = exports.PDFPageViewBuffer = exports.BaseViewer = void 0;
      var _pdfjsLib = __w_pdfjs_require__(3);
      var _ui_utils = __w_pdfjs_require__(6);
      var _annotation_layer_builder = __w_pdfjs_require__(2);
      var _l10n_utils = __w_pdfjs_require__(4);
      var _pdf_page_view = __w_pdfjs_require__(12);
      var _pdf_rendering_queue = __w_pdfjs_require__(14);
      var _pdf_link_service = __w_pdfjs_require__(5);
      var _struct_tree_layer_builder = __w_pdfjs_require__(7);
      var _text_highlighter = __w_pdfjs_require__(15);
      var _text_layer_builder = __w_pdfjs_require__(8);
      var _xfa_layer_builder = __w_pdfjs_require__(9);
      const DEFAULT_CACHE_SIZE = 10;
      const ENABLE_PERMISSIONS_CLASS = "enablePermissions";
      const PagesCountLimit = {
        FORCE_SCROLL_MODE_PAGE: 15000,
        FORCE_LAZY_PAGE_INIT: 7500,
        PAUSE_EAGER_PAGE_INIT: 250
      };
      exports.PagesCountLimit = PagesCountLimit;
      var _buf = /*#__PURE__*/new WeakMap();
      var _size = /*#__PURE__*/new WeakMap();
      var _PDFPageViewBuffer_brand = /*#__PURE__*/new WeakSet();
      class PDFPageViewBuffer {
        constructor(size) {
          _classPrivateMethodInitSpec(this, _PDFPageViewBuffer_brand);
          _classPrivateFieldInitSpec(this, _buf, new Set());
          _classPrivateFieldInitSpec(this, _size, 0);
          _classPrivateFieldSet(_size, this, size);
        }
        push(view) {
          const buf = _classPrivateFieldGet(_buf, this);
          if (buf.has(view)) {
            buf.delete(view);
          }
          buf.add(view);
          if (buf.size > _classPrivateFieldGet(_size, this)) {
            _assertClassBrand(_PDFPageViewBuffer_brand, this, _destroyFirstView).call(this);
          }
        }
        resize(newSize, idsToKeep = null) {
          _classPrivateFieldSet(_size, this, newSize);
          const buf = _classPrivateFieldGet(_buf, this);
          if (idsToKeep) {
            const ii = buf.size;
            let i = 1;
            for (const view of buf) {
              if (idsToKeep.has(view.id)) {
                buf.delete(view);
                buf.add(view);
              }
              if (++i > ii) {
                break;
              }
            }
          }
          while (buf.size > _classPrivateFieldGet(_size, this)) {
            _assertClassBrand(_PDFPageViewBuffer_brand, this, _destroyFirstView).call(this);
          }
        }
        has(view) {
          return _classPrivateFieldGet(_buf, this).has(view);
        }
        [Symbol.iterator]() {
          return _classPrivateFieldGet(_buf, this).keys();
        }
      }
      function _destroyFirstView() {
        const firstView = _classPrivateFieldGet(_buf, this).keys().next().value;
        firstView === null || firstView === void 0 ? void 0 : firstView.destroy();
        _classPrivateFieldGet(_buf, this).delete(firstView);
      }
      exports.PDFPageViewBuffer = PDFPageViewBuffer;
      var _buffer = /*#__PURE__*/new WeakMap();
      var _annotationMode = /*#__PURE__*/new WeakMap();
      var _previousAnnotationMode = /*#__PURE__*/new WeakMap();
      var _enablePermissions = /*#__PURE__*/new WeakMap();
      var _previousContainerHeight = /*#__PURE__*/new WeakMap();
      var _scrollModePageState = /*#__PURE__*/new WeakMap();
      var _onVisibilityChange = /*#__PURE__*/new WeakMap();
      var _BaseViewer_brand = /*#__PURE__*/new WeakSet();
      class BaseViewer {
        constructor(options) {
          var _this$container, _this$viewer, _options$textLayerMod, _options$annotationMo;
          _classPrivateMethodInitSpec(this, _BaseViewer_brand);
          _classPrivateFieldInitSpec(this, _buffer, null);
          _classPrivateFieldInitSpec(this, _annotationMode, _pdfjsLib.AnnotationMode.ENABLE_FORMS);
          _classPrivateFieldInitSpec(this, _previousAnnotationMode, null);
          _classPrivateFieldInitSpec(this, _enablePermissions, false);
          _classPrivateFieldInitSpec(this, _previousContainerHeight, 0);
          _classPrivateFieldInitSpec(this, _scrollModePageState, null);
          _classPrivateFieldInitSpec(this, _onVisibilityChange, null);
          if (this.constructor === BaseViewer) {
            throw new Error("Cannot initialize BaseViewer.");
          }
          const viewerVersion = '2.14.305';
          if (_pdfjsLib.version !== viewerVersion) {
            throw new Error(`The API version "${_pdfjsLib.version}" does not match the Viewer version "${viewerVersion}".`);
          }
          this.container = options.container;
          this.viewer = options.viewer || options.container.firstElementChild;
          if (!(((_this$container = this.container) === null || _this$container === void 0 ? void 0 : _this$container.tagName.toUpperCase()) === "DIV" && ((_this$viewer = this.viewer) === null || _this$viewer === void 0 ? void 0 : _this$viewer.tagName.toUpperCase()) === "DIV")) {
            throw new Error("Invalid `container` and/or `viewer` option.");
          }
          if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute") {
            throw new Error("The `container` must be absolutely positioned.");
          }
          this.eventBus = options.eventBus;
          this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService();
          this.downloadManager = options.downloadManager || null;
          this.findController = options.findController || null;
          this._scriptingManager = options.scriptingManager || null;
          this.removePageBorders = options.removePageBorders || false;
          this.textLayerMode = (_options$textLayerMod = options.textLayerMode) !== null && _options$textLayerMod !== void 0 ? _options$textLayerMod : _ui_utils.TextLayerMode.ENABLE;
          _classPrivateFieldSet(_annotationMode, this, (_options$annotationMo = options.annotationMode) !== null && _options$annotationMo !== void 0 ? _options$annotationMo : _pdfjsLib.AnnotationMode.ENABLE_FORMS);
          this.imageResourcesPath = options.imageResourcesPath || "";
          this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;
          this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
          this.useOnlyCssZoom = options.useOnlyCssZoom || false;
          this.maxCanvasPixels = options.maxCanvasPixels;
          this.l10n = options.l10n || _l10n_utils.NullL10n;
          _classPrivateFieldSet(_enablePermissions, this, options.enablePermissions || false);
          this.pageColors = options.pageColors || null;
          if (options.pageColors && (!CSS.supports("color", options.pageColors.background) || !CSS.supports("color", options.pageColors.foreground))) {
            if (options.pageColors.background || options.pageColors.foreground) {
              console.warn("Ignoring `pageColors`-option, since the browser doesn't support the values used.");
            }
            this.pageColors = null;
          }
          this.defaultRenderingQueue = !options.renderingQueue;
          if (this.defaultRenderingQueue) {
            this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
            this.renderingQueue.setViewer(this);
          } else {
            this.renderingQueue = options.renderingQueue;
          }
          this._doc = document.documentElement;
          this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this));
          this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN;
          this._onBeforeDraw = this._onAfterDraw = null;
          this._resetView();
          if (this.removePageBorders) {
            this.viewer.classList.add("removePageBorders");
          }
          this.updateContainerHeightCss();
          Promise.resolve().then(() => {
            this.eventBus.dispatch("baseviewerinit", {
              source: this
            });
          });
        }
        get pagesCount() {
          return this._pages.length;
        }
        getPageView(index) {
          return this._pages[index];
        }
        get pageViewsReady() {
          if (!this._pagesCapability.settled) {
            return false;
          }
          return this._pages.every(function (pageView) {
            return pageView === null || pageView === void 0 ? void 0 : pageView.pdfPage;
          });
        }
        get renderForms() {
          return _classPrivateFieldGet(_annotationMode, this) === _pdfjsLib.AnnotationMode.ENABLE_FORMS;
        }
        get enableScripting() {
          return !!this._scriptingManager;
        }
        get currentPageNumber() {
          return this._currentPageNumber;
        }
        set currentPageNumber(val) {
          if (!Number.isInteger(val)) {
            throw new Error("Invalid page number.");
          }
          if (!this.pdfDocument) {
            return;
          }
          if (!this._setCurrentPageNumber(val, true)) {
            console.error(`currentPageNumber: "${val}" is not a valid page.`);
          }
        }
        _setCurrentPageNumber(val, resetCurrentPageView = false) {
          var _this$_pageLabels, _this$_pageLabels2;
          if (this._currentPageNumber === val) {
            if (resetCurrentPageView) {
              _assertClassBrand(_BaseViewer_brand, this, _resetCurrentPageView).call(this);
            }
            return true;
          }
          if (!(0 < val && val <= this.pagesCount)) {
            return false;
          }
          const previous = this._currentPageNumber;
          this._currentPageNumber = val;
          this.eventBus.dispatch("pagechanging", {
            source: this,
            pageNumber: val,
            pageLabel: (_this$_pageLabels = (_this$_pageLabels2 = this._pageLabels) === null || _this$_pageLabels2 === void 0 ? void 0 : _this$_pageLabels2[val - 1]) !== null && _this$_pageLabels !== void 0 ? _this$_pageLabels : null,
            previous
          });
          if (resetCurrentPageView) {
            _assertClassBrand(_BaseViewer_brand, this, _resetCurrentPageView).call(this);
          }
          return true;
        }
        get currentPageLabel() {
          var _this$_pageLabels3, _this$_pageLabels4;
          return (_this$_pageLabels3 = (_this$_pageLabels4 = this._pageLabels) === null || _this$_pageLabels4 === void 0 ? void 0 : _this$_pageLabels4[this._currentPageNumber - 1]) !== null && _this$_pageLabels3 !== void 0 ? _this$_pageLabels3 : null;
        }
        set currentPageLabel(val) {
          if (!this.pdfDocument) {
            return;
          }
          let page = val | 0;
          if (this._pageLabels) {
            const i = this._pageLabels.indexOf(val);
            if (i >= 0) {
              page = i + 1;
            }
          }
          if (!this._setCurrentPageNumber(page, true)) {
            console.error(`currentPageLabel: "${val}" is not a valid page.`);
          }
        }
        get currentScale() {
          return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE;
        }
        set currentScale(val) {
          if (isNaN(val)) {
            throw new Error("Invalid numeric scale.");
          }
          if (!this.pdfDocument) {
            return;
          }
          this._setScale(val, false);
        }
        get currentScaleValue() {
          return this._currentScaleValue;
        }
        set currentScaleValue(val) {
          if (!this.pdfDocument) {
            return;
          }
          this._setScale(val, false);
        }
        get pagesRotation() {
          return this._pagesRotation;
        }
        set pagesRotation(rotation) {
          if (!(0, _ui_utils.isValidRotation)(rotation)) {
            throw new Error("Invalid pages rotation angle.");
          }
          if (!this.pdfDocument) {
            return;
          }
          rotation %= 360;
          if (rotation < 0) {
            rotation += 360;
          }
          if (this._pagesRotation === rotation) {
            return;
          }
          this._pagesRotation = rotation;
          const pageNumber = this._currentPageNumber;
          const updateArgs = {
            rotation
          };
          for (const pageView of this._pages) {
            pageView.update(updateArgs);
          }
          if (this._currentScaleValue) {
            this._setScale(this._currentScaleValue, true);
          }
          this.eventBus.dispatch("rotationchanging", {
            source: this,
            pagesRotation: rotation,
            pageNumber
          });
          if (this.defaultRenderingQueue) {
            this.update();
          }
        }
        get firstPagePromise() {
          return this.pdfDocument ? this._firstPageCapability.promise : null;
        }
        get onePageRendered() {
          return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
        }
        get pagesPromise() {
          return this.pdfDocument ? this._pagesCapability.promise : null;
        }
        setDocument(pdfDocument) {
          var _this3 = this;
          if (this.pdfDocument) {
            this.eventBus.dispatch("pagesdestroy", {
              source: this
            });
            this._cancelRendering();
            this._resetView();
            if (this.findController) {
              this.findController.setDocument(null);
            }
            if (this._scriptingManager) {
              this._scriptingManager.setDocument(null);
            }
          }
          this.pdfDocument = pdfDocument;
          if (!pdfDocument) {
            return;
          }
          const isPureXfa = pdfDocument.isPureXfa;
          const pagesCount = pdfDocument.numPages;
          const firstPagePromise = pdfDocument.getPage(1);
          const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();
          const permissionsPromise = _classPrivateFieldGet(_enablePermissions, this) ? pdfDocument.getPermissions() : Promise.resolve();
          if (pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {
            console.warn("Forcing PAGE-scrolling for performance reasons, given the length of the document.");
            const mode = this._scrollMode = _ui_utils.ScrollMode.PAGE;
            this.eventBus.dispatch("scrollmodechanged", {
              source: this,
              mode
            });
          }
          this._pagesCapability.promise.then(() => {
            this.eventBus.dispatch("pagesloaded", {
              source: this,
              pagesCount
            });
          }, () => {});
          this._onBeforeDraw = evt => {
            const pageView = this._pages[evt.pageNumber - 1];
            if (!pageView) {
              return;
            }
            _classPrivateFieldGet(_buffer, this).push(pageView);
          };
          this.eventBus._on("pagerender", this._onBeforeDraw);
          this._onAfterDraw = evt => {
            if (evt.cssTransform || this._onePageRenderedCapability.settled) {
              return;
            }
            this._onePageRenderedCapability.resolve({
              timestamp: evt.timestamp
            });
            this.eventBus._off("pagerendered", this._onAfterDraw);
            this._onAfterDraw = null;
            if (_classPrivateFieldGet(_onVisibilityChange, this)) {
              document.removeEventListener("visibilitychange", _classPrivateFieldGet(_onVisibilityChange, this));
              _classPrivateFieldSet(_onVisibilityChange, this, null);
            }
          };
          this.eventBus._on("pagerendered", this._onAfterDraw);
          Promise.all([firstPagePromise, permissionsPromise]).then(([firstPdfPage, permissions]) => {
            if (pdfDocument !== this.pdfDocument) {
              return;
            }
            this._firstPageCapability.resolve(firstPdfPage);
            this._optionalContentConfigPromise = optionalContentConfigPromise;
            _assertClassBrand(_BaseViewer_brand, this, _initializePermissions).call(this, permissions);
            const viewerElement = this._scrollMode === _ui_utils.ScrollMode.PAGE ? null : this.viewer;
            const scale = this.currentScale;
            const viewport = firstPdfPage.getViewport({
              scale: scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS
            });
            const textLayerFactory = this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && !isPureXfa ? this : null;
            const annotationLayerFactory = _classPrivateFieldGet(_annotationMode, this) !== _pdfjsLib.AnnotationMode.DISABLE ? this : null;
            const xfaLayerFactory = isPureXfa ? this : null;
            for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {
              const pageView = new _pdf_page_view.PDFPageView({
                container: viewerElement,
                eventBus: this.eventBus,
                id: pageNum,
                scale,
                defaultViewport: viewport.clone(),
                optionalContentConfigPromise,
                renderingQueue: this.renderingQueue,
                textLayerFactory,
                textLayerMode: this.textLayerMode,
                annotationLayerFactory,
                annotationMode: _classPrivateFieldGet(_annotationMode, this),
                xfaLayerFactory,
                textHighlighterFactory: this,
                structTreeLayerFactory: this,
                imageResourcesPath: this.imageResourcesPath,
                renderer: this.renderer,
                useOnlyCssZoom: this.useOnlyCssZoom,
                maxCanvasPixels: this.maxCanvasPixels,
                pageColors: this.pageColors,
                l10n: this.l10n
              });
              this._pages.push(pageView);
            }
            const firstPageView = this._pages[0];
            if (firstPageView) {
              firstPageView.setPdfPage(firstPdfPage);
              this.linkService.cachePageRef(1, firstPdfPage.ref);
            }
            if (this._scrollMode === _ui_utils.ScrollMode.PAGE) {
              _assertClassBrand(_BaseViewer_brand, this, _ensurePageViewVisible).call(this);
            } else if (this._spreadMode !== _ui_utils.SpreadMode.NONE) {
              this._updateSpreadMode();
            }
            _assertClassBrand(_BaseViewer_brand, this, _onePageRenderedOrForceFetch).call(this).then( /*#__PURE__*/_asyncToGenerator(function* () {
              if (_this3.findController) {
                _this3.findController.setDocument(pdfDocument);
              }
              if (_this3._scriptingManager) {
                _this3._scriptingManager.setDocument(pdfDocument);
              }
              if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > PagesCountLimit.FORCE_LAZY_PAGE_INIT) {
                _this3._pagesCapability.resolve();
                return;
              }
              let getPagesLeft = pagesCount - 1;
              if (getPagesLeft <= 0) {
                _this3._pagesCapability.resolve();
                return;
              }
              for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) {
                const promise = pdfDocument.getPage(pageNum).then(pdfPage => {
                  const pageView = _this3._pages[pageNum - 1];
                  if (!pageView.pdfPage) {
                    pageView.setPdfPage(pdfPage);
                  }
                  _this3.linkService.cachePageRef(pageNum, pdfPage.ref);
                  if (--getPagesLeft === 0) {
                    _this3._pagesCapability.resolve();
                  }
                }, reason => {
                  console.error(`Unable to get page ${pageNum} to initialize viewer`, reason);
                  if (--getPagesLeft === 0) {
                    _this3._pagesCapability.resolve();
                  }
                });
                if (pageNum % PagesCountLimit.PAUSE_EAGER_PAGE_INIT === 0) {
                  yield promise;
                }
              }
            }));
            this.eventBus.dispatch("pagesinit", {
              source: this
            });
            pdfDocument.getMetadata().then(({
              info
            }) => {
              if (pdfDocument !== this.pdfDocument) {
                return;
              }
              if (info.Language) {
                this.viewer.lang = info.Language;
              }
            });
            if (this.defaultRenderingQueue) {
              this.update();
            }
          }).catch(reason => {
            console.error("Unable to initialize viewer", reason);
            this._pagesCapability.reject(reason);
          });
        }
        setPageLabels(labels) {
          if (!this.pdfDocument) {
            return;
          }
          if (!labels) {
            this._pageLabels = null;
          } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
            this._pageLabels = null;
            console.error(`setPageLabels: Invalid page labels.`);
          } else {
            this._pageLabels = labels;
          }
          for (let i = 0, ii = this._pages.length; i < ii; i++) {
            var _this$_pageLabels$i, _this$_pageLabels5;
            this._pages[i].setPageLabel((_this$_pageLabels$i = (_this$_pageLabels5 = this._pageLabels) === null || _this$_pageLabels5 === void 0 ? void 0 : _this$_pageLabels5[i]) !== null && _this$_pageLabels$i !== void 0 ? _this$_pageLabels$i : null);
          }
        }
        _resetView() {
          this._pages = [];
          this._currentPageNumber = 1;
          this._currentScale = _ui_utils.UNKNOWN_SCALE;
          this._currentScaleValue = null;
          this._pageLabels = null;
          _classPrivateFieldSet(_buffer, this, new PDFPageViewBuffer(DEFAULT_CACHE_SIZE));
          this._location = null;
          this._pagesRotation = 0;
          this._optionalContentConfigPromise = null;
          this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
          this._onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)();
          this._pagesCapability = (0, _pdfjsLib.createPromiseCapability)();
          this._scrollMode = _ui_utils.ScrollMode.VERTICAL;
          this._previousScrollMode = _ui_utils.ScrollMode.UNKNOWN;
          this._spreadMode = _ui_utils.SpreadMode.NONE;
          _classPrivateFieldSet(_scrollModePageState, this, {
            previousPageNumber: 1,
            scrollDown: true,
            pages: []
          });
          if (this._onBeforeDraw) {
            this.eventBus._off("pagerender", this._onBeforeDraw);
            this._onBeforeDraw = null;
          }
          if (this._onAfterDraw) {
            this.eventBus._off("pagerendered", this._onAfterDraw);
            this._onAfterDraw = null;
          }
          if (_classPrivateFieldGet(_onVisibilityChange, this)) {
            document.removeEventListener("visibilitychange", _classPrivateFieldGet(_onVisibilityChange, this));
            _classPrivateFieldSet(_onVisibilityChange, this, null);
          }
          this.viewer.textContent = "";
          this._updateScrollMode();
          this.viewer.removeAttribute("lang");
          this.viewer.classList.remove(ENABLE_PERMISSIONS_CLASS);
          if (_classPrivateFieldGet(_previousAnnotationMode, this) !== null) {
            _classPrivateFieldSet(_annotationMode, this, _classPrivateFieldGet(_previousAnnotationMode, this));
            _classPrivateFieldSet(_previousAnnotationMode, this, null);
          }
        }
        _scrollUpdate() {
          if (this.pagesCount === 0) {
            return;
          }
          this.update();
        }
        _setScaleUpdatePages(newScale, newValue, noScroll = false, preset = false) {
          this._currentScaleValue = newValue.toString();
          if (_assertClassBrand(_BaseViewer_brand, this, _isSameScale).call(this, newScale)) {
            if (preset) {
              this.eventBus.dispatch("scalechanging", {
                source: this,
                scale: newScale,
                presetValue: newValue
              });
            }
            return;
          }
          this._doc.style.setProperty("--zoom-factor", newScale);
          const updateArgs = {
            scale: newScale
          };
          for (const pageView of this._pages) {
            pageView.update(updateArgs);
          }
          this._currentScale = newScale;
          if (!noScroll) {
            let page = this._currentPageNumber,
              dest;
            if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) {
              page = this._location.pageNumber;
              dest = [null, {
                name: "XYZ"
              }, this._location.left, this._location.top, null];
            }
            this.scrollPageIntoView({
              pageNumber: page,
              destArray: dest,
              allowNegativeOffset: true
            });
          }
          this.eventBus.dispatch("scalechanging", {
            source: this,
            scale: newScale,
            presetValue: preset ? newValue : undefined
          });
          if (this.defaultRenderingQueue) {
            this.update();
          }
          this.updateContainerHeightCss();
        }
        get _pageWidthScaleFactor() {
          if (this._spreadMode !== _ui_utils.SpreadMode.NONE && this._scrollMode !== _ui_utils.ScrollMode.HORIZONTAL) {
            return 2;
          }
          return 1;
        }
        _setScale(value, noScroll = false) {
          let scale = parseFloat(value);
          if (scale > 0) {
            this._setScaleUpdatePages(scale, value, noScroll, false);
          } else {
            const currentPage = this._pages[this._currentPageNumber - 1];
            if (!currentPage) {
              return;
            }
            let hPadding = _ui_utils.SCROLLBAR_PADDING,
              vPadding = _ui_utils.VERTICAL_PADDING;
            if (this.isInPresentationMode) {
              hPadding = vPadding = 4;
            } else if (this.removePageBorders) {
              hPadding = vPadding = 0;
            } else if (this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL) {
              [hPadding, vPadding] = [vPadding, hPadding];
            }
            const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale / this._pageWidthScaleFactor;
            const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;
            switch (value) {
              case "page-actual":
                scale = 1;
                break;
              case "page-width":
                scale = pageWidthScale;
                break;
              case "page-height":
                scale = pageHeightScale;
                break;
              case "page-fit":
                scale = Math.min(pageWidthScale, pageHeightScale);
                break;
              case "auto":
                const horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);
                scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale);
                break;
              default:
                console.error(`_setScale: "${value}" is an unknown zoom value.`);
                return;
            }
            this._setScaleUpdatePages(scale, value, noScroll, true);
          }
        }
        pageLabelToPageNumber(label) {
          if (!this._pageLabels) {
            return null;
          }
          const i = this._pageLabels.indexOf(label);
          if (i < 0) {
            return null;
          }
          return i + 1;
        }
        scrollPageIntoView({
          pageNumber,
          destArray = null,
          allowNegativeOffset = false,
          ignoreDestinationZoom = false
        }) {
          if (!this.pdfDocument) {
            return;
          }
          const pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];
          if (!pageView) {
            console.error(`scrollPageIntoView: "${pageNumber}" is not a valid pageNumber parameter.`);
            return;
          }
          if (this.isInPresentationMode || !destArray) {
            this._setCurrentPageNumber(pageNumber, true);
            return;
          }
          let x = 0,
            y = 0;
          let width = 0,
            height = 0,
            widthScale,
            heightScale;
          const changeOrientation = pageView.rotation % 180 !== 0;
          const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
          const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
          let scale = 0;
          switch (destArray[1].name) {
            case "XYZ":
              x = destArray[2];
              y = destArray[3];
              scale = destArray[4];
              x = x !== null ? x : 0;
              y = y !== null ? y : pageHeight;
              break;
            case "Fit":
            case "FitB":
              scale = "page-fit";
              break;
            case "FitH":
            case "FitBH":
              y = destArray[2];
              scale = "page-width";
              if (y === null && this._location) {
                x = this._location.left;
                y = this._location.top;
              } else if (typeof y !== "number" || y < 0) {
                y = pageHeight;
              }
              break;
            case "FitV":
            case "FitBV":
              x = destArray[2];
              width = pageWidth;
              height = pageHeight;
              scale = "page-height";
              break;
            case "FitR":
              x = destArray[2];
              y = destArray[3];
              width = destArray[4] - x;
              height = destArray[5] - y;
              const hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING;
              const vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING;
              widthScale = (this.container.clientWidth - hPadding) / width / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
              heightScale = (this.container.clientHeight - vPadding) / height / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
              scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
              break;
            default:
              console.error(`scrollPageIntoView: "${destArray[1].name}" is not a valid destination type.`);
              return;
          }
          if (!ignoreDestinationZoom) {
            if (scale && scale !== this._currentScale) {
              this.currentScaleValue = scale;
            } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) {
              this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
            }
          }
          if (scale === "page-fit" && !destArray[4]) {
            _assertClassBrand(_BaseViewer_brand, this, _scrollIntoView).call(this, pageView);
            return;
          }
          const boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)];
          let left = Math.min(boundingRect[0][0], boundingRect[1][0]);
          let top = Math.min(boundingRect[0][1], boundingRect[1][1]);
          if (!allowNegativeOffset) {
            left = Math.max(left, 0);
            top = Math.max(top, 0);
          }
          _assertClassBrand(_BaseViewer_brand, this, _scrollIntoView).call(this, pageView, {
            left,
            top
          });
        }
        _updateLocation(firstPage) {
          const currentScale = this._currentScale;
          const currentScaleValue = this._currentScaleValue;
          const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue;
          const pageNumber = firstPage.id;
          const currentPageView = this._pages[pageNumber - 1];
          const container = this.container;
          const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);
          const intLeft = Math.round(topLeft[0]);
          const intTop = Math.round(topLeft[1]);
          let pdfOpenParams = `#page=${pageNumber}`;
          if (!this.isInPresentationMode) {
            pdfOpenParams += `&zoom=${normalizedScaleValue},${intLeft},${intTop}`;
          }
          this._location = {
            pageNumber,
            scale: normalizedScaleValue,
            top: intTop,
            left: intLeft,
            rotation: this._pagesRotation,
            pdfOpenParams
          };
        }
        update() {
          const visible = this._getVisiblePages();
          const visiblePages = visible.views,
            numVisiblePages = visiblePages.length;
          if (numVisiblePages === 0) {
            return;
          }
          const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);
          _classPrivateFieldGet(_buffer, this).resize(newCacheSize, visible.ids);
          this.renderingQueue.renderHighestPriority(visible);
          const isSimpleLayout = this._spreadMode === _ui_utils.SpreadMode.NONE && (this._scrollMode === _ui_utils.ScrollMode.PAGE || this._scrollMode === _ui_utils.ScrollMode.VERTICAL);
          const currentId = this._currentPageNumber;
          let stillFullyVisible = false;
          for (const page of visiblePages) {
            if (page.percent < 100) {
              break;
            }
            if (page.id === currentId && isSimpleLayout) {
              stillFullyVisible = true;
              break;
            }
          }
          this._setCurrentPageNumber(stillFullyVisible ? currentId : visiblePages[0].id);
          this._updateLocation(visible.first);
          this.eventBus.dispatch("updateviewarea", {
            source: this,
            location: this._location
          });
        }
        containsElement(element) {
          return this.container.contains(element);
        }
        focus() {
          this.container.focus();
        }
        get _isContainerRtl() {
          return getComputedStyle(this.container).direction === "rtl";
        }
        get isInPresentationMode() {
          return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN;
        }
        get isChangingPresentationMode() {
          return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING;
        }
        get isHorizontalScrollbarEnabled() {
          return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth;
        }
        get isVerticalScrollbarEnabled() {
          return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight;
        }
        _getVisiblePages() {
          const views = this._scrollMode === _ui_utils.ScrollMode.PAGE ? _classPrivateFieldGet(_scrollModePageState, this).pages : this._pages,
            horizontal = this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL,
            rtl = horizontal && this._isContainerRtl;
          return (0, _ui_utils.getVisibleElements)({
            scrollEl: this.container,
            views,
            sortByVisibility: true,
            horizontal,
            rtl
          });
        }
        isPageVisible(pageNumber) {
          if (!this.pdfDocument) {
            return false;
          }
          if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
            console.error(`isPageVisible: "${pageNumber}" is not a valid page.`);
            return false;
          }
          return this._getVisiblePages().ids.has(pageNumber);
        }
        isPageCached(pageNumber) {
          if (!this.pdfDocument) {
            return false;
          }
          if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
            console.error(`isPageCached: "${pageNumber}" is not a valid page.`);
            return false;
          }
          const pageView = this._pages[pageNumber - 1];
          return _classPrivateFieldGet(_buffer, this).has(pageView);
        }
        cleanup() {
          for (const pageView of this._pages) {
            if (pageView.renderingState !== _ui_utils.RenderingStates.FINISHED) {
              pageView.reset();
            }
          }
        }
        _cancelRendering() {
          for (const pageView of this._pages) {
            pageView.cancelRendering();
          }
        }
        forceRendering(currentlyVisiblePages) {
          const visiblePages = currentlyVisiblePages || this._getVisiblePages();
          const scrollAhead = _assertClassBrand(_BaseViewer_brand, this, _getScrollAhead).call(this, visiblePages);
          const preRenderExtra = this._spreadMode !== _ui_utils.SpreadMode.NONE && this._scrollMode !== _ui_utils.ScrollMode.HORIZONTAL;
          const pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead, preRenderExtra);
          _assertClassBrand(_BaseViewer_brand, this, _toggleLoadingIconSpinner).call(this, visiblePages.ids);
          if (pageView) {
            _assertClassBrand(_BaseViewer_brand, this, _ensurePdfPageLoaded).call(this, pageView).then(() => {
              this.renderingQueue.renderView(pageView);
            });
            return true;
          }
          return false;
        }
        createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus, highlighter) {
          return new _text_layer_builder.TextLayerBuilder({
            textLayerDiv,
            eventBus,
            pageIndex,
            viewport,
            enhanceTextSelection: this.isInPresentationMode ? false : enhanceTextSelection,
            highlighter
          });
        }
        createTextHighlighter(pageIndex, eventBus) {
          return new _text_highlighter.TextHighlighter({
            eventBus,
            pageIndex,
            findController: this.isInPresentationMode ? null : this.findController
          });
        }
        createAnnotationLayerBuilder(pageDiv, pdfPage, annotationStorage = null, imageResourcesPath = "", renderForms = true, l10n = _l10n_utils.NullL10n, enableScripting = null, hasJSActionsPromise = null, mouseState = null, fieldObjectsPromise = null, annotationCanvasMap = null) {
          var _this$pdfDocument, _this$pdfDocument2, _this$pdfDocument3, _this$_scriptingManag;
          return new _annotation_layer_builder.AnnotationLayerBuilder({
            pageDiv,
            pdfPage,
            annotationStorage: annotationStorage || ((_this$pdfDocument = this.pdfDocument) === null || _this$pdfDocument === void 0 ? void 0 : _this$pdfDocument.annotationStorage),
            imageResourcesPath,
            renderForms,
            linkService: this.linkService,
            downloadManager: this.downloadManager,
            l10n,
            enableScripting: enableScripting !== null && enableScripting !== void 0 ? enableScripting : this.enableScripting,
            hasJSActionsPromise: hasJSActionsPromise || ((_this$pdfDocument2 = this.pdfDocument) === null || _this$pdfDocument2 === void 0 ? void 0 : _this$pdfDocument2.hasJSActions()),
            fieldObjectsPromise: fieldObjectsPromise || ((_this$pdfDocument3 = this.pdfDocument) === null || _this$pdfDocument3 === void 0 ? void 0 : _this$pdfDocument3.getFieldObjects()),
            mouseState: mouseState || ((_this$_scriptingManag = this._scriptingManager) === null || _this$_scriptingManag === void 0 ? void 0 : _this$_scriptingManag.mouseState),
            annotationCanvasMap
          });
        }
        createXfaLayerBuilder(pageDiv, pdfPage, annotationStorage = null) {
          var _this$pdfDocument4;
          return new _xfa_layer_builder.XfaLayerBuilder({
            pageDiv,
            pdfPage,
            annotationStorage: annotationStorage || ((_this$pdfDocument4 = this.pdfDocument) === null || _this$pdfDocument4 === void 0 ? void 0 : _this$pdfDocument4.annotationStorage),
            linkService: this.linkService
          });
        }
        createStructTreeLayerBuilder(pdfPage) {
          return new _struct_tree_layer_builder.StructTreeLayerBuilder({
            pdfPage
          });
        }
        get hasEqualPageSizes() {
          const firstPageView = this._pages[0];
          for (let i = 1, ii = this._pages.length; i < ii; ++i) {
            const pageView = this._pages[i];
            if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {
              return false;
            }
          }
          return true;
        }
        getPagesOverview() {
          return this._pages.map(pageView => {
            const viewport = pageView.pdfPage.getViewport({
              scale: 1
            });
            if (!this.enablePrintAutoRotate || (0, _ui_utils.isPortraitOrientation)(viewport)) {
              return {
                width: viewport.width,
                height: viewport.height,
                rotation: viewport.rotation
              };
            }
            return {
              width: viewport.height,
              height: viewport.width,
              rotation: (viewport.rotation - 90) % 360
            };
          });
        }
        get optionalContentConfigPromise() {
          if (!this.pdfDocument) {
            return Promise.resolve(null);
          }
          if (!this._optionalContentConfigPromise) {
            return this.pdfDocument.getOptionalContentConfig();
          }
          return this._optionalContentConfigPromise;
        }
        set optionalContentConfigPromise(promise) {
          if (!(promise instanceof Promise)) {
            throw new Error(`Invalid optionalContentConfigPromise: ${promise}`);
          }
          if (!this.pdfDocument) {
            return;
          }
          if (!this._optionalContentConfigPromise) {
            return;
          }
          this._optionalContentConfigPromise = promise;
          const updateArgs = {
            optionalContentConfigPromise: promise
          };
          for (const pageView of this._pages) {
            pageView.update(updateArgs);
          }
          this.update();
          this.eventBus.dispatch("optionalcontentconfigchanged", {
            source: this,
            promise
          });
        }
        get scrollMode() {
          return this._scrollMode;
        }
        set scrollMode(mode) {
          if (this._scrollMode === mode) {
            return;
          }
          if (!(0, _ui_utils.isValidScrollMode)(mode)) {
            throw new Error(`Invalid scroll mode: ${mode}`);
          }
          if (this.pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {
            return;
          }
          this._previousScrollMode = this._scrollMode;
          this._scrollMode = mode;
          this.eventBus.dispatch("scrollmodechanged", {
            source: this,
            mode
          });
          this._updateScrollMode(this._currentPageNumber);
        }
        _updateScrollMode(pageNumber = null) {
          const scrollMode = this._scrollMode,
            viewer = this.viewer;
          viewer.classList.toggle("scrollHorizontal", scrollMode === _ui_utils.ScrollMode.HORIZONTAL);
          viewer.classList.toggle("scrollWrapped", scrollMode === _ui_utils.ScrollMode.WRAPPED);
          if (!this.pdfDocument || !pageNumber) {
            return;
          }
          if (scrollMode === _ui_utils.ScrollMode.PAGE) {
            _assertClassBrand(_BaseViewer_brand, this, _ensurePageViewVisible).call(this);
          } else if (this._previousScrollMode === _ui_utils.ScrollMode.PAGE) {
            this._updateSpreadMode();
          }
          if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
            this._setScale(this._currentScaleValue, true);
          }
          this._setCurrentPageNumber(pageNumber, true);
          this.update();
        }
        get spreadMode() {
          return this._spreadMode;
        }
        set spreadMode(mode) {
          if (this._spreadMode === mode) {
            return;
          }
          if (!(0, _ui_utils.isValidSpreadMode)(mode)) {
            throw new Error(`Invalid spread mode: ${mode}`);
          }
          this._spreadMode = mode;
          this.eventBus.dispatch("spreadmodechanged", {
            source: this,
            mode
          });
          this._updateSpreadMode(this._currentPageNumber);
        }
        _updateSpreadMode(pageNumber = null) {
          if (!this.pdfDocument) {
            return;
          }
          const viewer = this.viewer,
            pages = this._pages;
          if (this._scrollMode === _ui_utils.ScrollMode.PAGE) {
            _assertClassBrand(_BaseViewer_brand, this, _ensurePageViewVisible).call(this);
          } else {
            viewer.textContent = "";
            if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
              for (const pageView of this._pages) {
                viewer.appendChild(pageView.div);
              }
            } else {
              const parity = this._spreadMode - 1;
              let spread = null;
              for (let i = 0, ii = pages.length; i < ii; ++i) {
                if (spread === null) {
                  spread = document.createElement("div");
                  spread.className = "spread";
                  viewer.appendChild(spread);
                } else if (i % 2 === parity) {
                  spread = spread.cloneNode(false);
                  viewer.appendChild(spread);
                }
                spread.appendChild(pages[i].div);
              }
            }
          }
          if (!pageNumber) {
            return;
          }
          if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
            this._setScale(this._currentScaleValue, true);
          }
          this._setCurrentPageNumber(pageNumber, true);
          this.update();
        }
        _getPageAdvance(currentPageNumber, previous = false) {
          switch (this._scrollMode) {
            case _ui_utils.ScrollMode.WRAPPED:
              {
                const {
                    views
                  } = this._getVisiblePages(),
                  pageLayout = new Map();
                for (const {
                  id,
                  y,
                  percent,
                  widthPercent
                } of views) {
                  if (percent === 0 || widthPercent < 100) {
                    continue;
                  }
                  let yArray = pageLayout.get(y);
                  if (!yArray) {
                    pageLayout.set(y, yArray || (yArray = []));
                  }
                  yArray.push(id);
                }
                for (const yArray of pageLayout.values()) {
                  const currentIndex = yArray.indexOf(currentPageNumber);
                  if (currentIndex === -1) {
                    continue;
                  }
                  const numPages = yArray.length;
                  if (numPages === 1) {
                    break;
                  }
                  if (previous) {
                    for (let i = currentIndex - 1, ii = 0; i >= ii; i--) {
                      const currentId = yArray[i],
                        expectedId = yArray[i + 1] - 1;
                      if (currentId < expectedId) {
                        return currentPageNumber - expectedId;
                      }
                    }
                  } else {
                    for (let i = currentIndex + 1, ii = numPages; i < ii; i++) {
                      const currentId = yArray[i],
                        expectedId = yArray[i - 1] + 1;
                      if (currentId > expectedId) {
                        return expectedId - currentPageNumber;
                      }
                    }
                  }
                  if (previous) {
                    const firstId = yArray[0];
                    if (firstId < currentPageNumber) {
                      return currentPageNumber - firstId + 1;
                    }
                  } else {
                    const lastId = yArray[numPages - 1];
                    if (lastId > currentPageNumber) {
                      return lastId - currentPageNumber + 1;
                    }
                  }
                  break;
                }
                break;
              }
            case _ui_utils.ScrollMode.HORIZONTAL:
              {
                break;
              }
            case _ui_utils.ScrollMode.PAGE:
            case _ui_utils.ScrollMode.VERTICAL:
              {
                if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
                  break;
                }
                const parity = this._spreadMode - 1;
                if (previous && currentPageNumber % 2 !== parity) {
                  break;
                } else if (!previous && currentPageNumber % 2 === parity) {
                  break;
                }
                const {
                    views
                  } = this._getVisiblePages(),
                  expectedId = previous ? currentPageNumber - 1 : currentPageNumber + 1;
                for (const {
                  id,
                  percent,
                  widthPercent
                } of views) {
                  if (id !== expectedId) {
                    continue;
                  }
                  if (percent > 0 && widthPercent === 100) {
                    return 2;
                  }
                  break;
                }
                break;
              }
          }
          return 1;
        }
        nextPage() {
          const currentPageNumber = this._currentPageNumber,
            pagesCount = this.pagesCount;
          if (currentPageNumber >= pagesCount) {
            return false;
          }
          const advance = this._getPageAdvance(currentPageNumber, false) || 1;
          this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount);
          return true;
        }
        previousPage() {
          const currentPageNumber = this._currentPageNumber;
          if (currentPageNumber <= 1) {
            return false;
          }
          const advance = this._getPageAdvance(currentPageNumber, true) || 1;
          this.currentPageNumber = Math.max(currentPageNumber - advance, 1);
          return true;
        }
        increaseScale(steps = 1) {
          let newScale = this._currentScale;
          do {
            newScale = (newScale * _ui_utils.DEFAULT_SCALE_DELTA).toFixed(2);
            newScale = Math.ceil(newScale * 10) / 10;
            newScale = Math.min(_ui_utils.MAX_SCALE, newScale);
          } while (--steps > 0 && newScale < _ui_utils.MAX_SCALE);
          this.currentScaleValue = newScale;
        }
        decreaseScale(steps = 1) {
          let newScale = this._currentScale;
          do {
            newScale = (newScale / _ui_utils.DEFAULT_SCALE_DELTA).toFixed(2);
            newScale = Math.floor(newScale * 10) / 10;
            newScale = Math.max(_ui_utils.MIN_SCALE, newScale);
          } while (--steps > 0 && newScale > _ui_utils.MIN_SCALE);
          this.currentScaleValue = newScale;
        }
        updateContainerHeightCss() {
          const height = this.container.clientHeight;
          if (height !== _classPrivateFieldGet(_previousContainerHeight, this)) {
            _classPrivateFieldSet(_previousContainerHeight, this, height);
            this._doc.style.setProperty("--viewer-container-height", `${height}px`);
          }
        }
      }
      function _initializePermissions(permissions) {
        if (!permissions) {
          return;
        }
        if (!permissions.includes(_pdfjsLib.PermissionFlag.COPY)) {
          this.viewer.classList.add(ENABLE_PERMISSIONS_CLASS);
        }
        if (!permissions.includes(_pdfjsLib.PermissionFlag.MODIFY_ANNOTATIONS) && !permissions.includes(_pdfjsLib.PermissionFlag.FILL_INTERACTIVE_FORMS)) {
          if (_classPrivateFieldGet(_annotationMode, this) === _pdfjsLib.AnnotationMode.ENABLE_FORMS) {
            _classPrivateFieldSet(_previousAnnotationMode, this, _classPrivateFieldGet(_annotationMode, this));
            _classPrivateFieldSet(_annotationMode, this, _pdfjsLib.AnnotationMode.ENABLE);
          }
        }
      }
      function _onePageRenderedOrForceFetch() {
        if (document.visibilityState === "hidden" || !this.container.offsetParent || this._getVisiblePages().views.length === 0) {
          return Promise.resolve();
        }
        const visibilityChangePromise = new Promise(resolve => {
          _classPrivateFieldSet(_onVisibilityChange, this, () => {
            if (document.visibilityState !== "hidden") {
              return;
            }
            resolve();
            document.removeEventListener("visibilitychange", _classPrivateFieldGet(_onVisibilityChange, this));
            _classPrivateFieldSet(_onVisibilityChange, this, null);
          });
          document.addEventListener("visibilitychange", _classPrivateFieldGet(_onVisibilityChange, this));
        });
        return Promise.race([this._onePageRenderedCapability.promise, visibilityChangePromise]);
      }
      function _ensurePageViewVisible() {
        if (this._scrollMode !== _ui_utils.ScrollMode.PAGE) {
          throw new Error("#ensurePageViewVisible: Invalid scrollMode value.");
        }
        const pageNumber = this._currentPageNumber,
          state = _classPrivateFieldGet(_scrollModePageState, this),
          viewer = this.viewer;
        viewer.textContent = "";
        state.pages.length = 0;
        if (this._spreadMode === _ui_utils.SpreadMode.NONE && !this.isInPresentationMode) {
          const pageView = this._pages[pageNumber - 1];
          viewer.appendChild(pageView.div);
          state.pages.push(pageView);
        } else {
          const pageIndexSet = new Set(),
            parity = this._spreadMode - 1;
          if (parity === -1) {
            pageIndexSet.add(pageNumber - 1);
          } else if (pageNumber % 2 !== parity) {
            pageIndexSet.add(pageNumber - 1);
            pageIndexSet.add(pageNumber);
          } else {
            pageIndexSet.add(pageNumber - 2);
            pageIndexSet.add(pageNumber - 1);
          }
          const spread = document.createElement("div");
          spread.className = "spread";
          if (this.isInPresentationMode) {
            const dummyPage = document.createElement("div");
            dummyPage.className = "dummyPage";
            spread.appendChild(dummyPage);
          }
          for (const i of pageIndexSet) {
            const pageView = this._pages[i];
            if (!pageView) {
              continue;
            }
            spread.appendChild(pageView.div);
            state.pages.push(pageView);
          }
          viewer.appendChild(spread);
        }
        state.scrollDown = pageNumber >= state.previousPageNumber;
        state.previousPageNumber = pageNumber;
      }
      function _scrollIntoView(pageView, pageSpot = null) {
        const {
          div,
          id
        } = pageView;
        if (this._scrollMode === _ui_utils.ScrollMode.PAGE) {
          this._setCurrentPageNumber(id);
          _assertClassBrand(_BaseViewer_brand, this, _ensurePageViewVisible).call(this);
          this.update();
        }
        if (!pageSpot && !this.isInPresentationMode) {
          const left = div.offsetLeft + div.clientLeft,
            right = left + div.clientWidth;
          const {
            scrollLeft,
            clientWidth
          } = this.container;
          if (this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL || left < scrollLeft || right > scrollLeft + clientWidth) {
            pageSpot = {
              left: 0,
              top: 0
            };
          }
        }
        (0, _ui_utils.scrollIntoView)(div, pageSpot);
      }
      function _isSameScale(newScale) {
        return newScale === this._currentScale || Math.abs(newScale - this._currentScale) < 1e-15;
      }
      function _resetCurrentPageView() {
        const pageView = this._pages[this._currentPageNumber - 1];
        if (this.isInPresentationMode) {
          this._setScale(this._currentScaleValue, true);
        }
        _assertClassBrand(_BaseViewer_brand, this, _scrollIntoView).call(this, pageView);
      }
      function _ensurePdfPageLoaded(_x) {
        return _ensurePdfPageLoaded2.apply(this, arguments);
      }
      function _ensurePdfPageLoaded2() {
        _ensurePdfPageLoaded2 = _asyncToGenerator(function* (pageView) {
          if (pageView.pdfPage) {
            return pageView.pdfPage;
          }
          try {
            var _this$linkService$_ca, _this$linkService;
            const pdfPage = yield this.pdfDocument.getPage(pageView.id);
            if (!pageView.pdfPage) {
              pageView.setPdfPage(pdfPage);
            }
            if (!((_this$linkService$_ca = (_this$linkService = this.linkService)._cachedPageNumber) !== null && _this$linkService$_ca !== void 0 && _this$linkService$_ca.call(_this$linkService, pdfPage.ref))) {
              this.linkService.cachePageRef(pageView.id, pdfPage.ref);
            }
            return pdfPage;
          } catch (reason) {
            console.error("Unable to get page for page view", reason);
            return null;
          }
        });
        return _ensurePdfPageLoaded2.apply(this, arguments);
      }
      function _getScrollAhead(visible) {
        var _visible$first, _visible$last;
        if (((_visible$first = visible.first) === null || _visible$first === void 0 ? void 0 : _visible$first.id) === 1) {
          return true;
        } else if (((_visible$last = visible.last) === null || _visible$last === void 0 ? void 0 : _visible$last.id) === this.pagesCount) {
          return false;
        }
        switch (this._scrollMode) {
          case _ui_utils.ScrollMode.PAGE:
            return _classPrivateFieldGet(_scrollModePageState, this).scrollDown;
          case _ui_utils.ScrollMode.HORIZONTAL:
            return this.scroll.right;
        }
        return this.scroll.down;
      }
      function _toggleLoadingIconSpinner(visibleIds) {
        for (const id of visibleIds) {
          const pageView = this._pages[id - 1];
          pageView === null || pageView === void 0 ? void 0 : pageView.toggleLoadingIconSpinner(true);
        }
        for (const pageView of _classPrivateFieldGet(_buffer, this)) {
          if (visibleIds.has(pageView.id)) {
            continue;
          }
          pageView.toggleLoadingIconSpinner(false);
        }
      }
      exports.BaseViewer = BaseViewer;

      /***/
    }), ( /* 12 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFPageView = void 0;
      var _pdfjsLib = __w_pdfjs_require__(3);
      var _ui_utils = __w_pdfjs_require__(6);
      var _app_options = __w_pdfjs_require__(13);
      var _l10n_utils = __w_pdfjs_require__(4);
      const MAX_CANVAS_PIXELS = _app_options.compatibilityParams.maxCanvasPixels || 16777216;
      var _annotationMode2 = /*#__PURE__*/new WeakMap();
      class PDFPageView {
        constructor(options) {
          var _options$textLayerMod2, _options$annotationMo2, _options$textHighligh, _this$renderingQueue;
          _classPrivateFieldInitSpec(this, _annotationMode2, _pdfjsLib.AnnotationMode.ENABLE_FORMS);
          const container = options.container;
          const defaultViewport = options.defaultViewport;
          this.id = options.id;
          this.renderingId = "page" + this.id;
          this.pdfPage = null;
          this.pageLabel = null;
          this.rotation = 0;
          this.scale = options.scale || _ui_utils.DEFAULT_SCALE;
          this.viewport = defaultViewport;
          this.pdfPageRotate = defaultViewport.rotation;
          this._optionalContentConfigPromise = options.optionalContentConfigPromise || null;
          this.hasRestrictedScaling = false;
          this.textLayerMode = (_options$textLayerMod2 = options.textLayerMode) !== null && _options$textLayerMod2 !== void 0 ? _options$textLayerMod2 : _ui_utils.TextLayerMode.ENABLE;
          _classPrivateFieldSet(_annotationMode2, this, (_options$annotationMo2 = options.annotationMode) !== null && _options$annotationMo2 !== void 0 ? _options$annotationMo2 : _pdfjsLib.AnnotationMode.ENABLE_FORMS);
          this.imageResourcesPath = options.imageResourcesPath || "";
          this.useOnlyCssZoom = options.useOnlyCssZoom || false;
          this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS;
          this.pageColors = options.pageColors || null;
          this.eventBus = options.eventBus;
          this.renderingQueue = options.renderingQueue;
          this.textLayerFactory = options.textLayerFactory;
          this.annotationLayerFactory = options.annotationLayerFactory;
          this.xfaLayerFactory = options.xfaLayerFactory;
          this.textHighlighter = (_options$textHighligh = options.textHighlighterFactory) === null || _options$textHighligh === void 0 ? void 0 : _options$textHighligh.createTextHighlighter(this.id - 1, this.eventBus);
          this.structTreeLayerFactory = options.structTreeLayerFactory;
          this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
          this.l10n = options.l10n || _l10n_utils.NullL10n;
          this.paintTask = null;
          this.paintedViewportMap = new WeakMap();
          this.renderingState = _ui_utils.RenderingStates.INITIAL;
          this.resume = null;
          this._renderError = null;
          this._isStandalone = !((_this$renderingQueue = this.renderingQueue) !== null && _this$renderingQueue !== void 0 && _this$renderingQueue.hasViewer());
          this._annotationCanvasMap = null;
          this.annotationLayer = null;
          this.textLayer = null;
          this.zoomLayer = null;
          this.xfaLayer = null;
          this.structTreeLayer = null;
          const div = document.createElement("div");
          div.className = "page";
          div.style.width = Math.floor(this.viewport.width) + "px";
          div.style.height = Math.floor(this.viewport.height) + "px";
          div.setAttribute("data-page-number", this.id);
          div.setAttribute("role", "region");
          this.l10n.get("page_landmark", {
            page: this.id
          }).then(msg => {
            div.setAttribute("aria-label", msg);
          });
          this.div = div;
          container === null || container === void 0 ? void 0 : container.appendChild(div);
        }
        setPdfPage(pdfPage) {
          this.pdfPage = pdfPage;
          this.pdfPageRotate = pdfPage.rotate;
          const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
          this.viewport = pdfPage.getViewport({
            scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS,
            rotation: totalRotation
          });
          this.reset();
        }
        destroy() {
          this.reset();
          if (this.pdfPage) {
            this.pdfPage.cleanup();
          }
        }
        _renderAnnotationLayer() {
          var _this4 = this;
          return _asyncToGenerator(function* () {
            let error = null;
            try {
              yield _this4.annotationLayer.render(_this4.viewport, "display");
            } catch (ex) {
              error = ex;
            } finally {
              _this4.eventBus.dispatch("annotationlayerrendered", {
                source: _this4,
                pageNumber: _this4.id,
                error
              });
            }
          })();
        }
        _renderXfaLayer() {
          var _this5 = this;
          return _asyncToGenerator(function* () {
            let error = null;
            try {
              const result = yield _this5.xfaLayer.render(_this5.viewport, "display");
              if (_this5.textHighlighter) {
                _this5._buildXfaTextContentItems(result.textDivs);
              }
            } catch (ex) {
              error = ex;
            } finally {
              _this5.eventBus.dispatch("xfalayerrendered", {
                source: _this5,
                pageNumber: _this5.id,
                error
              });
            }
          })();
        }
        _buildXfaTextContentItems(textDivs) {
          var _this6 = this;
          return _asyncToGenerator(function* () {
            const text = yield _this6.pdfPage.getTextContent();
            const items = [];
            for (const item of text.items) {
              items.push(item.str);
            }
            _this6.textHighlighter.setTextMapping(textDivs, items);
            _this6.textHighlighter.enable();
          })();
        }
        _resetZoomLayer(removeFromDOM = false) {
          if (!this.zoomLayer) {
            return;
          }
          const zoomLayerCanvas = this.zoomLayer.firstChild;
          this.paintedViewportMap.delete(zoomLayerCanvas);
          zoomLayerCanvas.width = 0;
          zoomLayerCanvas.height = 0;
          if (removeFromDOM) {
            this.zoomLayer.remove();
          }
          this.zoomLayer = null;
        }
        reset({
          keepZoomLayer = false,
          keepAnnotationLayer = false,
          keepXfaLayer = false
        } = {}) {
          var _this$annotationLayer, _this$xfaLayer;
          this.cancelRendering({
            keepAnnotationLayer,
            keepXfaLayer
          });
          this.renderingState = _ui_utils.RenderingStates.INITIAL;
          const div = this.div;
          div.style.width = Math.floor(this.viewport.width) + "px";
          div.style.height = Math.floor(this.viewport.height) + "px";
          const childNodes = div.childNodes,
            zoomLayerNode = keepZoomLayer && this.zoomLayer || null,
            annotationLayerNode = keepAnnotationLayer && ((_this$annotationLayer = this.annotationLayer) === null || _this$annotationLayer === void 0 ? void 0 : _this$annotationLayer.div) || null,
            xfaLayerNode = keepXfaLayer && ((_this$xfaLayer = this.xfaLayer) === null || _this$xfaLayer === void 0 ? void 0 : _this$xfaLayer.div) || null;
          for (let i = childNodes.length - 1; i >= 0; i--) {
            const node = childNodes[i];
            switch (node) {
              case zoomLayerNode:
              case annotationLayerNode:
              case xfaLayerNode:
                continue;
            }
            node.remove();
          }
          div.removeAttribute("data-loaded");
          if (annotationLayerNode) {
            this.annotationLayer.hide();
          }
          if (xfaLayerNode) {
            this.xfaLayer.hide();
          }
          if (!zoomLayerNode) {
            if (this.canvas) {
              this.paintedViewportMap.delete(this.canvas);
              this.canvas.width = 0;
              this.canvas.height = 0;
              delete this.canvas;
            }
            this._resetZoomLayer();
          }
          if (this.svg) {
            this.paintedViewportMap.delete(this.svg);
            delete this.svg;
          }
          this.loadingIconDiv = document.createElement("div");
          this.loadingIconDiv.className = "loadingIcon notVisible";
          if (this._isStandalone) {
            this.toggleLoadingIconSpinner(true);
          }
          this.loadingIconDiv.setAttribute("role", "img");
          this.l10n.get("loading").then(msg => {
            var _this$loadingIconDiv;
            (_this$loadingIconDiv = this.loadingIconDiv) === null || _this$loadingIconDiv === void 0 ? void 0 : _this$loadingIconDiv.setAttribute("aria-label", msg);
          });
          div.appendChild(this.loadingIconDiv);
        }
        update({
          scale = 0,
          rotation = null,
          optionalContentConfigPromise = null
        }) {
          this.scale = scale || this.scale;
          if (typeof rotation === "number") {
            this.rotation = rotation;
          }
          if (optionalContentConfigPromise instanceof Promise) {
            this._optionalContentConfigPromise = optionalContentConfigPromise;
          }
          const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
          this.viewport = this.viewport.clone({
            scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS,
            rotation: totalRotation
          });
          if (this._isStandalone) {
            const {
              style
            } = document.documentElement;
            style.setProperty("--zoom-factor", this.scale);
          }
          if (this.svg) {
            this.cssTransform({
              target: this.svg,
              redrawAnnotationLayer: true,
              redrawXfaLayer: true
            });
            this.eventBus.dispatch("pagerendered", {
              source: this,
              pageNumber: this.id,
              cssTransform: true,
              timestamp: performance.now(),
              error: this._renderError
            });
            return;
          }
          let isScalingRestricted = false;
          if (this.canvas && this.maxCanvasPixels > 0) {
            const outputScale = this.outputScale;
            if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) {
              isScalingRestricted = true;
            }
          }
          if (this.canvas) {
            if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) {
              this.cssTransform({
                target: this.canvas,
                redrawAnnotationLayer: true,
                redrawXfaLayer: true
              });
              this.eventBus.dispatch("pagerendered", {
                source: this,
                pageNumber: this.id,
                cssTransform: true,
                timestamp: performance.now(),
                error: this._renderError
              });
              return;
            }
            if (!this.zoomLayer && !this.canvas.hidden) {
              this.zoomLayer = this.canvas.parentNode;
              this.zoomLayer.style.position = "absolute";
            }
          }
          if (this.zoomLayer) {
            this.cssTransform({
              target: this.zoomLayer.firstChild
            });
          }
          this.reset({
            keepZoomLayer: true,
            keepAnnotationLayer: true,
            keepXfaLayer: true
          });
        }
        cancelRendering({
          keepAnnotationLayer = false,
          keepXfaLayer = false
        } = {}) {
          if (this.paintTask) {
            this.paintTask.cancel();
            this.paintTask = null;
          }
          this.resume = null;
          if (this.textLayer) {
            this.textLayer.cancel();
            this.textLayer = null;
          }
          if (this.annotationLayer && (!keepAnnotationLayer || !this.annotationLayer.div)) {
            this.annotationLayer.cancel();
            this.annotationLayer = null;
            this._annotationCanvasMap = null;
          }
          if (this.xfaLayer && (!keepXfaLayer || !this.xfaLayer.div)) {
            var _this$textHighlighter;
            this.xfaLayer.cancel();
            this.xfaLayer = null;
            (_this$textHighlighter = this.textHighlighter) === null || _this$textHighlighter === void 0 ? void 0 : _this$textHighlighter.disable();
          }
          if (this._onTextLayerRendered) {
            this.eventBus._off("textlayerrendered", this._onTextLayerRendered);
            this._onTextLayerRendered = null;
          }
        }
        cssTransform({
          target,
          redrawAnnotationLayer = false,
          redrawXfaLayer = false
        }) {
          const width = this.viewport.width;
          const height = this.viewport.height;
          const div = this.div;
          target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + "px";
          target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + "px";
          const relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation;
          const absRotation = Math.abs(relativeRotation);
          let scaleX = 1,
            scaleY = 1;
          if (absRotation === 90 || absRotation === 270) {
            scaleX = height / width;
            scaleY = width / height;
          }
          target.style.transform = `rotate(${relativeRotation}deg) scale(${scaleX}, ${scaleY})`;
          if (this.textLayer) {
            const textLayerViewport = this.textLayer.viewport;
            const textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation;
            const textAbsRotation = Math.abs(textRelativeRotation);
            let scale = width / textLayerViewport.width;
            if (textAbsRotation === 90 || textAbsRotation === 270) {
              scale = width / textLayerViewport.height;
            }
            const textLayerDiv = this.textLayer.textLayerDiv;
            let transX, transY;
            switch (textAbsRotation) {
              case 0:
                transX = transY = 0;
                break;
              case 90:
                transX = 0;
                transY = "-" + textLayerDiv.style.height;
                break;
              case 180:
                transX = "-" + textLayerDiv.style.width;
                transY = "-" + textLayerDiv.style.height;
                break;
              case 270:
                transX = "-" + textLayerDiv.style.width;
                transY = 0;
                break;
              default:
                console.error("Bad rotation value.");
                break;
            }
            textLayerDiv.style.transform = `rotate(${textAbsRotation}deg) ` + `scale(${scale}) ` + `translate(${transX}, ${transY})`;
            textLayerDiv.style.transformOrigin = "0% 0%";
          }
          if (redrawAnnotationLayer && this.annotationLayer) {
            this._renderAnnotationLayer();
          }
          if (redrawXfaLayer && this.xfaLayer) {
            this._renderXfaLayer();
          }
        }
        get width() {
          return this.viewport.width;
        }
        get height() {
          return this.viewport.height;
        }
        getPagePoint(x, y) {
          return this.viewport.convertToPdfPoint(x, y);
        }
        toggleLoadingIconSpinner(viewVisible = false) {
          var _this$loadingIconDiv2;
          (_this$loadingIconDiv2 = this.loadingIconDiv) === null || _this$loadingIconDiv2 === void 0 ? void 0 : _this$loadingIconDiv2.classList.toggle("notVisible", !viewVisible);
        }
        draw() {
          var _this$annotationLayer2,
            _this$xfaLayer2,
            _this7 = this;
          if (this.renderingState !== _ui_utils.RenderingStates.INITIAL) {
            console.error("Must be in new state before drawing");
            this.reset();
          }
          const {
            div,
            pdfPage
          } = this;
          if (!pdfPage) {
            this.renderingState = _ui_utils.RenderingStates.FINISHED;
            if (this.loadingIconDiv) {
              this.loadingIconDiv.remove();
              delete this.loadingIconDiv;
            }
            return Promise.reject(new Error("pdfPage is not loaded"));
          }
          this.renderingState = _ui_utils.RenderingStates.RUNNING;
          const canvasWrapper = document.createElement("div");
          canvasWrapper.style.width = div.style.width;
          canvasWrapper.style.height = div.style.height;
          canvasWrapper.classList.add("canvasWrapper");
          if ((_this$annotationLayer2 = this.annotationLayer) !== null && _this$annotationLayer2 !== void 0 && _this$annotationLayer2.div) {
            div.insertBefore(canvasWrapper, this.annotationLayer.div);
          } else {
            div.appendChild(canvasWrapper);
          }
          let textLayer = null;
          if (this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && this.textLayerFactory) {
            var _this$annotationLayer3;
            const textLayerDiv = document.createElement("div");
            textLayerDiv.className = "textLayer";
            textLayerDiv.style.width = canvasWrapper.style.width;
            textLayerDiv.style.height = canvasWrapper.style.height;
            if ((_this$annotationLayer3 = this.annotationLayer) !== null && _this$annotationLayer3 !== void 0 && _this$annotationLayer3.div) {
              div.insertBefore(textLayerDiv, this.annotationLayer.div);
            } else {
              div.appendChild(textLayerDiv);
            }
            textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.textLayerMode === _ui_utils.TextLayerMode.ENABLE_ENHANCE, this.eventBus, this.textHighlighter);
          }
          this.textLayer = textLayer;
          if (_classPrivateFieldGet(_annotationMode2, this) !== _pdfjsLib.AnnotationMode.DISABLE && this.annotationLayerFactory) {
            this._annotationCanvasMap || (this._annotationCanvasMap = new Map());
            this.annotationLayer || (this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, null, this.imageResourcesPath, _classPrivateFieldGet(_annotationMode2, this) === _pdfjsLib.AnnotationMode.ENABLE_FORMS, this.l10n, null, null, null, null, this._annotationCanvasMap));
          }
          if ((_this$xfaLayer2 = this.xfaLayer) !== null && _this$xfaLayer2 !== void 0 && _this$xfaLayer2.div) {
            div.appendChild(this.xfaLayer.div);
          }
          let renderContinueCallback = null;
          if (this.renderingQueue) {
            renderContinueCallback = cont => {
              if (!this.renderingQueue.isHighestPriority(this)) {
                this.renderingState = _ui_utils.RenderingStates.PAUSED;
                this.resume = () => {
                  this.renderingState = _ui_utils.RenderingStates.RUNNING;
                  cont();
                };
                return;
              }
              cont();
            };
          }
          const finishPaintTask = /*#__PURE__*/function () {
            var _ref2 = _asyncToGenerator(function* (error = null) {
              if (paintTask === _this7.paintTask) {
                _this7.paintTask = null;
              }
              if (error instanceof _pdfjsLib.RenderingCancelledException) {
                _this7._renderError = null;
                return;
              }
              _this7._renderError = error;
              _this7.renderingState = _ui_utils.RenderingStates.FINISHED;
              if (_this7.loadingIconDiv) {
                _this7.loadingIconDiv.remove();
                delete _this7.loadingIconDiv;
              }
              _this7._resetZoomLayer(true);
              _this7.eventBus.dispatch("pagerendered", {
                source: _this7,
                pageNumber: _this7.id,
                cssTransform: false,
                timestamp: performance.now(),
                error: _this7._renderError
              });
              if (error) {
                throw error;
              }
            });
            return function finishPaintTask() {
              return _ref2.apply(this, arguments);
            };
          }();
          const paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper);
          paintTask.onRenderContinue = renderContinueCallback;
          this.paintTask = paintTask;
          const resultPromise = paintTask.promise.then(() => {
            return finishPaintTask(null).then(() => {
              if (textLayer) {
                const readableStream = pdfPage.streamTextContent({
                  includeMarkedContent: true
                });
                textLayer.setTextContentStream(readableStream);
                textLayer.render();
              }
              if (this.annotationLayer) {
                this._renderAnnotationLayer();
              }
            });
          }, function (reason) {
            return finishPaintTask(reason);
          });
          if (this.xfaLayerFactory) {
            if (!this.xfaLayer) {
              this.xfaLayer = this.xfaLayerFactory.createXfaLayerBuilder(div, pdfPage, null);
            }
            this._renderXfaLayer();
          }
          if (this.structTreeLayerFactory && this.textLayer && this.canvas) {
            this._onTextLayerRendered = event => {
              if (event.pageNumber !== this.id) {
                return;
              }
              this.eventBus._off("textlayerrendered", this._onTextLayerRendered);
              this._onTextLayerRendered = null;
              if (!this.canvas) {
                return;
              }
              this.pdfPage.getStructTree().then(tree => {
                if (!tree) {
                  return;
                }
                if (!this.canvas) {
                  return;
                }
                const treeDom = this.structTreeLayer.render(tree);
                treeDom.classList.add("structTree");
                this.canvas.appendChild(treeDom);
              });
            };
            this.eventBus._on("textlayerrendered", this._onTextLayerRendered);
            this.structTreeLayer = this.structTreeLayerFactory.createStructTreeLayerBuilder(pdfPage);
          }
          div.setAttribute("data-loaded", true);
          this.eventBus.dispatch("pagerender", {
            source: this,
            pageNumber: this.id
          });
          return resultPromise;
        }
        paintOnCanvas(canvasWrapper) {
          const renderCapability = (0, _pdfjsLib.createPromiseCapability)();
          const result = {
            promise: renderCapability.promise,
            onRenderContinue(cont) {
              cont();
            },
            cancel() {
              renderTask.cancel();
            }
          };
          const viewport = this.viewport;
          const canvas = document.createElement("canvas");
          canvas.hidden = true;
          let isCanvasHidden = true;
          const showCanvas = function () {
            if (isCanvasHidden) {
              canvas.hidden = false;
              isCanvasHidden = false;
            }
          };
          canvasWrapper.appendChild(canvas);
          this.canvas = canvas;
          const ctx = canvas.getContext("2d", {
            alpha: false
          });
          const outputScale = this.outputScale = new _ui_utils.OutputScale();
          if (this.useOnlyCssZoom) {
            const actualSizeViewport = viewport.clone({
              scale: _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS
            });
            outputScale.sx *= actualSizeViewport.width / viewport.width;
            outputScale.sy *= actualSizeViewport.height / viewport.height;
          }
          if (this.maxCanvasPixels > 0) {
            const pixelsInViewport = viewport.width * viewport.height;
            const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);
            if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
              outputScale.sx = maxScale;
              outputScale.sy = maxScale;
              this.hasRestrictedScaling = true;
            } else {
              this.hasRestrictedScaling = false;
            }
          }
          const sfx = (0, _ui_utils.approximateFraction)(outputScale.sx);
          const sfy = (0, _ui_utils.approximateFraction)(outputScale.sy);
          canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]);
          canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]);
          canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + "px";
          canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + "px";
          this.paintedViewportMap.set(canvas, viewport);
          const transform = outputScale.scaled ? [outputScale.sx, 0, 0, outputScale.sy, 0, 0] : null;
          const renderContext = {
            canvasContext: ctx,
            transform,
            viewport: this.viewport,
            annotationMode: _classPrivateFieldGet(_annotationMode2, this),
            optionalContentConfigPromise: this._optionalContentConfigPromise,
            annotationCanvasMap: this._annotationCanvasMap,
            pageColors: this.pageColors
          };
          const renderTask = this.pdfPage.render(renderContext);
          renderTask.onContinue = function (cont) {
            showCanvas();
            if (result.onRenderContinue) {
              result.onRenderContinue(cont);
            } else {
              cont();
            }
          };
          renderTask.promise.then(function () {
            showCanvas();
            renderCapability.resolve();
          }, function (error) {
            showCanvas();
            renderCapability.reject(error);
          });
          return result;
        }
        paintOnSvg(wrapper) {
          let cancelled = false;
          const ensureNotCancelled = () => {
            if (cancelled) {
              throw new _pdfjsLib.RenderingCancelledException(`Rendering cancelled, page ${this.id}`, "svg");
            }
          };
          const pdfPage = this.pdfPage;
          const actualSizeViewport = this.viewport.clone({
            scale: _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS
          });
          const promise = pdfPage.getOperatorList({
            annotationMode: _classPrivateFieldGet(_annotationMode2, this)
          }).then(opList => {
            ensureNotCancelled();
            const svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs);
            return svgGfx.getSVG(opList, actualSizeViewport).then(svg => {
              ensureNotCancelled();
              this.svg = svg;
              this.paintedViewportMap.set(svg, actualSizeViewport);
              svg.style.width = wrapper.style.width;
              svg.style.height = wrapper.style.height;
              this.renderingState = _ui_utils.RenderingStates.FINISHED;
              wrapper.appendChild(svg);
            });
          });
          return {
            promise,
            onRenderContinue(cont) {
              cont();
            },
            cancel() {
              cancelled = true;
            }
          };
        }
        setPageLabel(label) {
          this.pageLabel = typeof label === "string" ? label : null;
          if (this.pageLabel !== null) {
            this.div.setAttribute("data-page-label", this.pageLabel);
          } else {
            this.div.removeAttribute("data-page-label");
          }
        }
      }
      exports.PDFPageView = PDFPageView;

      /***/
    }), ( /* 13 */
    /***/(__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.compatibilityParams = exports.OptionKind = exports.AppOptions = void 0;
      const compatibilityParams = Object.create(null);
      exports.compatibilityParams = compatibilityParams;
      {
        const userAgent = navigator.userAgent || "";
        const platform = navigator.platform || "";
        const maxTouchPoints = navigator.maxTouchPoints || 1;
        const isAndroid = /Android/.test(userAgent);
        const isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1;
        (function checkCanvasSizeLimitation() {
          if (isIOS || isAndroid) {
            compatibilityParams.maxCanvasPixels = 5242880;
          }
        })();
      }
      const OptionKind = {
        VIEWER: 0x02,
        API: 0x04,
        WORKER: 0x08,
        PREFERENCE: 0x80
      };
      exports.OptionKind = OptionKind;
      const defaultOptions = {
        annotationMode: {
          value: 2,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        cursorToolOnLoad: {
          value: 0,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        defaultUrl: {
          value: "compressed.tracemonkey-pldi-09.pdf",
          kind: OptionKind.VIEWER
        },
        defaultZoomValue: {
          value: "",
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        disableHistory: {
          value: false,
          kind: OptionKind.VIEWER
        },
        disablePageLabels: {
          value: false,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        enablePermissions: {
          value: false,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        enablePrintAutoRotate: {
          value: true,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        enableScripting: {
          value: true,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        externalLinkRel: {
          value: "noopener noreferrer nofollow",
          kind: OptionKind.VIEWER
        },
        externalLinkTarget: {
          value: 0,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        historyUpdateUrl: {
          value: false,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        ignoreDestinationZoom: {
          value: false,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        imageResourcesPath: {
          value: "./images/",
          kind: OptionKind.VIEWER
        },
        maxCanvasPixels: {
          value: 16777216,
          compatibility: compatibilityParams.maxCanvasPixels,
          kind: OptionKind.VIEWER
        },
        pageColorsBackground: {
          value: "Canvas",
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        pageColorsForeground: {
          value: "CanvasText",
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        pdfBugEnabled: {
          value: false,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        printResolution: {
          value: 150,
          kind: OptionKind.VIEWER
        },
        renderer: {
          value: "canvas",
          kind: OptionKind.VIEWER
        },
        sidebarViewOnLoad: {
          value: -1,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        scrollModeOnLoad: {
          value: -1,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        spreadModeOnLoad: {
          value: -1,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        textLayerMode: {
          value: 1,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        useOnlyCssZoom: {
          value: false,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        viewerCssTheme: {
          value: 0,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        viewOnLoad: {
          value: 0,
          kind: OptionKind.VIEWER + OptionKind.PREFERENCE
        },
        cMapPacked: {
          value: true,
          kind: OptionKind.API
        },
        cMapUrl: {
          value: "../web/cmaps/",
          kind: OptionKind.API
        },
        disableAutoFetch: {
          value: false,
          kind: OptionKind.API + OptionKind.PREFERENCE
        },
        disableFontFace: {
          value: false,
          kind: OptionKind.API + OptionKind.PREFERENCE
        },
        disableRange: {
          value: false,
          kind: OptionKind.API + OptionKind.PREFERENCE
        },
        disableStream: {
          value: false,
          kind: OptionKind.API + OptionKind.PREFERENCE
        },
        docBaseUrl: {
          value: "",
          kind: OptionKind.API
        },
        enableXfa: {
          value: true,
          kind: OptionKind.API + OptionKind.PREFERENCE
        },
        fontExtraProperties: {
          value: false,
          kind: OptionKind.API
        },
        isEvalSupported: {
          value: true,
          kind: OptionKind.API
        },
        maxImageSize: {
          value: -1,
          kind: OptionKind.API
        },
        pdfBug: {
          value: false,
          kind: OptionKind.API
        },
        standardFontDataUrl: {
          value: "../web/standard_fonts/",
          kind: OptionKind.API
        },
        verbosity: {
          value: 1,
          kind: OptionKind.API
        },
        workerPort: {
          value: null,
          kind: OptionKind.WORKER
        },
        workerSrc: {
          value: "../build/pdf.worker.js",
          kind: OptionKind.WORKER
        }
      };
      {
        defaultOptions.disablePreferences = {
          value: false,
          kind: OptionKind.VIEWER
        };
        defaultOptions.locale = {
          value: navigator.language || "en-US",
          kind: OptionKind.VIEWER
        };
        defaultOptions.sandboxBundleSrc = {
          value: "../build/pdf.sandbox.js",
          kind: OptionKind.VIEWER
        };
        defaultOptions.renderer.kind += OptionKind.PREFERENCE;
      }
      const userOptions = Object.create(null);
      class AppOptions {
        constructor() {
          throw new Error("Cannot initialize AppOptions.");
        }
        static get(name) {
          const userOption = userOptions[name];
          if (userOption !== undefined) {
            return userOption;
          }
          const defaultOption = defaultOptions[name];
          if (defaultOption !== undefined) {
            var _defaultOption$compat;
            return (_defaultOption$compat = defaultOption.compatibility) !== null && _defaultOption$compat !== void 0 ? _defaultOption$compat : defaultOption.value;
          }
          return undefined;
        }
        static getAll(kind = null) {
          const options = Object.create(null);
          for (const name in defaultOptions) {
            var _defaultOption$compat2;
            const defaultOption = defaultOptions[name];
            if (kind) {
              if ((kind & defaultOption.kind) === 0) {
                continue;
              }
              if (kind === OptionKind.PREFERENCE) {
                const value = defaultOption.value,
                  valueType = typeof value;
                if (valueType === "boolean" || valueType === "string" || valueType === "number" && Number.isInteger(value)) {
                  options[name] = value;
                  continue;
                }
                throw new Error(`Invalid type for preference: ${name}`);
              }
            }
            const userOption = userOptions[name];
            options[name] = userOption !== undefined ? userOption : (_defaultOption$compat2 = defaultOption.compatibility) !== null && _defaultOption$compat2 !== void 0 ? _defaultOption$compat2 : defaultOption.value;
          }
          return options;
        }
        static set(name, value) {
          userOptions[name] = value;
        }
        static setAll(options) {
          for (const name in options) {
            userOptions[name] = options[name];
          }
        }
        static remove(name) {
          delete userOptions[name];
        }
        static _hasUserOptions() {
          return Object.keys(userOptions).length > 0;
        }
      }
      exports.AppOptions = AppOptions;

      /***/
    }), ( /* 14 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFRenderingQueue = void 0;
      var _pdfjsLib = __w_pdfjs_require__(3);
      var _ui_utils = __w_pdfjs_require__(6);
      const CLEANUP_TIMEOUT = 30000;
      class PDFRenderingQueue {
        constructor() {
          this.pdfViewer = null;
          this.pdfThumbnailViewer = null;
          this.onIdle = null;
          this.highestPriorityPage = null;
          this.idleTimeout = null;
          this.printing = false;
          this.isThumbnailViewEnabled = false;
        }
        setViewer(pdfViewer) {
          this.pdfViewer = pdfViewer;
        }
        setThumbnailViewer(pdfThumbnailViewer) {
          this.pdfThumbnailViewer = pdfThumbnailViewer;
        }
        isHighestPriority(view) {
          return this.highestPriorityPage === view.renderingId;
        }
        hasViewer() {
          return !!this.pdfViewer;
        }
        renderHighestPriority(currentlyVisiblePages) {
          var _this$pdfThumbnailVie;
          if (this.idleTimeout) {
            clearTimeout(this.idleTimeout);
            this.idleTimeout = null;
          }
          if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
            return;
          }
          if (this.isThumbnailViewEnabled && (_this$pdfThumbnailVie = this.pdfThumbnailViewer) !== null && _this$pdfThumbnailVie !== void 0 && _this$pdfThumbnailVie.forceRendering()) {
            return;
          }
          if (this.printing) {
            return;
          }
          if (this.onIdle) {
            this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);
          }
        }
        getHighestPriority(visible, views, scrolledDown, preRenderExtra = false) {
          const visibleViews = visible.views,
            numVisible = visibleViews.length;
          if (numVisible === 0) {
            return null;
          }
          for (let i = 0; i < numVisible; i++) {
            const view = visibleViews[i].view;
            if (!this.isViewFinished(view)) {
              return view;
            }
          }
          const firstId = visible.first.id,
            lastId = visible.last.id;
          if (lastId - firstId + 1 > numVisible) {
            const visibleIds = visible.ids;
            for (let i = 1, ii = lastId - firstId; i < ii; i++) {
              const holeId = scrolledDown ? firstId + i : lastId - i;
              if (visibleIds.has(holeId)) {
                continue;
              }
              const holeView = views[holeId - 1];
              if (!this.isViewFinished(holeView)) {
                return holeView;
              }
            }
          }
          let preRenderIndex = scrolledDown ? lastId : firstId - 2;
          let preRenderView = views[preRenderIndex];
          if (preRenderView && !this.isViewFinished(preRenderView)) {
            return preRenderView;
          }
          if (preRenderExtra) {
            preRenderIndex += scrolledDown ? 1 : -1;
            preRenderView = views[preRenderIndex];
            if (preRenderView && !this.isViewFinished(preRenderView)) {
              return preRenderView;
            }
          }
          return null;
        }
        isViewFinished(view) {
          return view.renderingState === _ui_utils.RenderingStates.FINISHED;
        }
        renderView(view) {
          switch (view.renderingState) {
            case _ui_utils.RenderingStates.FINISHED:
              return false;
            case _ui_utils.RenderingStates.PAUSED:
              this.highestPriorityPage = view.renderingId;
              view.resume();
              break;
            case _ui_utils.RenderingStates.RUNNING:
              this.highestPriorityPage = view.renderingId;
              break;
            case _ui_utils.RenderingStates.INITIAL:
              this.highestPriorityPage = view.renderingId;
              view.draw().finally(() => {
                this.renderHighestPriority();
              }).catch(reason => {
                if (reason instanceof _pdfjsLib.RenderingCancelledException) {
                  return;
                }
                console.error(`renderView: "${reason}"`);
              });
              break;
          }
          return true;
        }
      }
      exports.PDFRenderingQueue = PDFRenderingQueue;

      /***/
    }), ( /* 15 */
    /***/(__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TextHighlighter = void 0;
      class TextHighlighter {
        constructor({
          findController,
          eventBus,
          pageIndex
        }) {
          this.findController = findController;
          this.matches = [];
          this.eventBus = eventBus;
          this.pageIdx = pageIndex;
          this._onUpdateTextLayerMatches = null;
          this.textDivs = null;
          this.textContentItemsStr = null;
          this.enabled = false;
        }
        setTextMapping(divs, texts) {
          this.textDivs = divs;
          this.textContentItemsStr = texts;
        }
        enable() {
          if (!this.textDivs || !this.textContentItemsStr) {
            throw new Error("Text divs and strings have not been set.");
          }
          if (this.enabled) {
            throw new Error("TextHighlighter is already enabled.");
          }
          this.enabled = true;
          if (!this._onUpdateTextLayerMatches) {
            this._onUpdateTextLayerMatches = evt => {
              if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {
                this._updateMatches();
              }
            };
            this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches);
          }
          this._updateMatches();
        }
        disable() {
          if (!this.enabled) {
            return;
          }
          this.enabled = false;
          if (this._onUpdateTextLayerMatches) {
            this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches);
            this._onUpdateTextLayerMatches = null;
          }
        }
        _convertMatches(matches, matchesLength) {
          if (!matches) {
            return [];
          }
          const {
            textContentItemsStr
          } = this;
          let i = 0,
            iIndex = 0;
          const end = textContentItemsStr.length - 1;
          const result = [];
          for (let m = 0, mm = matches.length; m < mm; m++) {
            let matchIdx = matches[m];
            while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
              iIndex += textContentItemsStr[i].length;
              i++;
            }
            if (i === textContentItemsStr.length) {
              console.error("Could not find a matching mapping");
            }
            const match = {
              begin: {
                divIdx: i,
                offset: matchIdx - iIndex
              }
            };
            matchIdx += matchesLength[m];
            while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
              iIndex += textContentItemsStr[i].length;
              i++;
            }
            match.end = {
              divIdx: i,
              offset: matchIdx - iIndex
            };
            result.push(match);
          }
          return result;
        }
        _renderMatches(matches) {
          if (matches.length === 0) {
            return;
          }
          const {
            findController,
            pageIdx
          } = this;
          const {
            textContentItemsStr,
            textDivs
          } = this;
          const isSelectedPage = pageIdx === findController.selected.pageIdx;
          const selectedMatchIdx = findController.selected.matchIdx;
          const highlightAll = findController.state.highlightAll;
          let prevEnd = null;
          const infinity = {
            divIdx: -1,
            offset: undefined
          };
          function beginText(begin, className) {
            const divIdx = begin.divIdx;
            textDivs[divIdx].textContent = "";
            return appendTextToDiv(divIdx, 0, begin.offset, className);
          }
          function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
            let div = textDivs[divIdx];
            if (div.nodeType === Node.TEXT_NODE) {
              const span = document.createElement("span");
              div.parentNode.insertBefore(span, div);
              span.appendChild(div);
              textDivs[divIdx] = span;
              div = span;
            }
            const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
            const node = document.createTextNode(content);
            if (className) {
              const span = document.createElement("span");
              span.className = `${className} appended`;
              span.appendChild(node);
              div.appendChild(span);
              return className.includes("selected") ? span.offsetLeft : 0;
            }
            div.appendChild(node);
            return 0;
          }
          let i0 = selectedMatchIdx,
            i1 = i0 + 1;
          if (highlightAll) {
            i0 = 0;
            i1 = matches.length;
          } else if (!isSelectedPage) {
            return;
          }
          for (let i = i0; i < i1; i++) {
            const match = matches[i];
            const begin = match.begin;
            const end = match.end;
            const isSelected = isSelectedPage && i === selectedMatchIdx;
            const highlightSuffix = isSelected ? " selected" : "";
            let selectedLeft = 0;
            if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
              if (prevEnd !== null) {
                appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
              }
              beginText(begin);
            } else {
              appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
            }
            if (begin.divIdx === end.divIdx) {
              selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix);
            } else {
              selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix);
              for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
                textDivs[n0].className = "highlight middle" + highlightSuffix;
              }
              beginText(end, "highlight end" + highlightSuffix);
            }
            prevEnd = end;
            if (isSelected) {
              findController.scrollMatchIntoView({
                element: textDivs[begin.divIdx],
                selectedLeft,
                pageIndex: pageIdx,
                matchIndex: selectedMatchIdx
              });
            }
          }
          if (prevEnd) {
            appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
          }
        }
        _updateMatches() {
          if (!this.enabled) {
            return;
          }
          const {
            findController,
            matches,
            pageIdx
          } = this;
          const {
            textContentItemsStr,
            textDivs
          } = this;
          let clearedUntilDivIdx = -1;
          for (let i = 0, ii = matches.length; i < ii; i++) {
            const match = matches[i];
            const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);
            for (let n = begin, end = match.end.divIdx; n <= end; n++) {
              const div = textDivs[n];
              div.textContent = textContentItemsStr[n];
              div.className = "";
            }
            clearedUntilDivIdx = match.end.divIdx + 1;
          }
          if (!(findController !== null && findController !== void 0 && findController.highlightMatches)) {
            return;
          }
          const pageMatches = findController.pageMatches[pageIdx] || null;
          const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;
          this.matches = this._convertMatches(pageMatches, pageMatchesLength);
          this._renderMatches(this.matches);
        }
      }
      exports.TextHighlighter = TextHighlighter;

      /***/
    }), ( /* 16 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DownloadManager = void 0;
      var _pdfjsLib = __w_pdfjs_require__(3);
      ;
      function download(blobUrl, filename) {
        const a = document.createElement("a");
        if (!a.click) {
          throw new Error('DownloadManager: "a.click()" is not supported.');
        }
        a.href = blobUrl;
        a.target = "_parent";
        if ("download" in a) {
          a.download = filename;
        }
        (document.body || document.documentElement).appendChild(a);
        a.click();
        a.remove();
      }
      class DownloadManager {
        constructor() {
          this._openBlobUrls = new WeakMap();
        }
        downloadUrl(url, filename) {
          if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, "http://example.com")) {
            console.error(`downloadUrl - not a valid URL: ${url}`);
            return;
          }
          download(url + "#pdfjs.action=download", filename);
        }
        downloadData(data, filename, contentType) {
          const blobUrl = URL.createObjectURL(new Blob([data], {
            type: contentType
          }));
          download(blobUrl, filename);
        }
        openOrDownloadData(element, data, filename) {
          const isPdfData = (0, _pdfjsLib.isPdfFile)(filename);
          const contentType = isPdfData ? "application/pdf" : "";
          if (isPdfData) {
            let blobUrl = this._openBlobUrls.get(element);
            if (!blobUrl) {
              blobUrl = URL.createObjectURL(new Blob([data], {
                type: contentType
              }));
              this._openBlobUrls.set(element, blobUrl);
            }
            let viewerUrl;
            viewerUrl = "?file=" + encodeURIComponent(blobUrl + "#" + filename);
            try {
              window.open(viewerUrl);
              return true;
            } catch (ex) {
              console.error(`openOrDownloadData: ${ex}`);
              URL.revokeObjectURL(blobUrl);
              this._openBlobUrls.delete(element);
            }
          }
          this.downloadData(data, filename, contentType);
          return false;
        }
        download(blob, url, filename, sourceEventType = "download") {
          const blobUrl = URL.createObjectURL(blob);
          download(blobUrl, filename);
        }
      }
      exports.DownloadManager = DownloadManager;

      /***/
    }), ( /* 17 */
    /***/(__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.WaitOnType = exports.EventBus = exports.AutomationEventBus = void 0;
      exports.waitOnEventOrTimeout = waitOnEventOrTimeout;
      const WaitOnType = {
        EVENT: "event",
        TIMEOUT: "timeout"
      };
      exports.WaitOnType = WaitOnType;
      function waitOnEventOrTimeout({
        target,
        name,
        delay = 0
      }) {
        return new Promise(function (resolve, reject) {
          if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
            throw new Error("waitOnEventOrTimeout - invalid parameters.");
          }
          function handler(type) {
            if (target instanceof EventBus) {
              target._off(name, eventHandler);
            } else {
              target.removeEventListener(name, eventHandler);
            }
            if (timeout) {
              clearTimeout(timeout);
            }
            resolve(type);
          }
          const eventHandler = handler.bind(null, WaitOnType.EVENT);
          if (target instanceof EventBus) {
            target._on(name, eventHandler);
          } else {
            target.addEventListener(name, eventHandler);
          }
          const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
          const timeout = setTimeout(timeoutHandler, delay);
        });
      }
      class EventBus {
        constructor() {
          this._listeners = Object.create(null);
        }
        on(eventName, listener, options = null) {
          this._on(eventName, listener, {
            external: true,
            once: options === null || options === void 0 ? void 0 : options.once
          });
        }
        off(eventName, listener, options = null) {
          this._off(eventName, listener, {
            external: true,
            once: options === null || options === void 0 ? void 0 : options.once
          });
        }
        dispatch(eventName, data) {
          const eventListeners = this._listeners[eventName];
          if (!eventListeners || eventListeners.length === 0) {
            return;
          }
          let externalListeners;
          for (const {
            listener,
            external,
            once
          } of eventListeners.slice(0)) {
            if (once) {
              this._off(eventName, listener);
            }
            if (external) {
              (externalListeners || (externalListeners = [])).push(listener);
              continue;
            }
            listener(data);
          }
          if (externalListeners) {
            for (const listener of externalListeners) {
              listener(data);
            }
            externalListeners = null;
          }
        }
        _on(eventName, listener, options = null) {
          var _this$_listeners;
          const eventListeners = (_this$_listeners = this._listeners)[eventName] || (_this$_listeners[eventName] = []);
          eventListeners.push({
            listener,
            external: (options === null || options === void 0 ? void 0 : options.external) === true,
            once: (options === null || options === void 0 ? void 0 : options.once) === true
          });
        }
        _off(eventName, listener, options = null) {
          const eventListeners = this._listeners[eventName];
          if (!eventListeners) {
            return;
          }
          for (let i = 0, ii = eventListeners.length; i < ii; i++) {
            if (eventListeners[i].listener === listener) {
              eventListeners.splice(i, 1);
              return;
            }
          }
        }
      }
      exports.EventBus = EventBus;
      class AutomationEventBus extends EventBus {
        dispatch(eventName, data) {
          throw new Error("Not implemented: AutomationEventBus.dispatch");
        }
      }
      exports.AutomationEventBus = AutomationEventBus;

      /***/
    }), ( /* 18 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GenericL10n = void 0;
      __w_pdfjs_require__(19);
      var _l10n_utils = __w_pdfjs_require__(4);
      const webL10n = document.webL10n;
      class GenericL10n {
        constructor(lang) {
          this._lang = lang;
          this._ready = new Promise((resolve, reject) => {
            webL10n.setLanguage((0, _l10n_utils.fixupLangCode)(lang), () => {
              resolve(webL10n);
            });
          });
        }
        getLanguage() {
          var _this8 = this;
          return _asyncToGenerator(function* () {
            const l10n = yield _this8._ready;
            return l10n.getLanguage();
          })();
        }
        getDirection() {
          var _this9 = this;
          return _asyncToGenerator(function* () {
            const l10n = yield _this9._ready;
            return l10n.getDirection();
          })();
        }
        get(key, args = null, fallback = (0, _l10n_utils.getL10nFallback)(key, args)) {
          var _this10 = this;
          return _asyncToGenerator(function* () {
            const l10n = yield _this10._ready;
            return l10n.get(key, args, fallback);
          })();
        }
        translate(element) {
          var _this11 = this;
          return _asyncToGenerator(function* () {
            const l10n = yield _this11._ready;
            return l10n.translate(element);
          })();
        }
      }
      exports.GenericL10n = GenericL10n;

      /***/
    }), ( /* 19 */
    /***/() => {
      document.webL10n = function (window, document, undefined) {
        var gL10nData = {};
        var gTextData = '';
        var gTextProp = 'textContent';
        var gLanguage = '';
        var gMacros = {};
        var gReadyState = 'loading';
        var gAsyncResourceLoading = true;
        function getL10nResourceLinks() {
          return document.querySelectorAll('link[type="application/l10n"]');
        }
        function getL10nDictionary() {
          var script = document.querySelector('script[type="application/l10n"]');
          return script ? JSON.parse(script.innerHTML) : null;
        }
        function getTranslatableChildren(element) {
          return element ? element.querySelectorAll('*[data-l10n-id]') : [];
        }
        function getL10nAttributes(element) {
          if (!element) return {};
          var l10nId = element.getAttribute('data-l10n-id');
          var l10nArgs = element.getAttribute('data-l10n-args');
          var args = {};
          if (l10nArgs) {
            try {
              args = JSON.parse(l10nArgs);
            } catch (e) {
              console.warn('could not parse arguments for #' + l10nId);
            }
          }
          return {
            id: l10nId,
            args: args
          };
        }
        function xhrLoadText(url, onSuccess, onFailure) {
          onSuccess = onSuccess || function _onSuccess(data) {};
          onFailure = onFailure || function _onFailure() {};
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, gAsyncResourceLoading);
          if (xhr.overrideMimeType) {
            xhr.overrideMimeType('text/plain; charset=utf-8');
          }
          xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) {
              if (xhr.status == 200 || xhr.status === 0) {
                onSuccess(xhr.responseText);
              } else {
                onFailure();
              }
            }
          };
          xhr.onerror = onFailure;
          xhr.ontimeout = onFailure;
          try {
            xhr.send(null);
          } catch (e) {
            onFailure();
          }
        }
        function parseResource(href, lang, successCallback, failureCallback) {
          var baseURL = href.replace(/[^\/]*$/, '') || './';
          function evalString(text) {
            if (text.lastIndexOf('\\') < 0) return text;
            return text.replace(/\\\\/g, '\\').replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\b/g, '\b').replace(/\\f/g, '\f').replace(/\\{/g, '{').replace(/\\}/g, '}').replace(/\\"/g, '"').replace(/\\'/g, "'");
          }
          function parseProperties(text, parsedPropertiesCallback) {
            var dictionary = {};
            var reBlank = /^\s*|\s*$/;
            var reComment = /^\s*#|^\s*$/;
            var reSection = /^\s*\[(.*)\]\s*$/;
            var reImport = /^\s*@import\s+url\((.*)\)\s*$/i;
            var reSplit = /^([^=\s]*)\s*=\s*(.+)$/;
            function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) {
              var entries = rawText.replace(reBlank, '').split(/[\r\n]+/);
              var currentLang = '*';
              var genericLang = lang.split('-', 1)[0];
              var skipLang = false;
              var match = '';
              function nextEntry() {
                while (true) {
                  if (!entries.length) {
                    parsedRawLinesCallback();
                    return;
                  }
                  var line = entries.shift();
                  if (reComment.test(line)) continue;
                  if (extendedSyntax) {
                    match = reSection.exec(line);
                    if (match) {
                      currentLang = match[1].toLowerCase();
                      skipLang = currentLang !== '*' && currentLang !== lang && currentLang !== genericLang;
                      continue;
                    } else if (skipLang) {
                      continue;
                    }
                    match = reImport.exec(line);
                    if (match) {
                      loadImport(baseURL + match[1], nextEntry);
                      return;
                    }
                  }
                  var tmp = line.match(reSplit);
                  if (tmp && tmp.length == 3) {
                    dictionary[tmp[1]] = evalString(tmp[2]);
                  }
                }
              }
              nextEntry();
            }
            function loadImport(url, callback) {
              xhrLoadText(url, function (content) {
                parseRawLines(content, false, callback);
              }, function () {
                console.warn(url + ' not found.');
                callback();
              });
            }
            parseRawLines(text, true, function () {
              parsedPropertiesCallback(dictionary);
            });
          }
          xhrLoadText(href, function (response) {
            gTextData += response;
            parseProperties(response, function (data) {
              for (var key in data) {
                var id,
                  prop,
                  index = key.lastIndexOf('.');
                if (index > 0) {
                  id = key.substring(0, index);
                  prop = key.substring(index + 1);
                } else {
                  id = key;
                  prop = gTextProp;
                }
                if (!gL10nData[id]) {
                  gL10nData[id] = {};
                }
                gL10nData[id][prop] = data[key];
              }
              if (successCallback) {
                successCallback();
              }
            });
          }, failureCallback);
        }
        function loadLocale(lang, callback) {
          if (lang) {
            lang = lang.toLowerCase();
          }
          callback = callback || function _callback() {};
          clear();
          gLanguage = lang;
          var langLinks = getL10nResourceLinks();
          var langCount = langLinks.length;
          if (langCount === 0) {
            var dict = getL10nDictionary();
            if (dict && dict.locales && dict.default_locale) {
              console.log('using the embedded JSON directory, early way out');
              gL10nData = dict.locales[lang];
              if (!gL10nData) {
                var defaultLocale = dict.default_locale.toLowerCase();
                for (var anyCaseLang in dict.locales) {
                  anyCaseLang = anyCaseLang.toLowerCase();
                  if (anyCaseLang === lang) {
                    gL10nData = dict.locales[lang];
                    break;
                  } else if (anyCaseLang === defaultLocale) {
                    gL10nData = dict.locales[defaultLocale];
                  }
                }
              }
              callback();
            } else {
              console.log('no resource to load, early way out');
            }
            gReadyState = 'complete';
            return;
          }
          var onResourceLoaded = null;
          var gResourceCount = 0;
          onResourceLoaded = function () {
            gResourceCount++;
            if (gResourceCount >= langCount) {
              callback();
              gReadyState = 'complete';
            }
          };
          function L10nResourceLink(link) {
            var href = link.href;
            this.load = function (lang, callback) {
              parseResource(href, lang, callback, function () {
                console.warn(href + ' not found.');
                console.warn('"' + lang + '" resource not found');
                gLanguage = '';
                callback();
              });
            };
          }
          for (var i = 0; i < langCount; i++) {
            var resource = new L10nResourceLink(langLinks[i]);
            resource.load(lang, onResourceLoaded);
          }
        }
        function clear() {
          gL10nData = {};
          gTextData = '';
          gLanguage = '';
        }
        function getPluralRules(lang) {
          var locales2rules = {
            'af': 3,
            'ak': 4,
            'am': 4,
            'ar': 1,
            'asa': 3,
            'az': 0,
            'be': 11,
            'bem': 3,
            'bez': 3,
            'bg': 3,
            'bh': 4,
            'bm': 0,
            'bn': 3,
            'bo': 0,
            'br': 20,
            'brx': 3,
            'bs': 11,
            'ca': 3,
            'cgg': 3,
            'chr': 3,
            'cs': 12,
            'cy': 17,
            'da': 3,
            'de': 3,
            'dv': 3,
            'dz': 0,
            'ee': 3,
            'el': 3,
            'en': 3,
            'eo': 3,
            'es': 3,
            'et': 3,
            'eu': 3,
            'fa': 0,
            'ff': 5,
            'fi': 3,
            'fil': 4,
            'fo': 3,
            'fr': 5,
            'fur': 3,
            'fy': 3,
            'ga': 8,
            'gd': 24,
            'gl': 3,
            'gsw': 3,
            'gu': 3,
            'guw': 4,
            'gv': 23,
            'ha': 3,
            'haw': 3,
            'he': 2,
            'hi': 4,
            'hr': 11,
            'hu': 0,
            'id': 0,
            'ig': 0,
            'ii': 0,
            'is': 3,
            'it': 3,
            'iu': 7,
            'ja': 0,
            'jmc': 3,
            'jv': 0,
            'ka': 0,
            'kab': 5,
            'kaj': 3,
            'kcg': 3,
            'kde': 0,
            'kea': 0,
            'kk': 3,
            'kl': 3,
            'km': 0,
            'kn': 0,
            'ko': 0,
            'ksb': 3,
            'ksh': 21,
            'ku': 3,
            'kw': 7,
            'lag': 18,
            'lb': 3,
            'lg': 3,
            'ln': 4,
            'lo': 0,
            'lt': 10,
            'lv': 6,
            'mas': 3,
            'mg': 4,
            'mk': 16,
            'ml': 3,
            'mn': 3,
            'mo': 9,
            'mr': 3,
            'ms': 0,
            'mt': 15,
            'my': 0,
            'nah': 3,
            'naq': 7,
            'nb': 3,
            'nd': 3,
            'ne': 3,
            'nl': 3,
            'nn': 3,
            'no': 3,
            'nr': 3,
            'nso': 4,
            'ny': 3,
            'nyn': 3,
            'om': 3,
            'or': 3,
            'pa': 3,
            'pap': 3,
            'pl': 13,
            'ps': 3,
            'pt': 3,
            'rm': 3,
            'ro': 9,
            'rof': 3,
            'ru': 11,
            'rwk': 3,
            'sah': 0,
            'saq': 3,
            'se': 7,
            'seh': 3,
            'ses': 0,
            'sg': 0,
            'sh': 11,
            'shi': 19,
            'sk': 12,
            'sl': 14,
            'sma': 7,
            'smi': 7,
            'smj': 7,
            'smn': 7,
            'sms': 7,
            'sn': 3,
            'so': 3,
            'sq': 3,
            'sr': 11,
            'ss': 3,
            'ssy': 3,
            'st': 3,
            'sv': 3,
            'sw': 3,
            'syr': 3,
            'ta': 3,
            'te': 3,
            'teo': 3,
            'th': 0,
            'ti': 4,
            'tig': 3,
            'tk': 3,
            'tl': 4,
            'tn': 3,
            'to': 0,
            'tr': 0,
            'ts': 3,
            'tzm': 22,
            'uk': 11,
            'ur': 3,
            've': 3,
            'vi': 0,
            'vun': 3,
            'wa': 4,
            'wae': 3,
            'wo': 0,
            'xh': 3,
            'xog': 3,
            'yo': 0,
            'zh': 0,
            'zu': 3
          };
          function isIn(n, list) {
            return list.indexOf(n) !== -1;
          }
          function isBetween(n, start, end) {
            return start <= n && n <= end;
          }
          var pluralRules = {
            '0': function (n) {
              return 'other';
            },
            '1': function (n) {
              if (isBetween(n % 100, 3, 10)) return 'few';
              if (n === 0) return 'zero';
              if (isBetween(n % 100, 11, 99)) return 'many';
              if (n == 2) return 'two';
              if (n == 1) return 'one';
              return 'other';
            },
            '2': function (n) {
              if (n !== 0 && n % 10 === 0) return 'many';
              if (n == 2) return 'two';
              if (n == 1) return 'one';
              return 'other';
            },
            '3': function (n) {
              if (n == 1) return 'one';
              return 'other';
            },
            '4': function (n) {
              if (isBetween(n, 0, 1)) return 'one';
              return 'other';
            },
            '5': function (n) {
              if (isBetween(n, 0, 2) && n != 2) return 'one';
              return 'other';
            },
            '6': function (n) {
              if (n === 0) return 'zero';
              if (n % 10 == 1 && n % 100 != 11) return 'one';
              return 'other';
            },
            '7': function (n) {
              if (n == 2) return 'two';
              if (n == 1) return 'one';
              return 'other';
            },
            '8': function (n) {
              if (isBetween(n, 3, 6)) return 'few';
              if (isBetween(n, 7, 10)) return 'many';
              if (n == 2) return 'two';
              if (n == 1) return 'one';
              return 'other';
            },
            '9': function (n) {
              if (n === 0 || n != 1 && isBetween(n % 100, 1, 19)) return 'few';
              if (n == 1) return 'one';
              return 'other';
            },
            '10': function (n) {
              if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19)) return 'few';
              if (n % 10 == 1 && !isBetween(n % 100, 11, 19)) return 'one';
              return 'other';
            },
            '11': function (n) {
              if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
              if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14)) return 'many';
              if (n % 10 == 1 && n % 100 != 11) return 'one';
              return 'other';
            },
            '12': function (n) {
              if (isBetween(n, 2, 4)) return 'few';
              if (n == 1) return 'one';
              return 'other';
            },
            '13': function (n) {
              if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
              if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14)) return 'many';
              if (n == 1) return 'one';
              return 'other';
            },
            '14': function (n) {
              if (isBetween(n % 100, 3, 4)) return 'few';
              if (n % 100 == 2) return 'two';
              if (n % 100 == 1) return 'one';
              return 'other';
            },
            '15': function (n) {
              if (n === 0 || isBetween(n % 100, 2, 10)) return 'few';
              if (isBetween(n % 100, 11, 19)) return 'many';
              if (n == 1) return 'one';
              return 'other';
            },
            '16': function (n) {
              if (n % 10 == 1 && n != 11) return 'one';
              return 'other';
            },
            '17': function (n) {
              if (n == 3) return 'few';
              if (n === 0) return 'zero';
              if (n == 6) return 'many';
              if (n == 2) return 'two';
              if (n == 1) return 'one';
              return 'other';
            },
            '18': function (n) {
              if (n === 0) return 'zero';
              if (isBetween(n, 0, 2) && n !== 0 && n != 2) return 'one';
              return 'other';
            },
            '19': function (n) {
              if (isBetween(n, 2, 10)) return 'few';
              if (isBetween(n, 0, 1)) return 'one';
              return 'other';
            },
            '20': function (n) {
              if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99))) return 'few';
              if (n % 1000000 === 0 && n !== 0) return 'many';
              if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92])) return 'two';
              if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91])) return 'one';
              return 'other';
            },
            '21': function (n) {
              if (n === 0) return 'zero';
              if (n == 1) return 'one';
              return 'other';
            },
            '22': function (n) {
              if (isBetween(n, 0, 1) || isBetween(n, 11, 99)) return 'one';
              return 'other';
            },
            '23': function (n) {
              if (isBetween(n % 10, 1, 2) || n % 20 === 0) return 'one';
              return 'other';
            },
            '24': function (n) {
              if (isBetween(n, 3, 10) || isBetween(n, 13, 19)) return 'few';
              if (isIn(n, [2, 12])) return 'two';
              if (isIn(n, [1, 11])) return 'one';
              return 'other';
            }
          };
          var index = locales2rules[lang.replace(/-.*$/, '')];
          if (!(index in pluralRules)) {
            console.warn('plural form unknown for [' + lang + ']');
            return function () {
              return 'other';
            };
          }
          return pluralRules[index];
        }
        gMacros.plural = function (str, param, key, prop) {
          var n = parseFloat(param);
          if (isNaN(n)) return str;
          if (prop != gTextProp) return str;
          if (!gMacros._pluralRules) {
            gMacros._pluralRules = getPluralRules(gLanguage);
          }
          var index = '[' + gMacros._pluralRules(n) + ']';
          if (n === 0 && key + '[zero]' in gL10nData) {
            str = gL10nData[key + '[zero]'][prop];
          } else if (n == 1 && key + '[one]' in gL10nData) {
            str = gL10nData[key + '[one]'][prop];
          } else if (n == 2 && key + '[two]' in gL10nData) {
            str = gL10nData[key + '[two]'][prop];
          } else if (key + index in gL10nData) {
            str = gL10nData[key + index][prop];
          } else if (key + '[other]' in gL10nData) {
            str = gL10nData[key + '[other]'][prop];
          }
          return str;
        };
        function getL10nData(key, args, fallback) {
          var data = gL10nData[key];
          if (!data) {
            console.warn('#' + key + ' is undefined.');
            if (!fallback) {
              return null;
            }
            data = fallback;
          }
          var rv = {};
          for (var prop in data) {
            var str = data[prop];
            str = substIndexes(str, args, key, prop);
            str = substArguments(str, args, key);
            rv[prop] = str;
          }
          return rv;
        }
        function substIndexes(str, args, key, prop) {
          var reIndex = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/;
          var reMatch = reIndex.exec(str);
          if (!reMatch || !reMatch.length) return str;
          var macroName = reMatch[1];
          var paramName = reMatch[2];
          var param;
          if (args && paramName in args) {
            param = args[paramName];
          } else if (paramName in gL10nData) {
            param = gL10nData[paramName];
          }
          if (macroName in gMacros) {
            var macro = gMacros[macroName];
            str = macro(str, param, key, prop);
          }
          return str;
        }
        function substArguments(str, args, key) {
          var reArgs = /\{\{\s*(.+?)\s*\}\}/g;
          return str.replace(reArgs, function (matched_text, arg) {
            if (args && arg in args) {
              return args[arg];
            }
            if (arg in gL10nData) {
              return gL10nData[arg];
            }
            console.log('argument {{' + arg + '}} for #' + key + ' is undefined.');
            return matched_text;
          });
        }
        function translateElement(element) {
          var l10n = getL10nAttributes(element);
          if (!l10n.id) return;
          var data = getL10nData(l10n.id, l10n.args);
          if (!data) {
            console.warn('#' + l10n.id + ' is undefined.');
            return;
          }
          if (data[gTextProp]) {
            if (getChildElementCount(element) === 0) {
              element[gTextProp] = data[gTextProp];
            } else {
              var children = element.childNodes;
              var found = false;
              for (var i = 0, l = children.length; i < l; i++) {
                if (children[i].nodeType === 3 && /\S/.test(children[i].nodeValue)) {
                  if (found) {
                    children[i].nodeValue = '';
                  } else {
                    children[i].nodeValue = data[gTextProp];
                    found = true;
                  }
                }
              }
              if (!found) {
                var textNode = document.createTextNode(data[gTextProp]);
                element.insertBefore(textNode, element.firstChild);
              }
            }
            delete data[gTextProp];
          }
          for (var k in data) {
            element[k] = data[k];
          }
        }
        function getChildElementCount(element) {
          if (element.children) {
            return element.children.length;
          }
          if (typeof element.childElementCount !== 'undefined') {
            return element.childElementCount;
          }
          var count = 0;
          for (var i = 0; i < element.childNodes.length; i++) {
            count += element.nodeType === 1 ? 1 : 0;
          }
          return count;
        }
        function translateFragment(element) {
          element = element || document.documentElement;
          var children = getTranslatableChildren(element);
          var elementCount = children.length;
          for (var i = 0; i < elementCount; i++) {
            translateElement(children[i]);
          }
          translateElement(element);
        }
        return {
          get: function (key, args, fallbackString) {
            var index = key.lastIndexOf('.');
            var prop = gTextProp;
            if (index > 0) {
              prop = key.substring(index + 1);
              key = key.substring(0, index);
            }
            var fallback;
            if (fallbackString) {
              fallback = {};
              fallback[prop] = fallbackString;
            }
            var data = getL10nData(key, args, fallback);
            if (data && prop in data) {
              return data[prop];
            }
            return '{{' + key + '}}';
          },
          getData: function () {
            return gL10nData;
          },
          getText: function () {
            return gTextData;
          },
          getLanguage: function () {
            return gLanguage;
          },
          setLanguage: function (lang, callback) {
            loadLocale(lang, function () {
              if (callback) callback();
            });
          },
          getDirection: function () {
            var rtlList = ['ar', 'he', 'fa', 'ps', 'ur'];
            var shortCode = gLanguage.split('-', 1)[0];
            return rtlList.indexOf(shortCode) >= 0 ? 'rtl' : 'ltr';
          },
          translate: translateFragment,
          getReadyState: function () {
            return gReadyState;
          },
          ready: function (callback) {
            if (!callback) {
              return;
            } else if (gReadyState == 'complete' || gReadyState == 'interactive') {
              window.setTimeout(function () {
                callback();
              });
            } else if (document.addEventListener) {
              document.addEventListener('localized', function once() {
                document.removeEventListener('localized', once);
                callback();
              });
            }
          }
        };
      }(window, document);

      /***/
    }), ( /* 20 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFFindController = exports.FindState = void 0;
      var _ui_utils = __w_pdfjs_require__(6);
      var _pdfjsLib = __w_pdfjs_require__(3);
      var _pdf_find_utils = __w_pdfjs_require__(21);
      const FindState = {
        FOUND: 0,
        NOT_FOUND: 1,
        WRAPPED: 2,
        PENDING: 3
      };
      exports.FindState = FindState;
      const FIND_TIMEOUT = 250;
      const MATCH_SCROLL_OFFSET_TOP = -50;
      const MATCH_SCROLL_OFFSET_LEFT = -400;
      const CHARACTERS_TO_NORMALIZE = {
        "\u2010": "-",
        "\u2018": "'",
        "\u2019": "'",
        "\u201A": "'",
        "\u201B": "'",
        "\u201C": '"',
        "\u201D": '"',
        "\u201E": '"',
        "\u201F": '"',
        "\u00BC": "1/4",
        "\u00BD": "1/2",
        "\u00BE": "3/4"
      };
      const DIACRITICS_EXCEPTION = new Set([0x3099, 0x309a, 0x094d, 0x09cd, 0x0a4d, 0x0acd, 0x0b4d, 0x0bcd, 0x0c4d, 0x0ccd, 0x0d3b, 0x0d3c, 0x0d4d, 0x0dca, 0x0e3a, 0x0eba, 0x0f84, 0x1039, 0x103a, 0x1714, 0x1734, 0x17d2, 0x1a60, 0x1b44, 0x1baa, 0x1bab, 0x1bf2, 0x1bf3, 0x2d7f, 0xa806, 0xa82c, 0xa8c4, 0xa953, 0xa9c0, 0xaaf6, 0xabed, 0x0c56, 0x0f71, 0x0f72, 0x0f7a, 0x0f7b, 0x0f7c, 0x0f7d, 0x0f80, 0x0f74]);
      const DIACRITICS_EXCEPTION_STR = [...DIACRITICS_EXCEPTION.values()].map(x => String.fromCharCode(x)).join("");
      const DIACRITICS_REG_EXP = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]+/gu;
      const SPECIAL_CHARS_REG_EXP = /([.*+?^${}()|[\]\\])|([!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65\u{10100}-\u{10102}\u{1039F}\u{103D0}\u{1056F}\u{10857}\u{1091F}\u{1093F}\u{10A50}-\u{10A58}\u{10A7F}\u{10AF0}-\u{10AF6}\u{10B39}-\u{10B3F}\u{10B99}-\u{10B9C}\u{10EAD}\u{10F55}-\u{10F59}\u{10F86}-\u{10F89}\u{11047}-\u{1104D}\u{110BB}\u{110BC}\u{110BE}-\u{110C1}\u{11140}-\u{11143}\u{11174}\u{11175}\u{111C5}-\u{111C8}\u{111CD}\u{111DB}\u{111DD}-\u{111DF}\u{11238}-\u{1123D}\u{112A9}\u{1144B}-\u{1144F}\u{1145A}\u{1145B}\u{1145D}\u{114C6}\u{115C1}-\u{115D7}\u{11641}-\u{11643}\u{11660}-\u{1166C}\u{116B9}\u{1173C}-\u{1173E}\u{1183B}\u{11944}-\u{11946}\u{119E2}\u{11A3F}-\u{11A46}\u{11A9A}-\u{11A9C}\u{11A9E}-\u{11AA2}\u{11B00}-\u{11B09}\u{11C41}-\u{11C45}\u{11C70}\u{11C71}\u{11EF7}\u{11EF8}\u{11F43}-\u{11F4F}\u{11FFF}\u{12470}-\u{12474}\u{12FF1}\u{12FF2}\u{16A6E}\u{16A6F}\u{16AF5}\u{16B37}-\u{16B3B}\u{16B44}\u{16E97}-\u{16E9A}\u{16FE2}\u{1BC9F}\u{1DA87}-\u{1DA8B}\u{1E95E}\u{1E95F}])|(\s+)|([\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}])|([A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{1031F}\u{1032D}-\u{10340}\u{10342}-\u{10349}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{103A0}-\u{103C3}\u{103C8}-\u{103CF}\u{10400}-\u{1049D}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{10570}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10860}-\u{10876}\u{10880}-\u{1089E}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{10900}-\u{10915}\u{10920}-\u{10939}\u{10980}-\u{109B7}\u{109BE}\u{109BF}\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A60}-\u{10A7C}\u{10A80}-\u{10A9C}\u{10AC0}-\u{10AC7}\u{10AC9}-\u{10AE4}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B60}-\u{10B72}\u{10B80}-\u{10B91}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10D00}-\u{10D23}\u{10E80}-\u{10EA9}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F1C}\u{10F27}\u{10F30}-\u{10F45}\u{10F70}-\u{10F81}\u{10FB0}-\u{10FC4}\u{10FE0}-\u{10FF6}\u{11003}-\u{11037}\u{11071}\u{11072}\u{11075}\u{11083}-\u{110AF}\u{110D0}-\u{110E8}\u{11103}-\u{11126}\u{11144}\u{11147}\u{11150}-\u{11172}\u{11176}\u{11183}-\u{111B2}\u{111C1}-\u{111C4}\u{111DA}\u{111DC}\u{11200}-\u{11211}\u{11213}-\u{1122B}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A8}\u{112B0}-\u{112DE}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}\u{11350}\u{1135D}-\u{11361}\u{11400}-\u{11434}\u{11447}-\u{1144A}\u{1145F}-\u{11461}\u{11480}-\u{114AF}\u{114C4}\u{114C5}\u{114C7}\u{11580}-\u{115AE}\u{115D8}-\u{115DB}\u{11600}-\u{1162F}\u{11644}\u{11680}-\u{116AA}\u{116B8}\u{11700}-\u{1171A}\u{11740}-\u{11746}\u{11800}-\u{1182B}\u{118A0}-\u{118DF}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{1192F}\u{1193F}\u{11941}\u{119A0}-\u{119A7}\u{119AA}-\u{119D0}\u{119E1}\u{119E3}\u{11A00}\u{11A0B}-\u{11A32}\u{11A3A}\u{11A50}\u{11A5C}-\u{11A89}\u{11A9D}\u{11AB0}-\u{11AF8}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2E}\u{11C40}\u{11C72}-\u{11C8F}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D89}\u{11D98}\u{11EE0}-\u{11EF2}\u{11F02}\u{11F04}-\u{11F10}\u{11F12}-\u{11F33}\u{11FB0}\u{12000}-\u{12399}\u{12480}-\u{12543}\u{12F90}-\u{12FF0}\u{13000}-\u{1342F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A70}-\u{16ABE}\u{16AD0}-\u{16AED}\u{16B00}-\u{16B2F}\u{16B40}-\u{16B43}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E7F}\u{16F00}-\u{16F4A}\u{16F50}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E14E}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E4D0}-\u{1E4EB}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E800}-\u{1E8C4}\u{1E900}-\u{1E943}\u{1E94B}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}])/gu;
      const NOT_DIACRITIC_FROM_END_REG_EXP = /([^\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}])[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
      const NOT_DIACRITIC_FROM_START_REG_EXP = /^[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*([^\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}])/u;
      let normalizationRegex = null;
      function normalize(text) {
        if (!normalizationRegex) {
          const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join("");
          normalizationRegex = new RegExp(`([${replace}])|(\\p{M}+(?:-\\n)?)|(\\S-\\n)|(\\n)`, "gum");
        }
        const rawDiacriticsPositions = [];
        let m;
        while ((m = DIACRITICS_REG_EXP.exec(text)) !== null) {
          rawDiacriticsPositions.push([m[0].length, m.index]);
        }
        let normalized = text.normalize("NFD");
        const positions = [[0, 0]];
        let k = 0;
        let shift = 0;
        let shiftOrigin = 0;
        let eol = 0;
        let hasDiacritics = false;
        normalized = normalized.replace(normalizationRegex, (match, p1, p2, p3, p4, i) => {
          i -= shiftOrigin;
          if (p1) {
            const replacement = CHARACTERS_TO_NORMALIZE[match];
            const jj = replacement.length;
            for (let j = 1; j < jj; j++) {
              positions.push([i - shift + j, shift - j]);
            }
            shift -= jj - 1;
            return replacement;
          }
          if (p2) {
            var _rawDiacriticsPositio;
            const hasTrailingDashEOL = p2.endsWith("\n");
            const len = hasTrailingDashEOL ? p2.length - 2 : p2.length;
            hasDiacritics = true;
            let jj = len;
            if (i + eol === ((_rawDiacriticsPositio = rawDiacriticsPositions[k]) === null || _rawDiacriticsPositio === void 0 ? void 0 : _rawDiacriticsPositio[1])) {
              jj -= rawDiacriticsPositions[k][0];
              ++k;
            }
            for (let j = 1; j < jj + 1; j++) {
              positions.push([i - 1 - shift + j, shift - j]);
            }
            shift -= jj;
            shiftOrigin += jj;
            if (hasTrailingDashEOL) {
              i += len - 1;
              positions.push([i - shift + 1, 1 + shift]);
              shift += 1;
              shiftOrigin += 1;
              eol += 1;
              return p2.slice(0, len);
            }
            return p2;
          }
          if (p3) {
            positions.push([i - shift + 1, 1 + shift]);
            shift += 1;
            shiftOrigin += 1;
            eol += 1;
            return p3.charAt(0);
          }
          positions.push([i - shift + 1, shift - 1]);
          shift -= 1;
          shiftOrigin += 1;
          eol += 1;
          return " ";
        });
        positions.push([normalized.length, shift]);
        return [normalized, positions, hasDiacritics];
      }
      function getOriginalIndex(diffs, pos, len) {
        if (!diffs) {
          return [pos, len];
        }
        const start = pos;
        const end = pos + len;
        let i = (0, _ui_utils.binarySearchFirstItem)(diffs, x => x[0] >= start);
        if (diffs[i][0] > start) {
          --i;
        }
        let j = (0, _ui_utils.binarySearchFirstItem)(diffs, x => x[0] >= end, i);
        if (diffs[j][0] > end) {
          --j;
        }
        return [start + diffs[i][1], len + diffs[j][1] - diffs[i][1]];
      }
      var _PDFFindController_brand = /*#__PURE__*/new WeakSet();
      class PDFFindController {
        constructor({
          linkService: _linkService,
          eventBus
        }) {
          _classPrivateMethodInitSpec(this, _PDFFindController_brand);
          this._linkService = _linkService;
          this._eventBus = eventBus;
          _assertClassBrand(_PDFFindController_brand, this, _reset).call(this);
          eventBus._on("find", _assertClassBrand(_PDFFindController_brand, this, _onFind).bind(this));
          eventBus._on("findbarclose", _assertClassBrand(_PDFFindController_brand, this, _onFindBarClose).bind(this));
        }
        get highlightMatches() {
          return this._highlightMatches;
        }
        get pageMatches() {
          return this._pageMatches;
        }
        get pageMatchesLength() {
          return this._pageMatchesLength;
        }
        get selected() {
          return this._selected;
        }
        get state() {
          return this._state;
        }
        setDocument(pdfDocument) {
          if (this._pdfDocument) {
            _assertClassBrand(_PDFFindController_brand, this, _reset).call(this);
          }
          if (!pdfDocument) {
            return;
          }
          this._pdfDocument = pdfDocument;
          this._firstPageCapability.resolve();
        }
        scrollMatchIntoView({
          element = null,
          selectedLeft = 0,
          pageIndex = -1,
          matchIndex = -1
        }) {
          if (!this._scrollMatches || !element) {
            return;
          } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {
            return;
          } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {
            return;
          }
          this._scrollMatches = false;
          const spot = {
            top: MATCH_SCROLL_OFFSET_TOP,
            left: selectedLeft + MATCH_SCROLL_OFFSET_LEFT
          };
          (0, _ui_utils.scrollIntoView)(element, spot, true);
        }
      }
      function _onFind(state) {
        if (!state) {
          return;
        }
        const pdfDocument = this._pdfDocument;
        const {
          type
        } = state;
        if (this._state === null || _assertClassBrand(_PDFFindController_brand, this, _shouldDirtyMatch).call(this, state)) {
          this._dirtyMatch = true;
        }
        this._state = state;
        if (type !== "highlightallchange") {
          _assertClassBrand(_PDFFindController_brand, this, _updateUIState).call(this, FindState.PENDING);
        }
        this._firstPageCapability.promise.then(() => {
          if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
            return;
          }
          _assertClassBrand(_PDFFindController_brand, this, _extractText).call(this);
          const findbarClosed = !this._highlightMatches;
          const pendingTimeout = !!this._findTimeout;
          if (this._findTimeout) {
            clearTimeout(this._findTimeout);
            this._findTimeout = null;
          }
          if (!type) {
            this._findTimeout = setTimeout(() => {
              _assertClassBrand(_PDFFindController_brand, this, _nextMatch).call(this);
              this._findTimeout = null;
            }, FIND_TIMEOUT);
          } else if (this._dirtyMatch) {
            _assertClassBrand(_PDFFindController_brand, this, _nextMatch).call(this);
          } else if (type === "again") {
            _assertClassBrand(_PDFFindController_brand, this, _nextMatch).call(this);
            if (findbarClosed && this._state.highlightAll) {
              _assertClassBrand(_PDFFindController_brand, this, _updateAllPages).call(this);
            }
          } else if (type === "highlightallchange") {
            if (pendingTimeout) {
              _assertClassBrand(_PDFFindController_brand, this, _nextMatch).call(this);
            } else {
              this._highlightMatches = true;
            }
            _assertClassBrand(_PDFFindController_brand, this, _updateAllPages).call(this);
          } else {
            _assertClassBrand(_PDFFindController_brand, this, _nextMatch).call(this);
          }
        });
      }
      function _reset() {
        this._highlightMatches = false;
        this._scrollMatches = false;
        this._pdfDocument = null;
        this._pageMatches = [];
        this._pageMatchesLength = [];
        this._state = null;
        this._selected = {
          pageIdx: -1,
          matchIdx: -1
        };
        this._offset = {
          pageIdx: null,
          matchIdx: null,
          wrapped: false
        };
        this._extractTextPromises = [];
        this._pageContents = [];
        this._pageDiffs = [];
        this._hasDiacritics = [];
        this._matchesCountTotal = 0;
        this._pagesToSearch = null;
        this._pendingFindMatches = new Set();
        this._resumePageIdx = null;
        this._dirtyMatch = false;
        clearTimeout(this._findTimeout);
        this._findTimeout = null;
        this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
      }
      function _get_query(_this12) {
        if (_this12._state.query !== _this12._rawQuery) {
          _this12._rawQuery = _this12._state.query;
          [_this12._normalizedQuery] = normalize(_this12._state.query);
        }
        return _this12._normalizedQuery;
      }
      function _shouldDirtyMatch(state) {
        if (state.query !== this._state.query) {
          return true;
        }
        switch (state.type) {
          case "again":
            const pageNumber = this._selected.pageIdx + 1;
            const linkService = this._linkService;
            if (pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !linkService.isPageVisible(pageNumber)) {
              return true;
            }
            return false;
          case "highlightallchange":
            return false;
        }
        return true;
      }
      function _isEntireWord(content, startIdx, length) {
        let match = content.slice(0, startIdx).match(NOT_DIACRITIC_FROM_END_REG_EXP);
        if (match) {
          const first = content.charCodeAt(startIdx);
          const limit = match[1].charCodeAt(0);
          if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) {
            return false;
          }
        }
        match = content.slice(startIdx + length).match(NOT_DIACRITIC_FROM_START_REG_EXP);
        if (match) {
          const last = content.charCodeAt(startIdx + length - 1);
          const limit = match[1].charCodeAt(0);
          if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(limit)) {
            return false;
          }
        }
        return true;
      }
      function _calculateRegExpMatch(query, entireWord, pageIndex, pageContent) {
        const matches = [],
          matchesLength = [];
        const diffs = this._pageDiffs[pageIndex];
        let match;
        while ((match = query.exec(pageContent)) !== null) {
          if (entireWord && !_assertClassBrand(_PDFFindController_brand, this, _isEntireWord).call(this, pageContent, match.index, match[0].length)) {
            continue;
          }
          const [matchPos, matchLen] = getOriginalIndex(diffs, match.index, match[0].length);
          if (matchLen) {
            matches.push(matchPos);
            matchesLength.push(matchLen);
          }
        }
        this._pageMatches[pageIndex] = matches;
        this._pageMatchesLength[pageIndex] = matchesLength;
      }
      function _convertToRegExpString(query, hasDiacritics) {
        const {
          matchDiacritics
        } = this._state;
        let isUnicode = false;
        query = query.replace(SPECIAL_CHARS_REG_EXP, (match, p1, p2, p3, p4, p5) => {
          if (p1) {
            return `[ ]*\\${p1}[ ]*`;
          }
          if (p2) {
            return `[ ]*${p2}[ ]*`;
          }
          if (p3) {
            return "[ ]+";
          }
          if (matchDiacritics) {
            return p4 || p5;
          }
          if (p4) {
            return DIACRITICS_EXCEPTION.has(p4.charCodeAt(0)) ? p4 : "";
          }
          if (hasDiacritics) {
            isUnicode = true;
            return `${p5}\\p{M}*`;
          }
          return p5;
        });
        const trailingSpaces = "[ ]*";
        if (query.endsWith(trailingSpaces)) {
          query = query.slice(0, query.length - trailingSpaces.length);
        }
        if (matchDiacritics) {
          if (hasDiacritics) {
            isUnicode = true;
            query = `${query}(?=[${DIACRITICS_EXCEPTION_STR}]|[^\\p{M}]|$)`;
          }
        }
        return [isUnicode, query];
      }
      function _calculateMatch(pageIndex) {
        let query = _classPrivateGetter(_PDFFindController_brand, this, _get_query);
        if (query.length === 0) {
          return;
        }
        const {
          caseSensitive,
          entireWord,
          phraseSearch
        } = this._state;
        const pageContent = this._pageContents[pageIndex];
        const hasDiacritics = this._hasDiacritics[pageIndex];
        let isUnicode = false;
        if (phraseSearch) {
          [isUnicode, query] = _assertClassBrand(_PDFFindController_brand, this, _convertToRegExpString).call(this, query, hasDiacritics);
        } else {
          const match = query.match(/\S+/g);
          if (match) {
            query = match.sort().reverse().map(q => {
              const [isUnicodePart, queryPart] = _assertClassBrand(_PDFFindController_brand, this, _convertToRegExpString).call(this, q, hasDiacritics);
              isUnicode || (isUnicode = isUnicodePart);
              return `(${queryPart})`;
            }).join("|");
          }
        }
        const flags = `g${isUnicode ? "u" : ""}${caseSensitive ? "" : "i"}`;
        query = new RegExp(query, flags);
        _assertClassBrand(_PDFFindController_brand, this, _calculateRegExpMatch).call(this, query, entireWord, pageIndex, pageContent);
        if (this._state.highlightAll) {
          _assertClassBrand(_PDFFindController_brand, this, _updatePage).call(this, pageIndex);
        }
        if (this._resumePageIdx === pageIndex) {
          this._resumePageIdx = null;
          _assertClassBrand(_PDFFindController_brand, this, _nextPageMatch).call(this);
        }
        const pageMatchesCount = this._pageMatches[pageIndex].length;
        if (pageMatchesCount > 0) {
          this._matchesCountTotal += pageMatchesCount;
          _assertClassBrand(_PDFFindController_brand, this, _updateUIResultsCount).call(this);
        }
      }
      function _extractText() {
        if (this._extractTextPromises.length > 0) {
          return;
        }
        let promise = Promise.resolve();
        for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) {
          const extractTextCapability = (0, _pdfjsLib.createPromiseCapability)();
          this._extractTextPromises[i] = extractTextCapability.promise;
          promise = promise.then(() => {
            return this._pdfDocument.getPage(i + 1).then(pdfPage => {
              return pdfPage.getTextContent();
            }).then(textContent => {
              const strBuf = [];
              for (const textItem of textContent.items) {
                strBuf.push(textItem.str);
                if (textItem.hasEOL) {
                  strBuf.push("\n");
                }
              }
              [this._pageContents[i], this._pageDiffs[i], this._hasDiacritics[i]] = normalize(strBuf.join(""));
              extractTextCapability.resolve();
            }, reason => {
              console.error(`Unable to get text content for page ${i + 1}`, reason);
              this._pageContents[i] = "";
              this._pageDiffs[i] = null;
              this._hasDiacritics[i] = false;
              extractTextCapability.resolve();
            });
          });
        }
      }
      function _updatePage(index) {
        if (this._scrollMatches && this._selected.pageIdx === index) {
          this._linkService.page = index + 1;
        }
        this._eventBus.dispatch("updatetextlayermatches", {
          source: this,
          pageIndex: index
        });
      }
      function _updateAllPages() {
        this._eventBus.dispatch("updatetextlayermatches", {
          source: this,
          pageIndex: -1
        });
      }
      function _nextMatch() {
        const previous = this._state.findPrevious;
        const currentPageIndex = this._linkService.page - 1;
        const numPages = this._linkService.pagesCount;
        this._highlightMatches = true;
        if (this._dirtyMatch) {
          this._dirtyMatch = false;
          this._selected.pageIdx = this._selected.matchIdx = -1;
          this._offset.pageIdx = currentPageIndex;
          this._offset.matchIdx = null;
          this._offset.wrapped = false;
          this._resumePageIdx = null;
          this._pageMatches.length = 0;
          this._pageMatchesLength.length = 0;
          this._matchesCountTotal = 0;
          _assertClassBrand(_PDFFindController_brand, this, _updateAllPages).call(this);
          for (let i = 0; i < numPages; i++) {
            if (this._pendingFindMatches.has(i)) {
              continue;
            }
            this._pendingFindMatches.add(i);
            this._extractTextPromises[i].then(() => {
              this._pendingFindMatches.delete(i);
              _assertClassBrand(_PDFFindController_brand, this, _calculateMatch).call(this, i);
            });
          }
        }
        if (_classPrivateGetter(_PDFFindController_brand, this, _get_query) === "") {
          _assertClassBrand(_PDFFindController_brand, this, _updateUIState).call(this, FindState.FOUND);
          return;
        }
        if (this._resumePageIdx) {
          return;
        }
        const offset = this._offset;
        this._pagesToSearch = numPages;
        if (offset.matchIdx !== null) {
          const numPageMatches = this._pageMatches[offset.pageIdx].length;
          if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) {
            offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;
            _assertClassBrand(_PDFFindController_brand, this, _updateMatch).call(this, true);
            return;
          }
          _assertClassBrand(_PDFFindController_brand, this, _advanceOffsetPage).call(this, previous);
        }
        _assertClassBrand(_PDFFindController_brand, this, _nextPageMatch).call(this);
      }
      function _matchesReady(matches) {
        const offset = this._offset;
        const numMatches = matches.length;
        const previous = this._state.findPrevious;
        if (numMatches) {
          offset.matchIdx = previous ? numMatches - 1 : 0;
          _assertClassBrand(_PDFFindController_brand, this, _updateMatch).call(this, true);
          return true;
        }
        _assertClassBrand(_PDFFindController_brand, this, _advanceOffsetPage).call(this, previous);
        if (offset.wrapped) {
          offset.matchIdx = null;
          if (this._pagesToSearch < 0) {
            _assertClassBrand(_PDFFindController_brand, this, _updateMatch).call(this, false);
            return true;
          }
        }
        return false;
      }
      function _nextPageMatch() {
        if (this._resumePageIdx !== null) {
          console.error("There can only be one pending page.");
        }
        let matches = null;
        do {
          const pageIdx = this._offset.pageIdx;
          matches = this._pageMatches[pageIdx];
          if (!matches) {
            this._resumePageIdx = pageIdx;
            break;
          }
        } while (!_assertClassBrand(_PDFFindController_brand, this, _matchesReady).call(this, matches));
      }
      function _advanceOffsetPage(previous) {
        const offset = this._offset;
        const numPages = this._linkService.pagesCount;
        offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;
        offset.matchIdx = null;
        this._pagesToSearch--;
        if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
          offset.pageIdx = previous ? numPages - 1 : 0;
          offset.wrapped = true;
        }
      }
      function _updateMatch(found = false) {
        let state = FindState.NOT_FOUND;
        const wrapped = this._offset.wrapped;
        this._offset.wrapped = false;
        if (found) {
          const previousPage = this._selected.pageIdx;
          this._selected.pageIdx = this._offset.pageIdx;
          this._selected.matchIdx = this._offset.matchIdx;
          state = wrapped ? FindState.WRAPPED : FindState.FOUND;
          if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {
            _assertClassBrand(_PDFFindController_brand, this, _updatePage).call(this, previousPage);
          }
        }
        _assertClassBrand(_PDFFindController_brand, this, _updateUIState).call(this, state, this._state.findPrevious);
        if (this._selected.pageIdx !== -1) {
          this._scrollMatches = true;
          _assertClassBrand(_PDFFindController_brand, this, _updatePage).call(this, this._selected.pageIdx);
        }
      }
      function _onFindBarClose(evt) {
        const pdfDocument = this._pdfDocument;
        this._firstPageCapability.promise.then(() => {
          if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
            return;
          }
          if (this._findTimeout) {
            clearTimeout(this._findTimeout);
            this._findTimeout = null;
          }
          if (this._resumePageIdx) {
            this._resumePageIdx = null;
            this._dirtyMatch = true;
          }
          _assertClassBrand(_PDFFindController_brand, this, _updateUIState).call(this, FindState.FOUND);
          this._highlightMatches = false;
          _assertClassBrand(_PDFFindController_brand, this, _updateAllPages).call(this);
        });
      }
      function _requestMatchesCount() {
        const {
          pageIdx,
          matchIdx
        } = this._selected;
        let current = 0,
          total = this._matchesCountTotal;
        if (matchIdx !== -1) {
          for (let i = 0; i < pageIdx; i++) {
            var _this$_pageMatches$i;
            current += ((_this$_pageMatches$i = this._pageMatches[i]) === null || _this$_pageMatches$i === void 0 ? void 0 : _this$_pageMatches$i.length) || 0;
          }
          current += matchIdx + 1;
        }
        if (current < 1 || current > total) {
          current = total = 0;
        }
        return {
          current,
          total
        };
      }
      function _updateUIResultsCount() {
        this._eventBus.dispatch("updatefindmatchescount", {
          source: this,
          matchesCount: _assertClassBrand(_PDFFindController_brand, this, _requestMatchesCount).call(this)
        });
      }
      function _updateUIState(state, previous = false) {
        var _this$_state$query, _this$_state;
        this._eventBus.dispatch("updatefindcontrolstate", {
          source: this,
          state,
          previous,
          matchesCount: _assertClassBrand(_PDFFindController_brand, this, _requestMatchesCount).call(this),
          rawQuery: (_this$_state$query = (_this$_state = this._state) === null || _this$_state === void 0 ? void 0 : _this$_state.query) !== null && _this$_state$query !== void 0 ? _this$_state$query : null
        });
      }
      exports.PDFFindController = PDFFindController;

      /***/
    }), ( /* 21 */
    /***/(__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CharacterType = void 0;
      exports.getCharacterType = getCharacterType;
      const CharacterType = {
        SPACE: 0,
        ALPHA_LETTER: 1,
        PUNCT: 2,
        HAN_LETTER: 3,
        KATAKANA_LETTER: 4,
        HIRAGANA_LETTER: 5,
        HALFWIDTH_KATAKANA_LETTER: 6,
        THAI_LETTER: 7
      };
      exports.CharacterType = CharacterType;
      function isAlphabeticalScript(charCode) {
        return charCode < 0x2e80;
      }
      function isAscii(charCode) {
        return (charCode & 0xff80) === 0;
      }
      function isAsciiAlpha(charCode) {
        return charCode >= 0x61 && charCode <= 0x7a || charCode >= 0x41 && charCode <= 0x5a;
      }
      function isAsciiDigit(charCode) {
        return charCode >= 0x30 && charCode <= 0x39;
      }
      function isAsciiSpace(charCode) {
        return charCode === 0x20 || charCode === 0x09 || charCode === 0x0d || charCode === 0x0a;
      }
      function isHan(charCode) {
        return charCode >= 0x3400 && charCode <= 0x9fff || charCode >= 0xf900 && charCode <= 0xfaff;
      }
      function isKatakana(charCode) {
        return charCode >= 0x30a0 && charCode <= 0x30ff;
      }
      function isHiragana(charCode) {
        return charCode >= 0x3040 && charCode <= 0x309f;
      }
      function isHalfwidthKatakana(charCode) {
        return charCode >= 0xff60 && charCode <= 0xff9f;
      }
      function isThai(charCode) {
        return (charCode & 0xff80) === 0x0e00;
      }
      function getCharacterType(charCode) {
        if (isAlphabeticalScript(charCode)) {
          if (isAscii(charCode)) {
            if (isAsciiSpace(charCode)) {
              return CharacterType.SPACE;
            } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 0x5f) {
              return CharacterType.ALPHA_LETTER;
            }
            return CharacterType.PUNCT;
          } else if (isThai(charCode)) {
            return CharacterType.THAI_LETTER;
          } else if (charCode === 0xa0) {
            return CharacterType.SPACE;
          }
          return CharacterType.ALPHA_LETTER;
        }
        if (isHan(charCode)) {
          return CharacterType.HAN_LETTER;
        } else if (isKatakana(charCode)) {
          return CharacterType.KATAKANA_LETTER;
        } else if (isHiragana(charCode)) {
          return CharacterType.HIRAGANA_LETTER;
        } else if (isHalfwidthKatakana(charCode)) {
          return CharacterType.HALFWIDTH_KATAKANA_LETTER;
        }
        return CharacterType.ALPHA_LETTER;
      }

      /***/
    }), ( /* 22 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFHistory = void 0;
      exports.isDestArraysEqual = isDestArraysEqual;
      exports.isDestHashesEqual = isDestHashesEqual;
      var _ui_utils = __w_pdfjs_require__(6);
      var _event_utils = __w_pdfjs_require__(17);
      const HASH_CHANGE_TIMEOUT = 1000;
      const POSITION_UPDATED_THRESHOLD = 50;
      const UPDATE_VIEWAREA_TIMEOUT = 1000;
      function getCurrentHash() {
        return document.location.hash;
      }
      class PDFHistory {
        constructor({
          linkService,
          eventBus
        }) {
          this.linkService = linkService;
          this.eventBus = eventBus;
          this._initialized = false;
          this._fingerprint = "";
          this.reset();
          this._boundEvents = null;
          this.eventBus._on("pagesinit", () => {
            this._isPagesLoaded = false;
            this.eventBus._on("pagesloaded", evt => {
              this._isPagesLoaded = !!evt.pagesCount;
            }, {
              once: true
            });
          });
        }
        initialize({
          fingerprint,
          resetHistory = false,
          updateUrl = false
        }) {
          if (!fingerprint || typeof fingerprint !== "string") {
            console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
            return;
          }
          if (this._initialized) {
            this.reset();
          }
          const reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint;
          this._fingerprint = fingerprint;
          this._updateUrl = updateUrl === true;
          this._initialized = true;
          this._bindEvents();
          const state = window.history.state;
          this._popStateInProgress = false;
          this._blockHashChange = 0;
          this._currentHash = getCurrentHash();
          this._numPositionUpdates = 0;
          this._uid = this._maxUid = 0;
          this._destination = null;
          this._position = null;
          if (!this._isValidState(state, true) || resetHistory) {
            const {
              hash,
              page,
              rotation
            } = this._parseCurrentHash(true);
            if (!hash || reInitialized || resetHistory) {
              this._pushOrReplaceState(null, true);
              return;
            }
            this._pushOrReplaceState({
              hash,
              page,
              rotation
            }, true);
            return;
          }
          const destination = state.destination;
          this._updateInternalState(destination, state.uid, true);
          if (destination.rotation !== undefined) {
            this._initialRotation = destination.rotation;
          }
          if (destination.dest) {
            this._initialBookmark = JSON.stringify(destination.dest);
            this._destination.page = null;
          } else if (destination.hash) {
            this._initialBookmark = destination.hash;
          } else if (destination.page) {
            this._initialBookmark = `page=${destination.page}`;
          }
        }
        reset() {
          if (this._initialized) {
            this._pageHide();
            this._initialized = false;
            this._unbindEvents();
          }
          if (this._updateViewareaTimeout) {
            clearTimeout(this._updateViewareaTimeout);
            this._updateViewareaTimeout = null;
          }
          this._initialBookmark = null;
          this._initialRotation = null;
        }
        push({
          namedDest = null,
          explicitDest,
          pageNumber
        }) {
          if (!this._initialized) {
            return;
          }
          if (namedDest && typeof namedDest !== "string") {
            console.error("PDFHistory.push: " + `"${namedDest}" is not a valid namedDest parameter.`);
            return;
          } else if (!Array.isArray(explicitDest)) {
            console.error("PDFHistory.push: " + `"${explicitDest}" is not a valid explicitDest parameter.`);
            return;
          } else if (!this._isValidPage(pageNumber)) {
            if (pageNumber !== null || this._destination) {
              console.error("PDFHistory.push: " + `"${pageNumber}" is not a valid pageNumber parameter.`);
              return;
            }
          }
          const hash = namedDest || JSON.stringify(explicitDest);
          if (!hash) {
            return;
          }
          let forceReplace = false;
          if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {
            if (this._destination.page) {
              return;
            }
            forceReplace = true;
          }
          if (this._popStateInProgress && !forceReplace) {
            return;
          }
          this._pushOrReplaceState({
            dest: explicitDest,
            hash,
            page: pageNumber,
            rotation: this.linkService.rotation
          }, forceReplace);
          if (!this._popStateInProgress) {
            this._popStateInProgress = true;
            Promise.resolve().then(() => {
              this._popStateInProgress = false;
            });
          }
        }
        pushPage(pageNumber) {
          var _this$_destination;
          if (!this._initialized) {
            return;
          }
          if (!this._isValidPage(pageNumber)) {
            console.error(`PDFHistory.pushPage: "${pageNumber}" is not a valid page number.`);
            return;
          }
          if (((_this$_destination = this._destination) === null || _this$_destination === void 0 ? void 0 : _this$_destination.page) === pageNumber) {
            return;
          }
          if (this._popStateInProgress) {
            return;
          }
          this._pushOrReplaceState({
            dest: null,
            hash: `page=${pageNumber}`,
            page: pageNumber,
            rotation: this.linkService.rotation
          });
          if (!this._popStateInProgress) {
            this._popStateInProgress = true;
            Promise.resolve().then(() => {
              this._popStateInProgress = false;
            });
          }
        }
        pushCurrentPosition() {
          if (!this._initialized || this._popStateInProgress) {
            return;
          }
          this._tryPushCurrentPosition();
        }
        back() {
          if (!this._initialized || this._popStateInProgress) {
            return;
          }
          const state = window.history.state;
          if (this._isValidState(state) && state.uid > 0) {
            window.history.back();
          }
        }
        forward() {
          if (!this._initialized || this._popStateInProgress) {
            return;
          }
          const state = window.history.state;
          if (this._isValidState(state) && state.uid < this._maxUid) {
            window.history.forward();
          }
        }
        get popStateInProgress() {
          return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
        }
        get initialBookmark() {
          return this._initialized ? this._initialBookmark : null;
        }
        get initialRotation() {
          return this._initialized ? this._initialRotation : null;
        }
        _pushOrReplaceState(destination, forceReplace = false) {
          const shouldReplace = forceReplace || !this._destination;
          const newState = {
            fingerprint: this._fingerprint,
            uid: shouldReplace ? this._uid : this._uid + 1,
            destination
          };
          this._updateInternalState(destination, newState.uid);
          let newUrl;
          if (this._updateUrl && destination !== null && destination !== void 0 && destination.hash) {
            const baseUrl = document.location.href.split("#")[0];
            if (!baseUrl.startsWith("file://")) {
              newUrl = `${baseUrl}#${destination.hash}`;
            }
          }
          if (shouldReplace) {
            window.history.replaceState(newState, "", newUrl);
          } else {
            window.history.pushState(newState, "", newUrl);
          }
        }
        _tryPushCurrentPosition(temporary = false) {
          if (!this._position) {
            return;
          }
          let position = this._position;
          if (temporary) {
            position = Object.assign(Object.create(null), this._position);
            position.temporary = true;
          }
          if (!this._destination) {
            this._pushOrReplaceState(position);
            return;
          }
          if (this._destination.temporary) {
            this._pushOrReplaceState(position, true);
            return;
          }
          if (this._destination.hash === position.hash) {
            return;
          }
          if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {
            return;
          }
          let forceReplace = false;
          if (this._destination.page >= position.first && this._destination.page <= position.page) {
            if (this._destination.dest !== undefined || !this._destination.first) {
              return;
            }
            forceReplace = true;
          }
          this._pushOrReplaceState(position, forceReplace);
        }
        _isValidPage(val) {
          return Number.isInteger(val) && val > 0 && val <= this.linkService.pagesCount;
        }
        _isValidState(state, checkReload = false) {
          if (!state) {
            return false;
          }
          if (state.fingerprint !== this._fingerprint) {
            if (checkReload) {
              if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) {
                return false;
              }
              const [perfEntry] = performance.getEntriesByType("navigation");
              if ((perfEntry === null || perfEntry === void 0 ? void 0 : perfEntry.type) !== "reload") {
                return false;
              }
            } else {
              return false;
            }
          }
          if (!Number.isInteger(state.uid) || state.uid < 0) {
            return false;
          }
          if (state.destination === null || typeof state.destination !== "object") {
            return false;
          }
          return true;
        }
        _updateInternalState(destination, uid, removeTemporary = false) {
          if (this._updateViewareaTimeout) {
            clearTimeout(this._updateViewareaTimeout);
            this._updateViewareaTimeout = null;
          }
          if (removeTemporary && destination !== null && destination !== void 0 && destination.temporary) {
            delete destination.temporary;
          }
          this._destination = destination;
          this._uid = uid;
          this._maxUid = Math.max(this._maxUid, uid);
          this._numPositionUpdates = 0;
        }
        _parseCurrentHash(checkNameddest = false) {
          const hash = unescape(getCurrentHash()).substring(1);
          const params = (0, _ui_utils.parseQueryString)(hash);
          const nameddest = params.get("nameddest") || "";
          let page = params.get("page") | 0;
          if (!this._isValidPage(page) || checkNameddest && nameddest.length > 0) {
            page = null;
          }
          return {
            hash,
            page,
            rotation: this.linkService.rotation
          };
        }
        _updateViewarea({
          location
        }) {
          if (this._updateViewareaTimeout) {
            clearTimeout(this._updateViewareaTimeout);
            this._updateViewareaTimeout = null;
          }
          this._position = {
            hash: location.pdfOpenParams.substring(1),
            page: this.linkService.page,
            first: location.pageNumber,
            rotation: location.rotation
          };
          if (this._popStateInProgress) {
            return;
          }
          if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {
            this._numPositionUpdates++;
          }
          if (UPDATE_VIEWAREA_TIMEOUT > 0) {
            this._updateViewareaTimeout = setTimeout(() => {
              if (!this._popStateInProgress) {
                this._tryPushCurrentPosition(true);
              }
              this._updateViewareaTimeout = null;
            }, UPDATE_VIEWAREA_TIMEOUT);
          }
        }
        _popState({
          state
        }) {
          const newHash = getCurrentHash(),
            hashChanged = this._currentHash !== newHash;
          this._currentHash = newHash;
          if (!state) {
            this._uid++;
            const {
              hash,
              page,
              rotation
            } = this._parseCurrentHash();
            this._pushOrReplaceState({
              hash,
              page,
              rotation
            }, true);
            return;
          }
          if (!this._isValidState(state)) {
            return;
          }
          this._popStateInProgress = true;
          if (hashChanged) {
            this._blockHashChange++;
            (0, _event_utils.waitOnEventOrTimeout)({
              target: window,
              name: "hashchange",
              delay: HASH_CHANGE_TIMEOUT
            }).then(() => {
              this._blockHashChange--;
            });
          }
          const destination = state.destination;
          this._updateInternalState(destination, state.uid, true);
          if ((0, _ui_utils.isValidRotation)(destination.rotation)) {
            this.linkService.rotation = destination.rotation;
          }
          if (destination.dest) {
            this.linkService.goToDestination(destination.dest);
          } else if (destination.hash) {
            this.linkService.setHash(destination.hash);
          } else if (destination.page) {
            this.linkService.page = destination.page;
          }
          Promise.resolve().then(() => {
            this._popStateInProgress = false;
          });
        }
        _pageHide() {
          if (!this._destination || this._destination.temporary) {
            this._tryPushCurrentPosition();
          }
        }
        _bindEvents() {
          if (this._boundEvents) {
            return;
          }
          this._boundEvents = {
            updateViewarea: this._updateViewarea.bind(this),
            popState: this._popState.bind(this),
            pageHide: this._pageHide.bind(this)
          };
          this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea);
          window.addEventListener("popstate", this._boundEvents.popState);
          window.addEventListener("pagehide", this._boundEvents.pageHide);
        }
        _unbindEvents() {
          if (!this._boundEvents) {
            return;
          }
          this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea);
          window.removeEventListener("popstate", this._boundEvents.popState);
          window.removeEventListener("pagehide", this._boundEvents.pageHide);
          this._boundEvents = null;
        }
      }
      exports.PDFHistory = PDFHistory;
      function isDestHashesEqual(destHash, pushHash) {
        if (typeof destHash !== "string" || typeof pushHash !== "string") {
          return false;
        }
        if (destHash === pushHash) {
          return true;
        }
        const nameddest = (0, _ui_utils.parseQueryString)(destHash).get("nameddest");
        if (nameddest === pushHash) {
          return true;
        }
        return false;
      }
      function isDestArraysEqual(firstDest, secondDest) {
        function isEntryEqual(first, second) {
          if (typeof first !== typeof second) {
            return false;
          }
          if (Array.isArray(first) || Array.isArray(second)) {
            return false;
          }
          if (first !== null && typeof first === "object" && second !== null) {
            if (Object.keys(first).length !== Object.keys(second).length) {
              return false;
            }
            for (const key in first) {
              if (!isEntryEqual(first[key], second[key])) {
                return false;
              }
            }
            return true;
          }
          return first === second || Number.isNaN(first) && Number.isNaN(second);
        }
        if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {
          return false;
        }
        if (firstDest.length !== secondDest.length) {
          return false;
        }
        for (let i = 0, ii = firstDest.length; i < ii; i++) {
          if (!isEntryEqual(firstDest[i], secondDest[i])) {
            return false;
          }
        }
        return true;
      }

      /***/
    }), ( /* 23 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.PDFScriptingManager = void 0;
      var _ui_utils = __w_pdfjs_require__(6);
      var _pdfjsLib = __w_pdfjs_require__(3);
      class PDFScriptingManager {
        constructor({
          eventBus,
          sandboxBundleSrc = null,
          scriptingFactory = null,
          docPropertiesLookup = null
        }) {
          this._pdfDocument = null;
          this._pdfViewer = null;
          this._closeCapability = null;
          this._destroyCapability = null;
          this._scripting = null;
          this._mouseState = Object.create(null);
          this._ready = false;
          this._eventBus = eventBus;
          this._sandboxBundleSrc = sandboxBundleSrc;
          this._scriptingFactory = scriptingFactory;
          this._docPropertiesLookup = docPropertiesLookup;
          if (!this._scriptingFactory) {
            window.addEventListener("updatefromsandbox", event => {
              this._eventBus.dispatch("updatefromsandbox", {
                source: window,
                detail: event.detail
              });
            });
          }
        }
        setViewer(pdfViewer) {
          this._pdfViewer = pdfViewer;
        }
        setDocument(pdfDocument) {
          var _this13 = this;
          return _asyncToGenerator(function* () {
            var _this13$_scripting3;
            if (_this13._pdfDocument) {
              yield _this13._destroyScripting();
            }
            _this13._pdfDocument = pdfDocument;
            if (!pdfDocument) {
              return;
            }
            const [objects, calculationOrder, docActions] = yield Promise.all([pdfDocument.getFieldObjects(), pdfDocument.getCalculationOrderIds(), pdfDocument.getJSActions()]);
            if (!objects && !docActions) {
              yield _this13._destroyScripting();
              return;
            }
            if (pdfDocument !== _this13._pdfDocument) {
              return;
            }
            try {
              _this13._scripting = _this13._createScripting();
            } catch (error) {
              console.error(`PDFScriptingManager.setDocument: "${error === null || error === void 0 ? void 0 : error.message}".`);
              yield _this13._destroyScripting();
              return;
            }
            _this13._internalEvents.set("updatefromsandbox", event => {
              if ((event === null || event === void 0 ? void 0 : event.source) !== window) {
                return;
              }
              _this13._updateFromSandbox(event.detail);
            });
            _this13._internalEvents.set("dispatcheventinsandbox", event => {
              var _this13$_scripting;
              (_this13$_scripting = _this13._scripting) === null || _this13$_scripting === void 0 ? void 0 : _this13$_scripting.dispatchEventInSandbox(event.detail);
            });
            _this13._internalEvents.set("pagechanging", ({
              pageNumber,
              previous
            }) => {
              if (pageNumber === previous) {
                return;
              }
              _this13._dispatchPageClose(previous);
              _this13._dispatchPageOpen(pageNumber);
            });
            _this13._internalEvents.set("pagerendered", ({
              pageNumber
            }) => {
              if (!_this13._pageOpenPending.has(pageNumber)) {
                return;
              }
              if (pageNumber !== _this13._pdfViewer.currentPageNumber) {
                return;
              }
              _this13._dispatchPageOpen(pageNumber);
            });
            _this13._internalEvents.set("pagesdestroy", /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator(function* (event) {
                var _this13$_scripting2, _this13$_closeCapabil;
                yield _this13._dispatchPageClose(_this13._pdfViewer.currentPageNumber);
                yield (_this13$_scripting2 = _this13._scripting) === null || _this13$_scripting2 === void 0 ? void 0 : _this13$_scripting2.dispatchEventInSandbox({
                  id: "doc",
                  name: "WillClose"
                });
                (_this13$_closeCapabil = _this13._closeCapability) === null || _this13$_closeCapabil === void 0 ? void 0 : _this13$_closeCapabil.resolve();
              });
              return function (_x2) {
                return _ref3.apply(this, arguments);
              };
            }());
            _this13._domEvents.set("mousedown", event => {
              _this13._mouseState.isDown = true;
            });
            _this13._domEvents.set("mouseup", event => {
              _this13._mouseState.isDown = false;
            });
            for (const [name, listener] of _this13._internalEvents) {
              _this13._eventBus._on(name, listener);
            }
            for (const [name, listener] of _this13._domEvents) {
              window.addEventListener(name, listener, true);
            }
            try {
              const docProperties = yield _this13._getDocProperties();
              if (pdfDocument !== _this13._pdfDocument) {
                return;
              }
              yield _this13._scripting.createSandbox({
                objects,
                calculationOrder,
                appInfo: {
                  platform: navigator.platform,
                  language: navigator.language
                },
                docInfo: {
                  ...docProperties,
                  actions: docActions
                }
              });
              _this13._eventBus.dispatch("sandboxcreated", {
                source: _this13
              });
            } catch (error) {
              console.error(`PDFScriptingManager.setDocument: "${error === null || error === void 0 ? void 0 : error.message}".`);
              yield _this13._destroyScripting();
              return;
            }
            yield (_this13$_scripting3 = _this13._scripting) === null || _this13$_scripting3 === void 0 ? void 0 : _this13$_scripting3.dispatchEventInSandbox({
              id: "doc",
              name: "Open"
            });
            yield _this13._dispatchPageOpen(_this13._pdfViewer.currentPageNumber, true);
            Promise.resolve().then(() => {
              if (pdfDocument === _this13._pdfDocument) {
                _this13._ready = true;
              }
            });
          })();
        }
        dispatchWillSave(detail) {
          var _this14 = this;
          return _asyncToGenerator(function* () {
            var _this14$_scripting;
            return (_this14$_scripting = _this14._scripting) === null || _this14$_scripting === void 0 ? void 0 : _this14$_scripting.dispatchEventInSandbox({
              id: "doc",
              name: "WillSave"
            });
          })();
        }
        dispatchDidSave(detail) {
          var _this15 = this;
          return _asyncToGenerator(function* () {
            var _this15$_scripting;
            return (_this15$_scripting = _this15._scripting) === null || _this15$_scripting === void 0 ? void 0 : _this15$_scripting.dispatchEventInSandbox({
              id: "doc",
              name: "DidSave"
            });
          })();
        }
        dispatchWillPrint(detail) {
          var _this16 = this;
          return _asyncToGenerator(function* () {
            var _this16$_scripting;
            return (_this16$_scripting = _this16._scripting) === null || _this16$_scripting === void 0 ? void 0 : _this16$_scripting.dispatchEventInSandbox({
              id: "doc",
              name: "WillPrint"
            });
          })();
        }
        dispatchDidPrint(detail) {
          var _this17 = this;
          return _asyncToGenerator(function* () {
            var _this17$_scripting;
            return (_this17$_scripting = _this17._scripting) === null || _this17$_scripting === void 0 ? void 0 : _this17$_scripting.dispatchEventInSandbox({
              id: "doc",
              name: "DidPrint"
            });
          })();
        }
        get mouseState() {
          return this._mouseState;
        }
        get destroyPromise() {
          var _this$_destroyCapabil;
          return ((_this$_destroyCapabil = this._destroyCapability) === null || _this$_destroyCapabil === void 0 ? void 0 : _this$_destroyCapabil.promise) || null;
        }
        get ready() {
          return this._ready;
        }
        get _internalEvents() {
          return (0, _pdfjsLib.shadow)(this, "_internalEvents", new Map());
        }
        get _domEvents() {
          return (0, _pdfjsLib.shadow)(this, "_domEvents", new Map());
        }
        get _pageOpenPending() {
          return (0, _pdfjsLib.shadow)(this, "_pageOpenPending", new Set());
        }
        get _visitedPages() {
          return (0, _pdfjsLib.shadow)(this, "_visitedPages", new Map());
        }
        _updateFromSandbox(detail) {
          var _this18 = this;
          return _asyncToGenerator(function* () {
            const isInPresentationMode = _this18._pdfViewer.isInPresentationMode || _this18._pdfViewer.isChangingPresentationMode;
            const {
              id,
              siblings,
              command,
              value
            } = detail;
            if (!id) {
              switch (command) {
                case "clear":
                  console.clear();
                  break;
                case "error":
                  console.error(value);
                  break;
                case "layout":
                  if (isInPresentationMode) {
                    return;
                  }
                  const modes = (0, _ui_utils.apiPageLayoutToViewerModes)(value);
                  _this18._pdfViewer.spreadMode = modes.spreadMode;
                  break;
                case "page-num":
                  _this18._pdfViewer.currentPageNumber = value + 1;
                  break;
                case "print":
                  yield _this18._pdfViewer.pagesPromise;
                  _this18._eventBus.dispatch("print", {
                    source: _this18
                  });
                  break;
                case "println":
                  console.log(value);
                  break;
                case "zoom":
                  if (isInPresentationMode) {
                    return;
                  }
                  _this18._pdfViewer.currentScaleValue = value;
                  break;
                case "SaveAs":
                  _this18._eventBus.dispatch("save", {
                    source: _this18
                  });
                  break;
                case "FirstPage":
                  _this18._pdfViewer.currentPageNumber = 1;
                  break;
                case "LastPage":
                  _this18._pdfViewer.currentPageNumber = _this18._pdfViewer.pagesCount;
                  break;
                case "NextPage":
                  _this18._pdfViewer.nextPage();
                  break;
                case "PrevPage":
                  _this18._pdfViewer.previousPage();
                  break;
                case "ZoomViewIn":
                  if (isInPresentationMode) {
                    return;
                  }
                  _this18._pdfViewer.increaseScale();
                  break;
                case "ZoomViewOut":
                  if (isInPresentationMode) {
                    return;
                  }
                  _this18._pdfViewer.decreaseScale();
                  break;
              }
              return;
            }
            if (isInPresentationMode) {
              if (detail.focus) {
                return;
              }
            }
            delete detail.id;
            delete detail.siblings;
            const ids = siblings ? [id, ...siblings] : [id];
            for (const elementId of ids) {
              const element = document.getElementById(elementId);
              if (element) {
                element.dispatchEvent(new CustomEvent("updatefromsandbox", {
                  detail
                }));
              } else {
                var _this18$_pdfDocument;
                (_this18$_pdfDocument = _this18._pdfDocument) === null || _this18$_pdfDocument === void 0 ? void 0 : _this18$_pdfDocument.annotationStorage.setValue(elementId, detail);
              }
            }
          })();
        }
        _dispatchPageOpen(pageNumber, initialize = false) {
          var _this19 = this;
          return _asyncToGenerator(function* () {
            const pdfDocument = _this19._pdfDocument,
              visitedPages = _this19._visitedPages;
            if (initialize) {
              _this19._closeCapability = (0, _pdfjsLib.createPromiseCapability)();
            }
            if (!_this19._closeCapability) {
              return;
            }
            const pageView = _this19._pdfViewer.getPageView(pageNumber - 1);
            if ((pageView === null || pageView === void 0 ? void 0 : pageView.renderingState) !== _ui_utils.RenderingStates.FINISHED) {
              _this19._pageOpenPending.add(pageNumber);
              return;
            }
            _this19._pageOpenPending.delete(pageNumber);
            const actionsPromise = _asyncToGenerator(function* () {
              var _pageView$pdfPage, _this19$_scripting;
              const actions = yield !visitedPages.has(pageNumber) ? (_pageView$pdfPage = pageView.pdfPage) === null || _pageView$pdfPage === void 0 ? void 0 : _pageView$pdfPage.getJSActions() : null;
              if (pdfDocument !== _this19._pdfDocument) {
                return;
              }
              yield (_this19$_scripting = _this19._scripting) === null || _this19$_scripting === void 0 ? void 0 : _this19$_scripting.dispatchEventInSandbox({
                id: "page",
                name: "PageOpen",
                pageNumber,
                actions
              });
            })();
            visitedPages.set(pageNumber, actionsPromise);
          })();
        }
        _dispatchPageClose(pageNumber) {
          var _this20 = this;
          return _asyncToGenerator(function* () {
            var _this20$_scripting;
            const pdfDocument = _this20._pdfDocument,
              visitedPages = _this20._visitedPages;
            if (!_this20._closeCapability) {
              return;
            }
            if (_this20._pageOpenPending.has(pageNumber)) {
              return;
            }
            const actionsPromise = visitedPages.get(pageNumber);
            if (!actionsPromise) {
              return;
            }
            visitedPages.set(pageNumber, null);
            yield actionsPromise;
            if (pdfDocument !== _this20._pdfDocument) {
              return;
            }
            yield (_this20$_scripting = _this20._scripting) === null || _this20$_scripting === void 0 ? void 0 : _this20$_scripting.dispatchEventInSandbox({
              id: "page",
              name: "PageClose",
              pageNumber
            });
          })();
        }
        _getDocProperties() {
          var _this21 = this;
          return _asyncToGenerator(function* () {
            if (_this21._docPropertiesLookup) {
              return _this21._docPropertiesLookup(_this21._pdfDocument);
            }
            const {
              docPropertiesLookup
            } = __w_pdfjs_require__(24);
            return docPropertiesLookup(_this21._pdfDocument);
          })();
        }
        _createScripting() {
          this._destroyCapability = (0, _pdfjsLib.createPromiseCapability)();
          if (this._scripting) {
            throw new Error("_createScripting: Scripting already exists.");
          }
          if (this._scriptingFactory) {
            return this._scriptingFactory.createScripting({
              sandboxBundleSrc: this._sandboxBundleSrc
            });
          }
          const {
            GenericScripting
          } = __w_pdfjs_require__(24);
          return new GenericScripting(this._sandboxBundleSrc);
        }
        _destroyScripting() {
          var _this22 = this;
          return _asyncToGenerator(function* () {
            var _this22$_destroyCapab2;
            if (!_this22._scripting) {
              var _this22$_destroyCapab;
              _this22._pdfDocument = null;
              (_this22$_destroyCapab = _this22._destroyCapability) === null || _this22$_destroyCapab === void 0 ? void 0 : _this22$_destroyCapab.resolve();
              return;
            }
            if (_this22._closeCapability) {
              yield Promise.race([_this22._closeCapability.promise, new Promise(resolve => {
                setTimeout(resolve, 1000);
              })]).catch(reason => {});
              _this22._closeCapability = null;
            }
            _this22._pdfDocument = null;
            try {
              yield _this22._scripting.destroySandbox();
            } catch (ex) {}
            for (const [name, listener] of _this22._internalEvents) {
              _this22._eventBus._off(name, listener);
            }
            _this22._internalEvents.clear();
            for (const [name, listener] of _this22._domEvents) {
              window.removeEventListener(name, listener, true);
            }
            _this22._domEvents.clear();
            _this22._pageOpenPending.clear();
            _this22._visitedPages.clear();
            _this22._scripting = null;
            delete _this22._mouseState.isDown;
            _this22._ready = false;
            (_this22$_destroyCapab2 = _this22._destroyCapability) === null || _this22$_destroyCapab2 === void 0 ? void 0 : _this22$_destroyCapab2.resolve();
          })();
        }
      }
      exports.PDFScriptingManager = PDFScriptingManager;

      /***/
    }), ( /* 24 */
    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GenericScripting = void 0;
      exports.docPropertiesLookup = docPropertiesLookup;
      var _pdfjsLib = __w_pdfjs_require__(3);
      function docPropertiesLookup(_x3) {
        return _docPropertiesLookup.apply(this, arguments);
      }
      function _docPropertiesLookup() {
        _docPropertiesLookup = _asyncToGenerator(function* (pdfDocument) {
          const url = "",
            baseUrl = url.split("#")[0];
          let {
            info,
            metadata,
            contentDispositionFilename,
            contentLength
          } = yield pdfDocument.getMetadata();
          if (!contentLength) {
            const {
              length
            } = yield pdfDocument.getDownloadInfo();
            contentLength = length;
          }
          return {
            ...info,
            baseURL: baseUrl,
            filesize: contentLength,
            filename: contentDispositionFilename || (0, _pdfjsLib.getPdfFilenameFromUrl)(url),
            metadata: metadata === null || metadata === void 0 ? void 0 : metadata.getRaw(),
            authors: metadata === null || metadata === void 0 ? void 0 : metadata.get("dc:creator"),
            numPages: pdfDocument.numPages,
            URL: url
          };
        });
        return _docPropertiesLookup.apply(this, arguments);
      }
      class GenericScripting {
        constructor(sandboxBundleSrc) {
          this._ready = (0, _pdfjsLib.loadScript)(sandboxBundleSrc, true).then(() => {
            return window.pdfjsSandbox.QuickJSSandbox();
          });
        }
        createSandbox(data) {
          var _this23 = this;
          return _asyncToGenerator(function* () {
            const sandbox = yield _this23._ready;
            sandbox.create(data);
          })();
        }
        dispatchEventInSandbox(event) {
          var _this24 = this;
          return _asyncToGenerator(function* () {
            const sandbox = yield _this24._ready;
            setTimeout(() => sandbox.dispatchEvent(event), 0);
          })();
        }
        destroySandbox() {
          var _this25 = this;
          return _asyncToGenerator(function* () {
            const sandbox = yield _this25._ready;
            sandbox.nukeSandbox();
          })();
        }
      }
      exports.GenericScripting = GenericScripting;

      /***/
    }
    /******/)];
    /************************************************************************/
    /******/ // The module cache
    /******/
    var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/
    function __w_pdfjs_require__(moduleId) {
      /******/ // Check if module is in cache
      /******/var cachedModule = __webpack_module_cache__[moduleId];
      /******/
      if (cachedModule !== undefined) {
        /******/return cachedModule.exports;
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/
      var module = __webpack_module_cache__[moduleId] = {
        /******/ // no module.id needed
        /******/ // no module.loaded needed
        /******/exports: {}
        /******/
      };
      /******/
      /******/ // Execute the module function
      /******/
      __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
      /******/
      /******/ // Return the exports of the module
      /******/
      return module.exports;
      /******/
    }
    /******/
    /************************************************************************/
    var __webpack_exports__ = {};
    // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
    (() => {
      var exports = __webpack_exports__;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "AnnotationLayerBuilder", {
        enumerable: true,
        get: function () {
          return _annotation_layer_builder.AnnotationLayerBuilder;
        }
      });
      Object.defineProperty(exports, "DefaultAnnotationLayerFactory", {
        enumerable: true,
        get: function () {
          return _default_factory.DefaultAnnotationLayerFactory;
        }
      });
      Object.defineProperty(exports, "DefaultStructTreeLayerFactory", {
        enumerable: true,
        get: function () {
          return _default_factory.DefaultStructTreeLayerFactory;
        }
      });
      Object.defineProperty(exports, "DefaultTextLayerFactory", {
        enumerable: true,
        get: function () {
          return _default_factory.DefaultTextLayerFactory;
        }
      });
      Object.defineProperty(exports, "DefaultXfaLayerFactory", {
        enumerable: true,
        get: function () {
          return _default_factory.DefaultXfaLayerFactory;
        }
      });
      Object.defineProperty(exports, "DownloadManager", {
        enumerable: true,
        get: function () {
          return _download_manager.DownloadManager;
        }
      });
      Object.defineProperty(exports, "EventBus", {
        enumerable: true,
        get: function () {
          return _event_utils.EventBus;
        }
      });
      Object.defineProperty(exports, "GenericL10n", {
        enumerable: true,
        get: function () {
          return _genericl10n.GenericL10n;
        }
      });
      Object.defineProperty(exports, "LinkTarget", {
        enumerable: true,
        get: function () {
          return _pdf_link_service.LinkTarget;
        }
      });
      Object.defineProperty(exports, "NullL10n", {
        enumerable: true,
        get: function () {
          return _l10n_utils.NullL10n;
        }
      });
      Object.defineProperty(exports, "PDFFindController", {
        enumerable: true,
        get: function () {
          return _pdf_find_controller.PDFFindController;
        }
      });
      Object.defineProperty(exports, "PDFHistory", {
        enumerable: true,
        get: function () {
          return _pdf_history.PDFHistory;
        }
      });
      Object.defineProperty(exports, "PDFLinkService", {
        enumerable: true,
        get: function () {
          return _pdf_link_service.PDFLinkService;
        }
      });
      Object.defineProperty(exports, "PDFPageView", {
        enumerable: true,
        get: function () {
          return _pdf_page_view.PDFPageView;
        }
      });
      Object.defineProperty(exports, "PDFScriptingManager", {
        enumerable: true,
        get: function () {
          return _pdf_scripting_manager.PDFScriptingManager;
        }
      });
      Object.defineProperty(exports, "PDFSinglePageViewer", {
        enumerable: true,
        get: function () {
          return _pdf_viewer.PDFSinglePageViewer;
        }
      });
      Object.defineProperty(exports, "PDFViewer", {
        enumerable: true,
        get: function () {
          return _pdf_viewer.PDFViewer;
        }
      });
      Object.defineProperty(exports, "ProgressBar", {
        enumerable: true,
        get: function () {
          return _ui_utils.ProgressBar;
        }
      });
      Object.defineProperty(exports, "SimpleLinkService", {
        enumerable: true,
        get: function () {
          return _pdf_link_service.SimpleLinkService;
        }
      });
      Object.defineProperty(exports, "StructTreeLayerBuilder", {
        enumerable: true,
        get: function () {
          return _struct_tree_layer_builder.StructTreeLayerBuilder;
        }
      });
      Object.defineProperty(exports, "TextLayerBuilder", {
        enumerable: true,
        get: function () {
          return _text_layer_builder.TextLayerBuilder;
        }
      });
      Object.defineProperty(exports, "XfaLayerBuilder", {
        enumerable: true,
        get: function () {
          return _xfa_layer_builder.XfaLayerBuilder;
        }
      });
      Object.defineProperty(exports, "parseQueryString", {
        enumerable: true,
        get: function () {
          return _ui_utils.parseQueryString;
        }
      });
      var _default_factory = __w_pdfjs_require__(1);
      var _pdf_link_service = __w_pdfjs_require__(5);
      var _ui_utils = __w_pdfjs_require__(6);
      var _pdf_viewer = __w_pdfjs_require__(10);
      var _annotation_layer_builder = __w_pdfjs_require__(2);
      var _download_manager = __w_pdfjs_require__(16);
      var _event_utils = __w_pdfjs_require__(17);
      var _genericl10n = __w_pdfjs_require__(18);
      var _l10n_utils = __w_pdfjs_require__(4);
      var _pdf_find_controller = __w_pdfjs_require__(20);
      var _pdf_history = __w_pdfjs_require__(22);
      var _pdf_page_view = __w_pdfjs_require__(12);
      var _pdf_scripting_manager = __w_pdfjs_require__(23);
      var _struct_tree_layer_builder = __w_pdfjs_require__(7);
      var _text_layer_builder = __w_pdfjs_require__(8);
      var _xfa_layer_builder = __w_pdfjs_require__(9);
      const pdfjsVersion = '2.14.305';
      const pdfjsBuild = 'eaaa8b4ad';
    })();

    /******/
    return __webpack_exports__;
    /******/
  })();
});

/***/ }),

/***/ 93414:
/*!************************!*\
  !*** canvas (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 70172:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 2001:
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 33779:
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 66558:
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 82258:
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 79717:
/*!************************************************************************************************************!*\
  !*** ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \************************************************************************************************************/
/***/ ((module) => {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 86717:
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/checkPrivateRedeclaration.js ***!
  \*********************************************************************************************************************/
/***/ ((module) => {

function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
module.exports = _checkPrivateRedeclaration, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 97218:
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var checkPrivateRedeclaration = __webpack_require__(/*! ./checkPrivateRedeclaration.js */ 86717);
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
module.exports = _classPrivateFieldInitSpec, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 43798:
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js ***!
  \**********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var checkPrivateRedeclaration = __webpack_require__(/*! ./checkPrivateRedeclaration.js */ 86717);
function _classPrivateMethodInitSpec(obj, privateSet) {
  checkPrivateRedeclaration(obj, privateSet);
  privateSet.add(obj);
}
module.exports = _classPrivateMethodInitSpec, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 64144:
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \**********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ 84376);
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 47289:
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ 242)["default"]);
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 84376:
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \*********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ 242)["default"]);
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ 47289);
function _toPropertyKey(arg) {
  var key = toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 242:
/*!**************************************************************************************************!*\
  !*** ./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/typeof.js ***!
  \**************************************************************************************************/
/***/ ((module) => {

function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 63940:
/*!*****************************************************************!*\
  !*** ./node_modules/ng2-pdf-viewer/fesm2020/ng2-pdf-viewer.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
var pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
var pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PdfViewerComponent": () => (/* binding */ PdfViewerComponent),
/* harmony export */   "PdfViewerModule": () => (/* binding */ PdfViewerModule),
/* harmony export */   "RenderTextMode": () => (/* binding */ RenderTextMode)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/core */ 22560);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ 23280);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 80228);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ 59346);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ 68951);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ 71989);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ 60116);
/* harmony import */ var pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pdfjs-dist/build/pdf */ 7787);
/* harmony import */ var pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pdfjs-dist/web/pdf_viewer */ 90638);






const _c0 = ["pdfViewerContainer"];
function createEventBus(pdfJsViewer, destroy$) {
  const globalEventBus = new pdfJsViewer.EventBus();
  attachDOMEventsToEventBus(globalEventBus, destroy$);
  return globalEventBus;
}
function attachDOMEventsToEventBus(eventBus, destroy$) {
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'documentload').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(() => {
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('documentload', true, true, {});
    window.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'pagerendered').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    pageNumber,
    cssTransform,
    source
  }) => {
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('pagerendered', true, true, {
      pageNumber,
      cssTransform
    });
    source.div.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'textlayerrendered').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    pageNumber,
    source
  }) => {
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('textlayerrendered', true, true, {
      pageNumber
    });
    source.textLayerDiv.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'pagechanging').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    pageNumber,
    source
  }) => {
    const event = document.createEvent('UIEvents');
    event.initEvent('pagechanging', true, true);
    /* tslint:disable:no-string-literal */
    event['pageNumber'] = pageNumber;
    source.container.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'pagesinit').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    source
  }) => {
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('pagesinit', true, true, null);
    source.container.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'pagesloaded').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    pagesCount,
    source
  }) => {
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('pagesloaded', true, true, {
      pagesCount
    });
    source.container.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'scalechange').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    scale,
    presetValue,
    source
  }) => {
    const event = document.createEvent('UIEvents');
    event.initEvent('scalechange', true, true);
    /* tslint:disable:no-string-literal */
    event['scale'] = scale;
    /* tslint:disable:no-string-literal */
    event['presetValue'] = presetValue;
    source.container.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'updateviewarea').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    location,
    source
  }) => {
    const event = document.createEvent('UIEvents');
    event.initEvent('updateviewarea', true, true);
    event['location'] = location;
    source.container.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'find').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    source,
    type,
    query,
    phraseSearch,
    caseSensitive,
    highlightAll,
    findPrevious
  }) => {
    if (source === window) {
      return; // event comes from FirefoxCom, no need to replicate
    }
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('find' + type, true, true, {
      query,
      phraseSearch,
      caseSensitive,
      highlightAll,
      findPrevious
    });
    window.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'attachmentsloaded').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    attachmentsCount,
    source
  }) => {
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('attachmentsloaded', true, true, {
      attachmentsCount
    });
    source.container.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'sidebarviewchanged').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    view,
    source
  }) => {
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('sidebarviewchanged', true, true, {
      view
    });
    source.outerContainer.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'pagemode').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    mode,
    source
  }) => {
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('pagemode', true, true, {
      mode
    });
    source.pdfViewer.container.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'namedaction').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    action,
    source
  }) => {
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('namedaction', true, true, {
      action
    });
    source.pdfViewer.container.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'presentationmodechanged').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    active,
    switchInProgress
  }) => {
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('presentationmodechanged', true, true, {
      active,
      switchInProgress
    });
    window.dispatchEvent(event);
  });
  (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(eventBus, 'outlineloaded').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(destroy$)).subscribe(({
    outlineCount,
    source
  }) => {
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('outlineloaded', true, true, {
      outlineCount
    });
    source.container.dispatchEvent(event);
  });
}
function assign(obj, prop, value) {
  obj[prop] = value;
}
function isSSR() {
  return typeof window === 'undefined';
}

/**
 * Created by vadimdez on 21/06/16.
 */
if (!isSSR()) {
  assign(/*#__PURE__*/ (pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0__, 2))), 'verbosity', pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0__.VerbosityLevel.INFOS);
}
var RenderTextMode;
(function (RenderTextMode) {
  RenderTextMode[RenderTextMode["DISABLED"] = 0] = "DISABLED";
  RenderTextMode[RenderTextMode["ENABLED"] = 1] = "ENABLED";
  RenderTextMode[RenderTextMode["ENHANCED"] = 2] = "ENHANCED";
})(RenderTextMode || (RenderTextMode = {}));
class PdfViewerComponent {
  constructor(element, ngZone) {
    this.element = element;
    this.ngZone = ngZone;
    this.isVisible = false;
    this._cMapsUrl = typeof /*#__PURE__*/ (pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0__, 2))) !== 'undefined' ? `https://unpkg.com/pdfjs-dist@${pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0__.version}/cmaps/` : null;
    this._imageResourcesPath = typeof /*#__PURE__*/ (pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0__, 2))) !== 'undefined' ? `https://unpkg.com/pdfjs-dist@${pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0__.version}/web/images/` : null;
    this._renderText = true;
    this._renderTextMode = RenderTextMode.ENABLED;
    this._stickToPage = false;
    this._originalSize = true;
    this._page = 1;
    this._zoom = 1;
    this._zoomScale = 'page-width';
    this._rotation = 0;
    this._showAll = true;
    this._canAutoResize = true;
    this._fitToPage = false;
    this._externalLinkTarget = 'blank';
    this._showBorders = false;
    this.resizeTimeout = null;
    this.pageScrollTimeout = null;
    this.isInitialized = false;
    this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__.Subject();
    this.afterLoadComplete = new _angular_core__WEBPACK_IMPORTED_MODULE_5__.EventEmitter();
    this.pageRendered = new _angular_core__WEBPACK_IMPORTED_MODULE_5__.EventEmitter();
    this.pageInitialized = new _angular_core__WEBPACK_IMPORTED_MODULE_5__.EventEmitter();
    this.textLayerRendered = new _angular_core__WEBPACK_IMPORTED_MODULE_5__.EventEmitter();
    this.onError = new _angular_core__WEBPACK_IMPORTED_MODULE_5__.EventEmitter();
    this.onProgress = new _angular_core__WEBPACK_IMPORTED_MODULE_5__.EventEmitter();
    this.pageChange = new _angular_core__WEBPACK_IMPORTED_MODULE_5__.EventEmitter(true);
    if (isSSR()) {
      return;
    }
    let pdfWorkerSrc;
    const pdfJsVersion = pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0__.version;
    const versionSpecificPdfWorkerUrl = window[`pdfWorkerSrc${pdfJsVersion}`];
    if (versionSpecificPdfWorkerUrl) {
      pdfWorkerSrc = versionSpecificPdfWorkerUrl;
    } else if (window.hasOwnProperty('pdfWorkerSrc') && typeof window.pdfWorkerSrc === 'string' && window.pdfWorkerSrc) {
      pdfWorkerSrc = window.pdfWorkerSrc;
    } else {
      pdfWorkerSrc = `https://cdn.jsdelivr.net/npm/pdfjs-dist@${pdfJsVersion}/legacy/build/pdf.worker.min.js`;
    }
    assign(pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions, 'workerSrc', pdfWorkerSrc);
  }
  set cMapsUrl(cMapsUrl) {
    this._cMapsUrl = cMapsUrl;
  }
  set page(_page) {
    _page = parseInt(_page, 10) || 1;
    const originalPage = _page;
    if (this._pdf) {
      _page = this.getValidPageNumber(_page);
    }
    this._page = _page;
    if (originalPage !== _page) {
      this.pageChange.emit(_page);
    }
  }
  set renderText(renderText) {
    this._renderText = renderText;
  }
  set renderTextMode(renderTextMode) {
    this._renderTextMode = renderTextMode;
  }
  set originalSize(originalSize) {
    this._originalSize = originalSize;
  }
  set showAll(value) {
    this._showAll = value;
  }
  set stickToPage(value) {
    this._stickToPage = value;
  }
  set zoom(value) {
    if (value <= 0) {
      return;
    }
    this._zoom = value;
  }
  get zoom() {
    return this._zoom;
  }
  set zoomScale(value) {
    this._zoomScale = value;
  }
  get zoomScale() {
    return this._zoomScale;
  }
  set rotation(value) {
    if (!(typeof value === 'number' && value % 90 === 0)) {
      console.warn('Invalid pages rotation angle.');
      return;
    }
    this._rotation = value;
  }
  set externalLinkTarget(value) {
    this._externalLinkTarget = value;
  }
  set autoresize(value) {
    this._canAutoResize = Boolean(value);
  }
  set fitToPage(value) {
    this._fitToPage = Boolean(value);
  }
  set showBorders(value) {
    this._showBorders = Boolean(value);
  }
  static getLinkTarget(type) {
    switch (type) {
      case 'blank':
        return pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1__.LinkTarget.BLANK;
      case 'none':
        return pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1__.LinkTarget.NONE;
      case 'self':
        return pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1__.LinkTarget.SELF;
      case 'parent':
        return pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1__.LinkTarget.PARENT;
      case 'top':
        return pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1__.LinkTarget.TOP;
    }
    return null;
  }
  ngAfterViewChecked() {
    if (this.isInitialized) {
      return;
    }
    const offset = this.pdfViewerContainer.nativeElement.offsetParent;
    if (this.isVisible === true && offset == null) {
      this.isVisible = false;
      return;
    }
    if (this.isVisible === false && offset != null) {
      this.isVisible = true;
      setTimeout(() => {
        this.initialize();
        this.ngOnChanges({
          src: this.src
        });
      });
    }
  }
  ngOnInit() {
    this.initialize();
    this.setupResizeListener();
  }
  ngOnDestroy() {
    this.clear();
    this.destroy$.next();
    this.loadingTask = null;
  }
  ngOnChanges(changes) {
    if (isSSR() || !this.isVisible) {
      return;
    }
    if ('src' in changes) {
      this.loadPDF();
    } else if (this._pdf) {
      if ('renderText' in changes) {
        this.pdfViewer.textLayerMode = this._renderText ? this._renderTextMode : RenderTextMode.DISABLED;
        this.resetPdfDocument();
      } else if ('showAll' in changes) {
        this.setupViewer();
        this.resetPdfDocument();
      }
      if ('page' in changes) {
        const {
          page
        } = changes;
        if (page.currentValue === this._latestScrolledPage) {
          return;
        }
        // New form of page changing: The viewer will now jump to the specified page when it is changed.
        // This behavior is introduced by using the PDFSinglePageViewer
        this.pdfViewer.scrollPageIntoView({
          pageNumber: this._page
        });
      }
      this.update();
    }
  }
  updateSize() {
    (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.from)(this._pdf.getPage(this.pdfViewer.currentPageNumber)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.destroy$)).subscribe({
      next: page => {
        const rotation = this._rotation + page.rotate;
        const viewportWidth = page.getViewport({
          scale: this._zoom,
          rotation
        }).width * PdfViewerComponent.CSS_UNITS;
        let scale = this._zoom;
        let stickToPage = true;
        // Scale the document when it shouldn't be in original size or doesn't fit into the viewport
        if (!this._originalSize || this._fitToPage && viewportWidth > this.pdfViewerContainer.nativeElement.clientWidth) {
          const viewPort = page.getViewport({
            scale: 1,
            rotation
          });
          scale = this.getScale(viewPort.width, viewPort.height);
          stickToPage = !this._stickToPage;
        }
        this.pdfViewer._setScale(scale, stickToPage);
      }
    });
  }
  clear() {
    if (this.loadingTask && !this.loadingTask.destroyed) {
      this.loadingTask.destroy();
    }
    if (this._pdf) {
      this._latestScrolledPage = 0;
      this._pdf.destroy();
      this._pdf = null;
      this.pdfViewer.setDocument(null);
      this.pdfLinkService.setDocument(null, null);
      this.pdfFindController.setDocument(null);
    }
  }
  getPDFLinkServiceConfig() {
    const linkTarget = PdfViewerComponent.getLinkTarget(this._externalLinkTarget);
    if (linkTarget) {
      return {
        externalLinkTarget: linkTarget
      };
    }
    return {};
  }
  initEventBus() {
    this.eventBus = createEventBus(/*#__PURE__*/ (pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1__, 2))), this.destroy$);
    (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(this.eventBus, 'pagerendered').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.destroy$)).subscribe(event => {
      this.pageRendered.emit(event);
    });
    (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(this.eventBus, 'pagesinit').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.destroy$)).subscribe(event => {
      this.pageInitialized.emit(event);
    });
    (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(this.eventBus, 'pagechanging').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.destroy$)).subscribe(({
      pageNumber
    }) => {
      if (this.pageScrollTimeout) {
        clearTimeout(this.pageScrollTimeout);
      }
      this.pageScrollTimeout = window.setTimeout(() => {
        this._latestScrolledPage = pageNumber;
        this.pageChange.emit(pageNumber);
      }, 100);
    });
    (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(this.eventBus, 'textlayerrendered').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.destroy$)).subscribe(event => {
      this.textLayerRendered.emit(event);
    });
  }
  initPDFServices() {
    this.pdfLinkService = new pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1__.PDFLinkService({
      eventBus: this.eventBus,
      ...this.getPDFLinkServiceConfig()
    });
    this.pdfFindController = new pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1__.PDFFindController({
      eventBus: this.eventBus,
      linkService: this.pdfLinkService
    });
  }
  getPDFOptions() {
    return {
      eventBus: this.eventBus,
      container: this.element.nativeElement.querySelector('div'),
      removePageBorders: !this._showBorders,
      linkService: this.pdfLinkService,
      textLayerMode: this._renderText ? this._renderTextMode : RenderTextMode.DISABLED,
      findController: this.pdfFindController,
      renderer: 'canvas',
      l10n: undefined,
      imageResourcesPath: this._imageResourcesPath
    };
  }
  setupViewer() {
    assign(/*#__PURE__*/ (pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0__, 2))), 'disableTextLayer', !this._renderText);
    this.initPDFServices();
    if (this._showAll) {
      this.pdfViewer = new pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1__.PDFViewer(this.getPDFOptions());
    } else {
      this.pdfViewer = new pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_1__.PDFSinglePageViewer(this.getPDFOptions());
    }
    this.pdfLinkService.setViewer(this.pdfViewer);
    this.pdfViewer._currentPageNumber = this._page;
  }
  getValidPageNumber(page) {
    if (page < 1) {
      return 1;
    }
    if (page > this._pdf.numPages) {
      return this._pdf.numPages;
    }
    return page;
  }
  getDocumentParams() {
    const srcType = typeof this.src;
    if (!this._cMapsUrl) {
      return this.src;
    }
    const params = {
      cMapUrl: this._cMapsUrl,
      cMapPacked: true,
      enableXfa: true
    };
    if (srcType === 'string') {
      params.url = this.src;
    } else if (srcType === 'object') {
      if (this.src.byteLength !== undefined) {
        params.data = this.src;
      } else {
        Object.assign(params, this.src);
      }
    }
    return params;
  }
  loadPDF() {
    if (!this.src) {
      return;
    }
    if (this.lastLoaded === this.src) {
      this.update();
      return;
    }
    this.clear();
    this.setupViewer();
    this.loadingTask = pdfjs_dist_build_pdf__WEBPACK_IMPORTED_MODULE_0__.getDocument(this.getDocumentParams());
    this.loadingTask.onProgress = progressData => {
      this.onProgress.emit(progressData);
    };
    const src = this.src;
    (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.from)(this.loadingTask.promise).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.destroy$)).subscribe({
      next: pdf => {
        this._pdf = pdf;
        this.lastLoaded = src;
        this.afterLoadComplete.emit(pdf);
        this.resetPdfDocument();
        this.update();
      },
      error: error => {
        this.lastLoaded = null;
        this.onError.emit(error);
      }
    });
  }
  update() {
    this.page = this._page;
    this.render();
  }
  render() {
    this._page = this.getValidPageNumber(this._page);
    if (this._rotation !== 0 || this.pdfViewer.pagesRotation !== this._rotation) {
      setTimeout(() => {
        this.pdfViewer.pagesRotation = this._rotation;
      });
    }
    if (this._stickToPage) {
      setTimeout(() => {
        this.pdfViewer.currentPageNumber = this._page;
      });
    }
    this.updateSize();
  }
  getScale(viewportWidth, viewportHeight) {
    const borderSize = this._showBorders ? 2 * PdfViewerComponent.BORDER_WIDTH : 0;
    const pdfContainerWidth = this.pdfViewerContainer.nativeElement.clientWidth - borderSize;
    const pdfContainerHeight = this.pdfViewerContainer.nativeElement.clientHeight - borderSize;
    if (pdfContainerHeight === 0 || viewportHeight === 0 || pdfContainerWidth === 0 || viewportWidth === 0) {
      return 1;
    }
    let ratio = 1;
    switch (this._zoomScale) {
      case 'page-fit':
        ratio = Math.min(pdfContainerHeight / viewportHeight, pdfContainerWidth / viewportWidth);
        break;
      case 'page-height':
        ratio = pdfContainerHeight / viewportHeight;
        break;
      case 'page-width':
      default:
        ratio = pdfContainerWidth / viewportWidth;
        break;
    }
    return this._zoom * ratio / PdfViewerComponent.CSS_UNITS;
  }
  resetPdfDocument() {
    this.pdfLinkService.setDocument(this._pdf, null);
    this.pdfFindController.setDocument(this._pdf);
    this.pdfViewer.setDocument(this._pdf);
  }
  initialize() {
    if (isSSR() || !this.isVisible) {
      return;
    }
    this.isInitialized = true;
    this.initEventBus();
    this.setupViewer();
  }
  setupResizeListener() {
    if (isSSR()) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.fromEvent)(window, 'resize').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.debounceTime)(100), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.filter)(() => this._canAutoResize && !!this._pdf), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this.destroy$)).subscribe(() => {
        this.updateSize();
      });
    });
  }
}
PdfViewerComponent.CSS_UNITS = 96.0 / 72.0;
PdfViewerComponent.BORDER_WIDTH = 9;
PdfViewerComponent.fac = function PdfViewerComponent_Factory(t) {
  return new (t || PdfViewerComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_5__["directiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_5__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_5__["directiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_5__.NgZone));
};
PdfViewerComponent.cmp = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_5__["defineComponent"]({
  type: PdfViewerComponent,
  selectors: [["pdf-viewer"]],
  viewQuery: function PdfViewerComponent_Query(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_5__["viewQuery"](_c0, 5);
    }
    if (rf & 2) {
      let _t;
      _angular_core__WEBPACK_IMPORTED_MODULE_5__["queryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_5__["loadQuery"]()) && (ctx.pdfViewerContainer = _t.first);
    }
  },
  inputs: {
    src: "src",
    cMapsUrl: ["c-maps-url", "cMapsUrl"],
    page: "page",
    renderText: ["render-text", "renderText"],
    renderTextMode: ["render-text-mode", "renderTextMode"],
    originalSize: ["original-size", "originalSize"],
    showAll: ["show-all", "showAll"],
    stickToPage: ["stick-to-page", "stickToPage"],
    zoom: "zoom",
    zoomScale: ["zoom-scale", "zoomScale"],
    rotation: "rotation",
    externalLinkTarget: ["external-link-target", "externalLinkTarget"],
    autoresize: "autoresize",
    fitToPage: ["fit-to-page", "fitToPage"],
    showBorders: ["show-borders", "showBorders"]
  },
  outputs: {
    afterLoadComplete: "after-load-complete",
    pageRendered: "page-rendered",
    pageInitialized: "pages-initialized",
    textLayerRendered: "text-layer-rendered",
    onError: "error",
    onProgress: "on-progress",
    pageChange: "pageChange"
  },
  features: [_angular_core__WEBPACK_IMPORTED_MODULE_5__["NgOnChangesFeature"]],
  decls: 3,
  vars: 0,
  consts: [[1, "ng2-pdf-viewer-container"], ["pdfViewerContainer", ""], [1, "pdfViewer"]],
  template: function PdfViewerComponent_Template(rf, ctx) {
    if (rf & 1) {
      _angular_core__WEBPACK_IMPORTED_MODULE_5__["elementStart"](0, "div", 0, 1);
      _angular_core__WEBPACK_IMPORTED_MODULE_5__["element"](2, "div", 2);
      _angular_core__WEBPACK_IMPORTED_MODULE_5__["elementEnd"]();
    }
  },
  styles: [".ng2-pdf-viewer-container[_ngcontent-%COMP%]{overflow-x:auto;position:absolute;height:100%;width:100%;-webkit-overflow-scrolling:touch}[_nghost-%COMP%]{display:block;position:relative}[_nghost-%COMP%]    {--pdfViewer-padding-bottom: 0;--page-margin: 1px auto -8px;--page-border: 9px solid transparent;--spreadHorizontalWrapped-margin-LR: -3.5px;--zoom-factor: 1;--viewport-scale-factor: 1;--shadow: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAYAAAByUDbMAAAA1ElEQVQ4jbWUWw6EIAxFy2NFs/8NzR4UJhpqLsdi5mOmSSMUOfYWqv3S0gMr4XlYH/64gZa/gN3ANYA7KAXALt4ktoQ5MI9YxqaG8bWmsIysMuT6piSQCa4whZThCu8CM4zP9YJaKci9jicPq3NcBWYoPMGUlhG7ivtkB+gVyFY75wXghOvh8t5mto1Mdim6e+MBqH6XsY+YAwjpq3vGF7weTWQptLEDVCZvPTMl5JZZsdh47FHW6qFMyvLYqjcnmdFfY9Xk/KDOlzCusX2mi/ofM7MPkzBcSp4Q1/wAAAAASUVORK5CYII=);--viewer-container-height: 0;--annotation-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--xfa-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\")}@media screen and (forced-colors: active){[_nghost-%COMP%]    {--pdfViewer-padding-bottom: 9px;--page-margin: 9px auto 0;--page-border: none;--spreadHorizontalWrapped-margin-LR: 4.5px}}[_nghost-%COMP%]     .textLayer{position:absolute;text-align:initial;left:0;top:0;right:0;bottom:0;overflow:hidden;opacity:.2;line-height:1;-webkit-text-size-adjust:none;text-size-adjust:none;forced-color-adjust:none}[_nghost-%COMP%]     .textLayer span, [_nghost-%COMP%]     .textLayer br{color:transparent;position:absolute;white-space:pre;cursor:text;transform-origin:0% 0%}[_nghost-%COMP%]     .textLayer span.markedContent{top:0;height:0}[_nghost-%COMP%]     .textLayer .highlight{margin:-1px;padding:1px;background-color:#b400aa;border-radius:4px}[_nghost-%COMP%]     .textLayer .highlight.appended{position:initial}[_nghost-%COMP%]     .textLayer .highlight.begin{border-radius:4px 0 0 4px}[_nghost-%COMP%]     .textLayer .highlight.end{border-radius:0 4px 4px 0}[_nghost-%COMP%]     .textLayer .highlight.middle{border-radius:0}[_nghost-%COMP%]     .textLayer .highlight.selected{background-color:#006400}[_nghost-%COMP%]     .textLayer ::selection{background:blue}[_nghost-%COMP%]     .textLayer br::selection{background:transparent}[_nghost-%COMP%]     .textLayer .endOfContent{display:block;position:absolute;left:0;top:100%;right:0;bottom:0;z-index:-1;cursor:default;-webkit-user-select:none;user-select:none}[_nghost-%COMP%]     .textLayer .endOfContent.active{top:0}[_nghost-%COMP%]     .annotationLayer section{position:absolute;text-align:initial}[_nghost-%COMP%]     .annotationLayer .linkAnnotation>a, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.pushButton>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.pushButton>canvas{position:relative;top:0;left:0;z-index:-1}[_nghost-%COMP%]     .annotationLayer .linkAnnotation>a:hover, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.pushButton>a:hover{opacity:.2;background:yellow;box-shadow:0 2px 10px #ff0}[_nghost-%COMP%]     .annotationLayer .textAnnotation img{position:absolute;cursor:pointer}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea, [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input{background-image:var(--annotation-unfocused-field-background);border:1px solid transparent;box-sizing:border-box;font-size:9px;height:100%;margin:0;padding:0 3px;vertical-align:top;width:100%}[_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select option{padding:0}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea{font:message-box;font-size:9px;resize:none}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input[disabled], [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea[disabled], [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select[disabled], [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input[disabled], [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input[disabled]{background:none;border:1px solid transparent;cursor:not-allowed}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input:hover, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea:hover, [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select:hover, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:hover, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input:hover{border:1px solid black}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input:focus, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea:focus, [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:1px solid transparent}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input :focus, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea :focus, [_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select :focus, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox :focus, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton :focus{background-image:none;background-color:transparent;outline:auto}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:#000;content:\"\";display:block;position:absolute}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:30%;top:20%;width:50%}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0}[_nghost-%COMP%]     .annotationLayer .popupWrapper{position:absolute;width:20em}[_nghost-%COMP%]     .annotationLayer .popup{position:absolute;z-index:200;max-width:20em;background-color:#ff9;box-shadow:0 2px 5px #888;border-radius:2px;padding:6px;margin-left:5px;cursor:pointer;font:message-box;font-size:9px;white-space:normal;word-wrap:break-word}[_nghost-%COMP%]     .annotationLayer .popup>*{font-size:9px}[_nghost-%COMP%]     .annotationLayer .popup h1{display:inline-block}[_nghost-%COMP%]     .annotationLayer .popupDate{display:inline-block;margin-left:5px}[_nghost-%COMP%]     .annotationLayer .popupContent{border-top:1px solid #333333;margin-top:2px;padding-top:2px}[_nghost-%COMP%]     .annotationLayer .richText>*{white-space:pre-wrap}[_nghost-%COMP%]     .annotationLayer .highlightAnnotation, [_nghost-%COMP%]     .annotationLayer .underlineAnnotation, [_nghost-%COMP%]     .annotationLayer .squigglyAnnotation, [_nghost-%COMP%]     .annotationLayer .strikeoutAnnotation, [_nghost-%COMP%]     .annotationLayer .freeTextAnnotation, [_nghost-%COMP%]     .annotationLayer .lineAnnotation svg line, [_nghost-%COMP%]     .annotationLayer .squareAnnotation svg rect, [_nghost-%COMP%]     .annotationLayer .circleAnnotation svg ellipse, [_nghost-%COMP%]     .annotationLayer .polylineAnnotation svg polyline, [_nghost-%COMP%]     .annotationLayer .polygonAnnotation svg polygon, [_nghost-%COMP%]     .annotationLayer .caretAnnotation, [_nghost-%COMP%]     .annotationLayer .inkAnnotation svg polyline, [_nghost-%COMP%]     .annotationLayer .stampAnnotation, [_nghost-%COMP%]     .annotationLayer .fileAttachmentAnnotation{cursor:pointer}[_nghost-%COMP%]     .xfaLayer .highlight{margin:-1px;padding:1px;background-color:#efcbed;border-radius:4px}[_nghost-%COMP%]     .xfaLayer .highlight.appended{position:initial}[_nghost-%COMP%]     .xfaLayer .highlight.begin{border-radius:4px 0 0 4px}[_nghost-%COMP%]     .xfaLayer .highlight.end{border-radius:0 4px 4px 0}[_nghost-%COMP%]     .xfaLayer .highlight.middle{border-radius:0}[_nghost-%COMP%]     .xfaLayer .highlight.selected{background-color:#cbdfcb}[_nghost-%COMP%]     .xfaLayer ::selection{background:blue}[_nghost-%COMP%]     .xfaPage{overflow:hidden;position:relative}[_nghost-%COMP%]     .xfaContentarea{position:absolute}[_nghost-%COMP%]     .xfaPrintOnly{display:none}[_nghost-%COMP%]     .xfaLayer{position:absolute;text-align:initial;top:0;left:0;transform-origin:0 0;line-height:1.2}[_nghost-%COMP%]     .xfaLayer *{color:inherit;font:inherit;font-style:inherit;font-weight:inherit;font-feature-settings:inherit;font-kerning:inherit;letter-spacing:-.01px;text-align:inherit;text-decoration:inherit;box-sizing:border-box;background-color:transparent;padding:0;margin:0;pointer-events:auto;line-height:inherit}[_nghost-%COMP%]     .xfaLayer div{pointer-events:none}[_nghost-%COMP%]     .xfaLayer svg{pointer-events:none}[_nghost-%COMP%]     .xfaLayer svg *{pointer-events:none}[_nghost-%COMP%]     .xfaLayer a{color:#00f}[_nghost-%COMP%]     .xfaRich li{margin-left:3em}[_nghost-%COMP%]     .xfaFont{color:#000;font-weight:400;font-feature-settings:\"kern\" off;font-kerning:none;font-size:10px;font-style:normal;letter-spacing:0;text-decoration:none;vertical-align:0}[_nghost-%COMP%]     .xfaCaption{overflow:hidden;flex:0 0 auto}[_nghost-%COMP%]     .xfaCaptionForCheckButton{overflow:hidden;flex:1 1 auto}[_nghost-%COMP%]     .xfaLabel{height:100%;width:100%}[_nghost-%COMP%]     .xfaLeft{display:flex;flex-direction:row;align-items:center}[_nghost-%COMP%]     .xfaRight{display:flex;flex-direction:row-reverse;align-items:center}[_nghost-%COMP%]     .xfaLeft>.xfaCaption, [_nghost-%COMP%]     .xfaLeft>.xfaCaptionForCheckButton, [_nghost-%COMP%]     .xfaRight>.xfaCaption, [_nghost-%COMP%]     .xfaRight>.xfaCaptionForCheckButton{max-height:100%}[_nghost-%COMP%]     .xfaTop{display:flex;flex-direction:column;align-items:flex-start}[_nghost-%COMP%]     .xfaBottom{display:flex;flex-direction:column-reverse;align-items:flex-start}[_nghost-%COMP%]     .xfaTop>.xfaCaption, [_nghost-%COMP%]     .xfaTop>.xfaCaptionForCheckButton, [_nghost-%COMP%]     .xfaBottom>.xfaCaption, [_nghost-%COMP%]     .xfaBottom>.xfaCaptionForCheckButton{width:100%}[_nghost-%COMP%]     .xfaBorder{background-color:transparent;position:absolute;pointer-events:none}[_nghost-%COMP%]     .xfaWrapped{width:100%;height:100%}[_nghost-%COMP%]     .xfaTextfield:focus, [_nghost-%COMP%]     .xfaSelect:focus{background-image:none;background-color:transparent;outline:auto;outline-offset:-1px}[_nghost-%COMP%]     .xfaCheckbox:focus, [_nghost-%COMP%]     .xfaRadio:focus{outline:auto}[_nghost-%COMP%]     .xfaTextfield, [_nghost-%COMP%]     .xfaSelect{height:100%;width:100%;flex:1 1 auto;border:none;resize:none;background-image:var(--xfa-unfocused-field-background)}[_nghost-%COMP%]     .xfaTop>.xfaTextfield, [_nghost-%COMP%]     .xfaTop>.xfaSelect, [_nghost-%COMP%]     .xfaBottom>.xfaTextfield, [_nghost-%COMP%]     .xfaBottom>.xfaSelect{flex:0 1 auto}[_nghost-%COMP%]     .xfaButton{cursor:pointer;width:100%;height:100%;border:none;text-align:center}[_nghost-%COMP%]     .xfaLink{width:100%;height:100%;position:absolute;top:0;left:0}[_nghost-%COMP%]     .xfaCheckbox, [_nghost-%COMP%]     .xfaRadio{width:100%;height:100%;flex:0 0 auto;border:none}[_nghost-%COMP%]     .xfaRich{white-space:pre-wrap;width:100%;height:100%}[_nghost-%COMP%]     .xfaImage{object-position:left top;object-fit:contain;width:100%;height:100%}[_nghost-%COMP%]     .xfaLrTb, [_nghost-%COMP%]     .xfaRlTb, [_nghost-%COMP%]     .xfaTb{display:flex;flex-direction:column;align-items:stretch}[_nghost-%COMP%]     .xfaLr{display:flex;flex-direction:row;align-items:stretch}[_nghost-%COMP%]     .xfaRl{display:flex;flex-direction:row-reverse;align-items:stretch}[_nghost-%COMP%]     .xfaTb>div{justify-content:left}[_nghost-%COMP%]     .xfaPosition{position:relative}[_nghost-%COMP%]     .xfaArea{position:relative}[_nghost-%COMP%]     .xfaValignMiddle{display:flex;align-items:center}[_nghost-%COMP%]     .xfaTable{display:flex;flex-direction:column;align-items:stretch}[_nghost-%COMP%]     .xfaTable .xfaRow{display:flex;flex-direction:row;align-items:stretch}[_nghost-%COMP%]     .xfaTable .xfaRlRow{display:flex;flex-direction:row-reverse;align-items:stretch;flex:1}[_nghost-%COMP%]     .xfaTable .xfaRlRow>div{flex:1}[_nghost-%COMP%]     .xfaNonInteractive input, [_nghost-%COMP%]     .xfaNonInteractive textarea, [_nghost-%COMP%]     .xfaDisabled input, [_nghost-%COMP%]     .xfaDisabled textarea, [_nghost-%COMP%]     .xfaReadOnly input, [_nghost-%COMP%]     .xfaReadOnly textarea{background:initial}@media print{[_nghost-%COMP%]     .xfaTextfield, [_nghost-%COMP%]     .xfaSelect{background:transparent}[_nghost-%COMP%]     .xfaSelect{-webkit-appearance:none;-moz-appearance:none;appearance:none;text-indent:1px;text-overflow:\"\"}}[_nghost-%COMP%]     .pdfViewer{padding-bottom:var(--pdfViewer-padding-bottom)}[_nghost-%COMP%]     .pdfViewer .canvasWrapper{overflow:hidden}[_nghost-%COMP%]     .pdfViewer .page{direction:ltr;width:816px;height:1056px;margin:var(--page-margin);position:relative;overflow:visible;border:var(--page-border);background-clip:content-box;border-image:var(--shadow) 9 9 repeat;background-color:#fff}[_nghost-%COMP%]     .pdfViewer .dummyPage{position:relative;width:0;height:var(--viewer-container-height)}[_nghost-%COMP%]     .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}[_nghost-%COMP%]     .pdfViewer.singlePageView{display:inline-block}[_nghost-%COMP%]     .pdfViewer.singlePageView .page{margin:0;border:none}[_nghost-%COMP%]     .pdfViewer.scrollHorizontal, [_nghost-%COMP%]     .pdfViewer.scrollWrapped, [_nghost-%COMP%]     .spread{margin-left:3.5px;margin-right:3.5px;text-align:center}[_nghost-%COMP%]     .pdfViewer.scrollHorizontal, [_nghost-%COMP%]     .spread{white-space:nowrap}[_nghost-%COMP%]     .pdfViewer.removePageBorders, [_nghost-%COMP%]     .pdfViewer.scrollHorizontal .spread, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .spread{margin-left:0;margin-right:0}[_nghost-%COMP%]     .spread .page, [_nghost-%COMP%]     .spread .dummyPage, [_nghost-%COMP%]     .pdfViewer.scrollHorizontal .page, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .page, [_nghost-%COMP%]     .pdfViewer.scrollHorizontal .spread, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .spread{display:inline-block;vertical-align:middle}[_nghost-%COMP%]     .spread .page, [_nghost-%COMP%]     .pdfViewer.scrollHorizontal .page, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .page{margin-left:var(--spreadHorizontalWrapped-margin-LR);margin-right:var(--spreadHorizontalWrapped-margin-LR)}[_nghost-%COMP%]     .pdfViewer.removePageBorders .spread .page, [_nghost-%COMP%]     .pdfViewer.removePageBorders.scrollHorizontal .page, [_nghost-%COMP%]     .pdfViewer.removePageBorders.scrollWrapped .page{margin-left:5px;margin-right:5px}[_nghost-%COMP%]     .pdfViewer .page canvas{margin:0;display:block}[_nghost-%COMP%]     .pdfViewer .page canvas[hidden]{display:none}[_nghost-%COMP%]     .pdfViewer .page .loadingIcon{position:absolute;display:block;left:0;top:0;right:0;bottom:0;background:url(data:image/gif;base64,R0lGODlhGAAYAPQQAM7Ozvr6+uDg4LCwsOjo6I6OjsjIyJycnNjY2KioqMDAwPLy8nZ2doaGhri4uGhoaP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/ilPcHRpbWl6ZWQgd2l0aCBodHRwczovL2V6Z2lmLmNvbS9vcHRpbWl6ZQAh+QQJBwAQACwAAAAAGAAYAAAFmiAkjiTkOGVaBgjZNGSgkgKjjM8zLoI8iy+BKCdiCX8iBeMAhEEIPRXLxViYUE9CbCQoFAzFhHY3zkaT3oPvBz1zE4UBsr1eWZH4vAowOBwGAHk8AoQLfH6Agm0Ed3qOAXWOIgQKiWyFJQgDgJEpdG+WEACNEFNFmKVlVzJQk6qdkwqBoi1mebJ3ALNGeIZHtGSwNDS1RZKueCEAIfkECQcAEAAsAAAAABgAGAAABZcgJI4kpChlWgYCWRQkEKgjURgjw4zOg9CjVwuiEyEeO6CxkBC9nA+HiuUqLEyoBZI0Mx4SAFFgQCDZuguBoGv6Dtg0gvpqdhxQQDkBzuUr/4A1JwMKP39pc2mDhYCIc4GQYn6QCwCMeY91l0p6dBAEJ0OfcFRimZ91Mwt0alxxAIZyRmuAsKxDLKKvZbM1tJxmvGKRpn8hACH5BAkHABAALAAAAAAYABgAAAWhICSOJGQYZVoGAnkcJBKoI3EAY1GMCtPSosSBINKJBIwGkHdwBGGQA0OhYpEGQxNqkYzNIITBACEKKBaxxNfBeOCO4vMy0Hg8nDHFeCktkKtfNAtoS4UqAicKBj9zBAKPC4iKi4aRkISGmWWBmjUIAIyHkCUEAKCVo2WmREecVqoCgZhgP4NHrGWCj7e3szSpuxAsoVWxnp6cVV4kyZW+KSEAIfkECQcAEAAsAAAAABgAGAAABZkgJI4kBABlWgYEOQykEKgjMSDjcYxG0dKi108nEhQKQN4rCIMkCgbawjWYnSCLY2yGVSgEooBhWqsGGwxc0RtNBgoMhmJ1QgETjANYFeBKyUmBKQQIdT9JDmgPDQ6EhoKJD4sOgpWWgiwChyqEBH5hmptSoSOZgJ4kLKWkYTF7C2SaqaM/hEWygay4mYG8t6uffFuzl1iANCEAIfkECQcAEAAsAAAAABgAGAAABZ0gJI4khCBlmhKkopBCoI6LIozDMAIHO4uuBVBnOiR+I4FrCDwAZsKdQnaCLIwwmRUA8JmioprWUCjcwlwUMnAoG0qL03k2KCS8cC0UjOzDCQKBfHQFDAwFU4CCfgqFhy9+kZJWgzSKSAcPZn+BfQENDw8OljGWJAFeDoZPYTBnC1GdSXqnsoBolSulX2GyP6hgvnG0KrS3NJNhuSQhACH5BAkHABAALAAAAAAYABgAAAWaICSOJCQIZZoupGGQRKCOC0CMijIiwz2LABtQZxoMfjQhxAXszWQ7gOwECRhh0MCJJRJARTUoIHFAgbfI6uBwAJS01J/i4PClVYHvfV8lbLlIBmwFbQt+aGmChG18jXeGT4dICQxlb4g/AQUMDER9XjR6BAdiDQwINDBmkAsPDVh4cX4imw53iLKuaVqAcUsPqEiidkt6j4AzIQAh+QQJBwAQACwAAAAAGAAYAAAFmSAkjiREEGWaBiSCtCoZCMsIAKOg1LEo0KKbaKFQ9EYLoOkFuQlirNxzCQkUW9GZ0hQd4nyDAWr4G/esYSbyZFYZwu3jqiuvr8u8I2BwOAwASXh1e31/doeHC3klWnElfAlTd46MfQUGk2stCVEGBQWSdCciDg5VDAVYKoEiDQ0iBwxGcj9RDw8+qHIzebc2DJJQJK6qiKVyIQAh+QQJBwAQACwAAAAAGAAYAAAFmSAkjiS0LGWaBiRBtCoZCKgoCCMB1DF0sz6cCQDo5W62l28XAyZFpyECBv3lnCbhUqHMIo0Qg4Jbmn1jRCa4iV27TzfXGjEecOFWMN1OdvvfPGUuXSoKBw6EXokrAwcHRVU0UAeEBANAAAmUI1gNDyhjJgUHLW0iDg8FIqOnBQZrDA9TELE2rEYIDw4jta2LMpCrqld/YQpgIQAh+QQJBwAQACwAAAAAGAAYAAAFmyAkjiS0LGWaBiRBkKw6BgIqCsJcyyMe4yJajhcEml5H26o1PN2QQd3uFiv2AADlAgflIbDdZLgkABOJgep5LfWty4p4zeU+w+XsvJWXliEKDwdEBgMKYQ4PDw1qK3EDCCMAiQ5BCV0LCj+FSDQkgCgGBiYHAy2MIgoMghAHqw4HAGsNDEMFBTekdgwKI7aRB2MwkL2rVHoQoWchACH5BAkHABAALAAAAAAYABgAAAWWICSOJLQsZZoGJEGQrDoGAioKwlzLIx7jIlqOFwSaXkfbqjU83ZBB3e4WK0qrCxyU55peid0qcUwuixyNx6PhILsAcAJazXYj4lvz2MkLiFsHDAlEcABKZwwMBX8pBgoKQxAIigpBA1sLBj+PSDQkB4uSACYDlTMyBgWDEKVnl2QFBUigN61gBQYjtLV5JZ4jtlR6omMhACH5BAkHABAALAAAAAAYABgAAAWaICSOJLQsZZoGJEGQrDoGAioKwlzLIx7jIlqOFwSaXkdbidYanm7I4AjwYDh6saJuJ3JUG1mZi9srPA7EcRimJLrfJYWZUVC8TziXnEG3u/E+cIJaPAFrPQl1aQAIbRAGBZGHJQiMUQKRBkEKbQsAPZaEXQcslSYKmjMyAAdXj34ACkNEiUgDA5t+PAQHn6Ogjkuzry2DNwhuIQAh+QQFBwAQACwAAAAAGAAYAAAFnCAkjiS0LGVaBgBJEGSguo8zCsK4CPIsMg+ECCcKEH0ix6MwhJl4KiOp8UCdmrEbo6EoHpxF8A6aBBZ6vhf5dmAkkGr0CoWs21WGQ2FvsI9xC3l7B311fy93iWGKJQQOhHCAJQB6A3IqcWwJLU90i2FkUiMKlhBELEI6MwgDXRAGhQgAYD6tTqRFAJxpA6mvrqazSKJJhUWMpjlIIQA7) center no-repeat}[_nghost-%COMP%]     .pdfViewer .page .loadingIcon.notVisible{background:none}[_nghost-%COMP%]     .pdfViewer.enablePermissions .textLayer span{-webkit-user-select:none!important;user-select:none!important;cursor:not-allowed}[_nghost-%COMP%]     .pdfPresentationMode .pdfViewer{padding-bottom:0}[_nghost-%COMP%]     .pdfPresentationMode .spread{margin:0}[_nghost-%COMP%]     .pdfPresentationMode .pdfViewer .page{margin:0 auto;border:2px solid transparent}"]
});
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_5__["setClassMetadata"](PdfViewerComponent, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Component,
    args: [{
      selector: 'pdf-viewer',
      template: `
    <div #pdfViewerContainer class="ng2-pdf-viewer-container">
      <div class="pdfViewer"></div>
    </div>
  `,
      styles: [".ng2-pdf-viewer-container{overflow-x:auto;position:absolute;height:100%;width:100%;-webkit-overflow-scrolling:touch}:host{display:block;position:relative}:host ::ng-deep{--pdfViewer-padding-bottom: 0;--page-margin: 1px auto -8px;--page-border: 9px solid transparent;--spreadHorizontalWrapped-margin-LR: -3.5px;--zoom-factor: 1;--viewport-scale-factor: 1;--shadow: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAYAAAByUDbMAAAA1ElEQVQ4jbWUWw6EIAxFy2NFs/8NzR4UJhpqLsdi5mOmSSMUOfYWqv3S0gMr4XlYH/64gZa/gN3ANYA7KAXALt4ktoQ5MI9YxqaG8bWmsIysMuT6piSQCa4whZThCu8CM4zP9YJaKci9jicPq3NcBWYoPMGUlhG7ivtkB+gVyFY75wXghOvh8t5mto1Mdim6e+MBqH6XsY+YAwjpq3vGF7weTWQptLEDVCZvPTMl5JZZsdh47FHW6qFMyvLYqjcnmdFfY9Xk/KDOlzCusX2mi/ofM7MPkzBcSp4Q1/wAAAAASUVORK5CYII=);--viewer-container-height: 0;--annotation-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\");--xfa-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>\")}@media screen and (forced-colors: active){:host ::ng-deep{--pdfViewer-padding-bottom: 9px;--page-margin: 9px auto 0;--page-border: none;--spreadHorizontalWrapped-margin-LR: 4.5px}}:host ::ng-deep .textLayer{position:absolute;text-align:initial;left:0;top:0;right:0;bottom:0;overflow:hidden;opacity:.2;line-height:1;-webkit-text-size-adjust:none;text-size-adjust:none;forced-color-adjust:none}:host ::ng-deep .textLayer span,:host ::ng-deep .textLayer br{color:transparent;position:absolute;white-space:pre;cursor:text;transform-origin:0% 0%}:host ::ng-deep .textLayer span.markedContent{top:0;height:0}:host ::ng-deep .textLayer .highlight{margin:-1px;padding:1px;background-color:#b400aa;border-radius:4px}:host ::ng-deep .textLayer .highlight.appended{position:initial}:host ::ng-deep .textLayer .highlight.begin{border-radius:4px 0 0 4px}:host ::ng-deep .textLayer .highlight.end{border-radius:0 4px 4px 0}:host ::ng-deep .textLayer .highlight.middle{border-radius:0}:host ::ng-deep .textLayer .highlight.selected{background-color:#006400}:host ::ng-deep .textLayer ::selection{background:blue}:host ::ng-deep .textLayer br::selection{background:transparent}:host ::ng-deep .textLayer .endOfContent{display:block;position:absolute;left:0;top:100%;right:0;bottom:0;z-index:-1;cursor:default;-webkit-user-select:none;user-select:none}:host ::ng-deep .textLayer .endOfContent.active{top:0}:host ::ng-deep .annotationLayer section{position:absolute;text-align:initial}:host ::ng-deep .annotationLayer .linkAnnotation>a,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.pushButton>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.pushButton>canvas{position:relative;top:0;left:0;z-index:-1}:host ::ng-deep .annotationLayer .linkAnnotation>a:hover,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.pushButton>a:hover{opacity:.2;background:yellow;box-shadow:0 2px 10px #ff0}:host ::ng-deep .annotationLayer .textAnnotation img{position:absolute;cursor:pointer}:host ::ng-deep .annotationLayer .textWidgetAnnotation input,:host ::ng-deep .annotationLayer .textWidgetAnnotation textarea,:host ::ng-deep .annotationLayer .choiceWidgetAnnotation select,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input{background-image:var(--annotation-unfocused-field-background);border:1px solid transparent;box-sizing:border-box;font-size:9px;height:100%;margin:0;padding:0 3px;vertical-align:top;width:100%}:host ::ng-deep .annotationLayer .choiceWidgetAnnotation select option{padding:0}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}:host ::ng-deep .annotationLayer .textWidgetAnnotation textarea{font:message-box;font-size:9px;resize:none}:host ::ng-deep .annotationLayer .textWidgetAnnotation input[disabled],:host ::ng-deep .annotationLayer .textWidgetAnnotation textarea[disabled],:host ::ng-deep .annotationLayer .choiceWidgetAnnotation select[disabled],:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input[disabled],:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input[disabled]{background:none;border:1px solid transparent;cursor:not-allowed}:host ::ng-deep .annotationLayer .textWidgetAnnotation input:hover,:host ::ng-deep .annotationLayer .textWidgetAnnotation textarea:hover,:host ::ng-deep .annotationLayer .choiceWidgetAnnotation select:hover,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:hover,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input:hover{border:1px solid black}:host ::ng-deep .annotationLayer .textWidgetAnnotation input:focus,:host ::ng-deep .annotationLayer .textWidgetAnnotation textarea:focus,:host ::ng-deep .annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:1px solid transparent}:host ::ng-deep .annotationLayer .textWidgetAnnotation input :focus,:host ::ng-deep .annotationLayer .textWidgetAnnotation textarea :focus,:host ::ng-deep .annotationLayer .choiceWidgetAnnotation select :focus,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox :focus,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton :focus{background-image:none;background-color:transparent;outline:auto}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:#000;content:\"\";display:block;position:absolute}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:30%;top:20%;width:50%}:host ::ng-deep .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}:host ::ng-deep .annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0}:host ::ng-deep .annotationLayer .popupWrapper{position:absolute;width:20em}:host ::ng-deep .annotationLayer .popup{position:absolute;z-index:200;max-width:20em;background-color:#ff9;box-shadow:0 2px 5px #888;border-radius:2px;padding:6px;margin-left:5px;cursor:pointer;font:message-box;font-size:9px;white-space:normal;word-wrap:break-word}:host ::ng-deep .annotationLayer .popup>*{font-size:9px}:host ::ng-deep .annotationLayer .popup h1{display:inline-block}:host ::ng-deep .annotationLayer .popupDate{display:inline-block;margin-left:5px}:host ::ng-deep .annotationLayer .popupContent{border-top:1px solid #333333;margin-top:2px;padding-top:2px}:host ::ng-deep .annotationLayer .richText>*{white-space:pre-wrap}:host ::ng-deep .annotationLayer .highlightAnnotation,:host ::ng-deep .annotationLayer .underlineAnnotation,:host ::ng-deep .annotationLayer .squigglyAnnotation,:host ::ng-deep .annotationLayer .strikeoutAnnotation,:host ::ng-deep .annotationLayer .freeTextAnnotation,:host ::ng-deep .annotationLayer .lineAnnotation svg line,:host ::ng-deep .annotationLayer .squareAnnotation svg rect,:host ::ng-deep .annotationLayer .circleAnnotation svg ellipse,:host ::ng-deep .annotationLayer .polylineAnnotation svg polyline,:host ::ng-deep .annotationLayer .polygonAnnotation svg polygon,:host ::ng-deep .annotationLayer .caretAnnotation,:host ::ng-deep .annotationLayer .inkAnnotation svg polyline,:host ::ng-deep .annotationLayer .stampAnnotation,:host ::ng-deep .annotationLayer .fileAttachmentAnnotation{cursor:pointer}:host ::ng-deep .xfaLayer .highlight{margin:-1px;padding:1px;background-color:#efcbed;border-radius:4px}:host ::ng-deep .xfaLayer .highlight.appended{position:initial}:host ::ng-deep .xfaLayer .highlight.begin{border-radius:4px 0 0 4px}:host ::ng-deep .xfaLayer .highlight.end{border-radius:0 4px 4px 0}:host ::ng-deep .xfaLayer .highlight.middle{border-radius:0}:host ::ng-deep .xfaLayer .highlight.selected{background-color:#cbdfcb}:host ::ng-deep .xfaLayer ::selection{background:blue}:host ::ng-deep .xfaPage{overflow:hidden;position:relative}:host ::ng-deep .xfaContentarea{position:absolute}:host ::ng-deep .xfaPrintOnly{display:none}:host ::ng-deep .xfaLayer{position:absolute;text-align:initial;top:0;left:0;transform-origin:0 0;line-height:1.2}:host ::ng-deep .xfaLayer *{color:inherit;font:inherit;font-style:inherit;font-weight:inherit;font-feature-settings:inherit;font-kerning:inherit;letter-spacing:-.01px;text-align:inherit;text-decoration:inherit;box-sizing:border-box;background-color:transparent;padding:0;margin:0;pointer-events:auto;line-height:inherit}:host ::ng-deep .xfaLayer div{pointer-events:none}:host ::ng-deep .xfaLayer svg{pointer-events:none}:host ::ng-deep .xfaLayer svg *{pointer-events:none}:host ::ng-deep .xfaLayer a{color:#00f}:host ::ng-deep .xfaRich li{margin-left:3em}:host ::ng-deep .xfaFont{color:#000;font-weight:400;font-feature-settings:\"kern\" off;font-kerning:none;font-size:10px;font-style:normal;letter-spacing:0;text-decoration:none;vertical-align:0}:host ::ng-deep .xfaCaption{overflow:hidden;flex:0 0 auto}:host ::ng-deep .xfaCaptionForCheckButton{overflow:hidden;flex:1 1 auto}:host ::ng-deep .xfaLabel{height:100%;width:100%}:host ::ng-deep .xfaLeft{display:flex;flex-direction:row;align-items:center}:host ::ng-deep .xfaRight{display:flex;flex-direction:row-reverse;align-items:center}:host ::ng-deep .xfaLeft>.xfaCaption,:host ::ng-deep .xfaLeft>.xfaCaptionForCheckButton,:host ::ng-deep .xfaRight>.xfaCaption,:host ::ng-deep .xfaRight>.xfaCaptionForCheckButton{max-height:100%}:host ::ng-deep .xfaTop{display:flex;flex-direction:column;align-items:flex-start}:host ::ng-deep .xfaBottom{display:flex;flex-direction:column-reverse;align-items:flex-start}:host ::ng-deep .xfaTop>.xfaCaption,:host ::ng-deep .xfaTop>.xfaCaptionForCheckButton,:host ::ng-deep .xfaBottom>.xfaCaption,:host ::ng-deep .xfaBottom>.xfaCaptionForCheckButton{width:100%}:host ::ng-deep .xfaBorder{background-color:transparent;position:absolute;pointer-events:none}:host ::ng-deep .xfaWrapped{width:100%;height:100%}:host ::ng-deep .xfaTextfield:focus,:host ::ng-deep .xfaSelect:focus{background-image:none;background-color:transparent;outline:auto;outline-offset:-1px}:host ::ng-deep .xfaCheckbox:focus,:host ::ng-deep .xfaRadio:focus{outline:auto}:host ::ng-deep .xfaTextfield,:host ::ng-deep .xfaSelect{height:100%;width:100%;flex:1 1 auto;border:none;resize:none;background-image:var(--xfa-unfocused-field-background)}:host ::ng-deep .xfaTop>.xfaTextfield,:host ::ng-deep .xfaTop>.xfaSelect,:host ::ng-deep .xfaBottom>.xfaTextfield,:host ::ng-deep .xfaBottom>.xfaSelect{flex:0 1 auto}:host ::ng-deep .xfaButton{cursor:pointer;width:100%;height:100%;border:none;text-align:center}:host ::ng-deep .xfaLink{width:100%;height:100%;position:absolute;top:0;left:0}:host ::ng-deep .xfaCheckbox,:host ::ng-deep .xfaRadio{width:100%;height:100%;flex:0 0 auto;border:none}:host ::ng-deep .xfaRich{white-space:pre-wrap;width:100%;height:100%}:host ::ng-deep .xfaImage{object-position:left top;object-fit:contain;width:100%;height:100%}:host ::ng-deep .xfaLrTb,:host ::ng-deep .xfaRlTb,:host ::ng-deep .xfaTb{display:flex;flex-direction:column;align-items:stretch}:host ::ng-deep .xfaLr{display:flex;flex-direction:row;align-items:stretch}:host ::ng-deep .xfaRl{display:flex;flex-direction:row-reverse;align-items:stretch}:host ::ng-deep .xfaTb>div{justify-content:left}:host ::ng-deep .xfaPosition{position:relative}:host ::ng-deep .xfaArea{position:relative}:host ::ng-deep .xfaValignMiddle{display:flex;align-items:center}:host ::ng-deep .xfaTable{display:flex;flex-direction:column;align-items:stretch}:host ::ng-deep .xfaTable .xfaRow{display:flex;flex-direction:row;align-items:stretch}:host ::ng-deep .xfaTable .xfaRlRow{display:flex;flex-direction:row-reverse;align-items:stretch;flex:1}:host ::ng-deep .xfaTable .xfaRlRow>div{flex:1}:host ::ng-deep .xfaNonInteractive input,:host ::ng-deep .xfaNonInteractive textarea,:host ::ng-deep .xfaDisabled input,:host ::ng-deep .xfaDisabled textarea,:host ::ng-deep .xfaReadOnly input,:host ::ng-deep .xfaReadOnly textarea{background:initial}@media print{:host ::ng-deep .xfaTextfield,:host ::ng-deep .xfaSelect{background:transparent}:host ::ng-deep .xfaSelect{-webkit-appearance:none;-moz-appearance:none;appearance:none;text-indent:1px;text-overflow:\"\"}}:host ::ng-deep .pdfViewer{padding-bottom:var(--pdfViewer-padding-bottom)}:host ::ng-deep .pdfViewer .canvasWrapper{overflow:hidden}:host ::ng-deep .pdfViewer .page{direction:ltr;width:816px;height:1056px;margin:var(--page-margin);position:relative;overflow:visible;border:var(--page-border);background-clip:content-box;border-image:var(--shadow) 9 9 repeat;background-color:#fff}:host ::ng-deep .pdfViewer .dummyPage{position:relative;width:0;height:var(--viewer-container-height)}:host ::ng-deep .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}:host ::ng-deep .pdfViewer.singlePageView{display:inline-block}:host ::ng-deep .pdfViewer.singlePageView .page{margin:0;border:none}:host ::ng-deep .pdfViewer.scrollHorizontal,:host ::ng-deep .pdfViewer.scrollWrapped,:host ::ng-deep .spread{margin-left:3.5px;margin-right:3.5px;text-align:center}:host ::ng-deep .pdfViewer.scrollHorizontal,:host ::ng-deep .spread{white-space:nowrap}:host ::ng-deep .pdfViewer.removePageBorders,:host ::ng-deep .pdfViewer.scrollHorizontal .spread,:host ::ng-deep .pdfViewer.scrollWrapped .spread{margin-left:0;margin-right:0}:host ::ng-deep .spread .page,:host ::ng-deep .spread .dummyPage,:host ::ng-deep .pdfViewer.scrollHorizontal .page,:host ::ng-deep .pdfViewer.scrollWrapped .page,:host ::ng-deep .pdfViewer.scrollHorizontal .spread,:host ::ng-deep .pdfViewer.scrollWrapped .spread{display:inline-block;vertical-align:middle}:host ::ng-deep .spread .page,:host ::ng-deep .pdfViewer.scrollHorizontal .page,:host ::ng-deep .pdfViewer.scrollWrapped .page{margin-left:var(--spreadHorizontalWrapped-margin-LR);margin-right:var(--spreadHorizontalWrapped-margin-LR)}:host ::ng-deep .pdfViewer.removePageBorders .spread .page,:host ::ng-deep .pdfViewer.removePageBorders.scrollHorizontal .page,:host ::ng-deep .pdfViewer.removePageBorders.scrollWrapped .page{margin-left:5px;margin-right:5px}:host ::ng-deep .pdfViewer .page canvas{margin:0;display:block}:host ::ng-deep .pdfViewer .page canvas[hidden]{display:none}:host ::ng-deep .pdfViewer .page .loadingIcon{position:absolute;display:block;left:0;top:0;right:0;bottom:0;background:url(data:image/gif;base64,R0lGODlhGAAYAPQQAM7Ozvr6+uDg4LCwsOjo6I6OjsjIyJycnNjY2KioqMDAwPLy8nZ2doaGhri4uGhoaP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/ilPcHRpbWl6ZWQgd2l0aCBodHRwczovL2V6Z2lmLmNvbS9vcHRpbWl6ZQAh+QQJBwAQACwAAAAAGAAYAAAFmiAkjiTkOGVaBgjZNGSgkgKjjM8zLoI8iy+BKCdiCX8iBeMAhEEIPRXLxViYUE9CbCQoFAzFhHY3zkaT3oPvBz1zE4UBsr1eWZH4vAowOBwGAHk8AoQLfH6Agm0Ed3qOAXWOIgQKiWyFJQgDgJEpdG+WEACNEFNFmKVlVzJQk6qdkwqBoi1mebJ3ALNGeIZHtGSwNDS1RZKueCEAIfkECQcAEAAsAAAAABgAGAAABZcgJI4kpChlWgYCWRQkEKgjURgjw4zOg9CjVwuiEyEeO6CxkBC9nA+HiuUqLEyoBZI0Mx4SAFFgQCDZuguBoGv6Dtg0gvpqdhxQQDkBzuUr/4A1JwMKP39pc2mDhYCIc4GQYn6QCwCMeY91l0p6dBAEJ0OfcFRimZ91Mwt0alxxAIZyRmuAsKxDLKKvZbM1tJxmvGKRpn8hACH5BAkHABAALAAAAAAYABgAAAWhICSOJGQYZVoGAnkcJBKoI3EAY1GMCtPSosSBINKJBIwGkHdwBGGQA0OhYpEGQxNqkYzNIITBACEKKBaxxNfBeOCO4vMy0Hg8nDHFeCktkKtfNAtoS4UqAicKBj9zBAKPC4iKi4aRkISGmWWBmjUIAIyHkCUEAKCVo2WmREecVqoCgZhgP4NHrGWCj7e3szSpuxAsoVWxnp6cVV4kyZW+KSEAIfkECQcAEAAsAAAAABgAGAAABZkgJI4kBABlWgYEOQykEKgjMSDjcYxG0dKi108nEhQKQN4rCIMkCgbawjWYnSCLY2yGVSgEooBhWqsGGwxc0RtNBgoMhmJ1QgETjANYFeBKyUmBKQQIdT9JDmgPDQ6EhoKJD4sOgpWWgiwChyqEBH5hmptSoSOZgJ4kLKWkYTF7C2SaqaM/hEWygay4mYG8t6uffFuzl1iANCEAIfkECQcAEAAsAAAAABgAGAAABZ0gJI4khCBlmhKkopBCoI6LIozDMAIHO4uuBVBnOiR+I4FrCDwAZsKdQnaCLIwwmRUA8JmioprWUCjcwlwUMnAoG0qL03k2KCS8cC0UjOzDCQKBfHQFDAwFU4CCfgqFhy9+kZJWgzSKSAcPZn+BfQENDw8OljGWJAFeDoZPYTBnC1GdSXqnsoBolSulX2GyP6hgvnG0KrS3NJNhuSQhACH5BAkHABAALAAAAAAYABgAAAWaICSOJCQIZZoupGGQRKCOC0CMijIiwz2LABtQZxoMfjQhxAXszWQ7gOwECRhh0MCJJRJARTUoIHFAgbfI6uBwAJS01J/i4PClVYHvfV8lbLlIBmwFbQt+aGmChG18jXeGT4dICQxlb4g/AQUMDER9XjR6BAdiDQwINDBmkAsPDVh4cX4imw53iLKuaVqAcUsPqEiidkt6j4AzIQAh+QQJBwAQACwAAAAAGAAYAAAFmSAkjiREEGWaBiSCtCoZCMsIAKOg1LEo0KKbaKFQ9EYLoOkFuQlirNxzCQkUW9GZ0hQd4nyDAWr4G/esYSbyZFYZwu3jqiuvr8u8I2BwOAwASXh1e31/doeHC3klWnElfAlTd46MfQUGk2stCVEGBQWSdCciDg5VDAVYKoEiDQ0iBwxGcj9RDw8+qHIzebc2DJJQJK6qiKVyIQAh+QQJBwAQACwAAAAAGAAYAAAFmSAkjiS0LGWaBiRBtCoZCKgoCCMB1DF0sz6cCQDo5W62l28XAyZFpyECBv3lnCbhUqHMIo0Qg4Jbmn1jRCa4iV27TzfXGjEecOFWMN1OdvvfPGUuXSoKBw6EXokrAwcHRVU0UAeEBANAAAmUI1gNDyhjJgUHLW0iDg8FIqOnBQZrDA9TELE2rEYIDw4jta2LMpCrqld/YQpgIQAh+QQJBwAQACwAAAAAGAAYAAAFmyAkjiS0LGWaBiRBkKw6BgIqCsJcyyMe4yJajhcEml5H26o1PN2QQd3uFiv2AADlAgflIbDdZLgkABOJgep5LfWty4p4zeU+w+XsvJWXliEKDwdEBgMKYQ4PDw1qK3EDCCMAiQ5BCV0LCj+FSDQkgCgGBiYHAy2MIgoMghAHqw4HAGsNDEMFBTekdgwKI7aRB2MwkL2rVHoQoWchACH5BAkHABAALAAAAAAYABgAAAWWICSOJLQsZZoGJEGQrDoGAioKwlzLIx7jIlqOFwSaXkfbqjU83ZBB3e4WK0qrCxyU55peid0qcUwuixyNx6PhILsAcAJazXYj4lvz2MkLiFsHDAlEcABKZwwMBX8pBgoKQxAIigpBA1sLBj+PSDQkB4uSACYDlTMyBgWDEKVnl2QFBUigN61gBQYjtLV5JZ4jtlR6omMhACH5BAkHABAALAAAAAAYABgAAAWaICSOJLQsZZoGJEGQrDoGAioKwlzLIx7jIlqOFwSaXkdbidYanm7I4AjwYDh6saJuJ3JUG1mZi9srPA7EcRimJLrfJYWZUVC8TziXnEG3u/E+cIJaPAFrPQl1aQAIbRAGBZGHJQiMUQKRBkEKbQsAPZaEXQcslSYKmjMyAAdXj34ACkNEiUgDA5t+PAQHn6Ogjkuzry2DNwhuIQAh+QQFBwAQACwAAAAAGAAYAAAFnCAkjiS0LGVaBgBJEGSguo8zCsK4CPIsMg+ECCcKEH0ix6MwhJl4KiOp8UCdmrEbo6EoHpxF8A6aBBZ6vhf5dmAkkGr0CoWs21WGQ2FvsI9xC3l7B311fy93iWGKJQQOhHCAJQB6A3IqcWwJLU90i2FkUiMKlhBELEI6MwgDXRAGhQgAYD6tTqRFAJxpA6mvrqazSKJJhUWMpjlIIQA7) center no-repeat}:host ::ng-deep .pdfViewer .page .loadingIcon.notVisible{background:none}:host ::ng-deep .pdfViewer.enablePermissions .textLayer span{-webkit-user-select:none!important;user-select:none!important;cursor:not-allowed}:host ::ng-deep .pdfPresentationMode .pdfViewer{padding-bottom:0}:host ::ng-deep .pdfPresentationMode .spread{margin:0}:host ::ng-deep .pdfPresentationMode .pdfViewer .page{margin:0 auto;border:2px solid transparent}\n"]
    }]
  }], function () {
    return [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.ElementRef
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.NgZone
    }];
  }, {
    pdfViewerContainer: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.ViewChild,
      args: ['pdfViewerContainer']
    }],
    afterLoadComplete: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Output,
      args: ['after-load-complete']
    }],
    pageRendered: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Output,
      args: ['page-rendered']
    }],
    pageInitialized: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Output,
      args: ['pages-initialized']
    }],
    textLayerRendered: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Output,
      args: ['text-layer-rendered']
    }],
    onError: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Output,
      args: ['error']
    }],
    onProgress: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Output,
      args: ['on-progress']
    }],
    pageChange: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Output
    }],
    src: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input
    }],
    cMapsUrl: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['c-maps-url']
    }],
    page: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['page']
    }],
    renderText: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['render-text']
    }],
    renderTextMode: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['render-text-mode']
    }],
    originalSize: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['original-size']
    }],
    showAll: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['show-all']
    }],
    stickToPage: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['stick-to-page']
    }],
    zoom: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['zoom']
    }],
    zoomScale: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['zoom-scale']
    }],
    rotation: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['rotation']
    }],
    externalLinkTarget: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['external-link-target']
    }],
    autoresize: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['autoresize']
    }],
    fitToPage: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['fit-to-page']
    }],
    showBorders: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.Input,
      args: ['show-borders']
    }]
  });
})();

/**
 * Created by vadimdez on 01/11/2016.
 */
class PdfViewerModule {}
PdfViewerModule.fac = function PdfViewerModule_Factory(t) {
  return new (t || PdfViewerModule)();
};
PdfViewerModule.mod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_5__["defineNgModule"]({
  type: PdfViewerModule
});
PdfViewerModule.inj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_5__["defineInjector"]({});
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_5__["setClassMetadata"](PdfViewerModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_5__.NgModule,
    args: [{
      declarations: [PdfViewerComponent],
      exports: [PdfViewerComponent]
    }]
  }], null, null);
})();

/**
 * Generated bundle index. Do not edit.
 */



/***/ })

}]);
//# sourceMappingURL=default-node_modules_ng2-pdf-viewer_fesm2020_ng2-pdf-viewer_mjs.js.map